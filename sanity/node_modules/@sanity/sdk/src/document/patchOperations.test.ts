import {describe, expect, it} from 'vitest'

import {
  dec,
  diffMatchPatch,
  ensureArrayKeysDeep,
  getDeep,
  getIndexForKey,
  ifRevisionID,
  inc,
  insert,
  jsonMatch,
  parsePath,
  set,
  setDeep,
  setIfMissing,
  stringifyPath,
  unset,
  unsetDeep,
} from './patchOperations'

describe('parsePath', () => {
  it('parses an empty string into an empty path', () => {
    expect(parsePath('')).toEqual([])
  })

  it('parses simple dot notation (simple descent)', () => {
    expect(parsePath('friend.name')).toEqual(['friend', 'name'])
  })

  it('parses a single property', () => {
    expect(parsePath('foo')).toEqual(['foo'])
  })

  it('parses a property with a single numeric index', () => {
    expect(parsePath('items[0]')).toEqual(['items', 0])
  })

  it('parses a property with a negative index', () => {
    expect(parsePath('items[-1]')).toEqual(['items', -1])
  })

  it('parses a property with a keyed segment using double quotes', () => {
    expect(parsePath('items[_key=="value"]')).toEqual(['items', {_key: 'value'}])
  })

  it('parses a property with a keyed segment using single quotes', () => {
    expect(parsePath("items[_key=='value']")).toEqual(['items', {_key: 'value'}])
  })

  it('parses an array range that selects the whole thing (e.g. [:])', () => {
    expect(parsePath('array[:]')).toEqual(['array', ['', '']])
  })

  it('parses an array range with both start and end (e.g. [1:9])', () => {
    expect(parsePath('array[1:9]')).toEqual(['array', [1, 9]])
  })

  it('parses an array range with missing end (e.g. [4:])', () => {
    expect(parsePath('array[4:]')).toEqual(['array', [4, '']])
  })

  it('parses an array range with missing start (e.g. [:4])', () => {
    expect(parsePath('array[:4]')).toEqual(['array', ['', 4]])
  })

  it('parses multiple bracket expressions in one segment', () => {
    expect(parsePath('foo[1][_key=="bar"][2:9]')).toEqual(['foo', 1, {_key: 'bar'}, [2, 9]])
  })

  it('parses segments that mix dot and bracket notation', () => {
    // "a.b[0].c" splits into: ["a"] + parseSegment("b[0]") + ["c"] → ["a", "b", 0, "c"]
    expect(parsePath('a.b[0].c')).toEqual(['a', 'b', 0, 'c'])
  })

  it('parses a segment with text before and after a bracket expression', () => {
    // "foo[1]bar" → ["foo", 1, "bar"]
    expect(parsePath('foo[1]bar')).toEqual(['foo', 1, 'bar'])
  })

  it('parses a segment that is only a bracket expression', () => {
    expect(parsePath('[0]')).toEqual([0])
  })

  it('parses a segment that consists solely of bracket expressions', () => {
    // "[1][_key=="a"]" → [1, { _key: "a" }]
    expect(parsePath('[1][_key=="a"]')).toEqual([1, {_key: 'a'}])
  })

  it('ignores a trailing dot', () => {
    // "foo." → ["foo"]
    expect(parsePath('foo.')).toEqual(['foo'])
  })

  it('ignores a leading dot', () => {
    // ".foo" → ["foo"]
    expect(parsePath('.foo')).toEqual(['foo'])
  })

  it('throws an error when a bracket is not closed', () => {
    expect(() => parsePath('foo[1')).toThrowError('Unmatched "[" in segment: "foo[1"')
  })

  it('throws an error when bracket content is invalid', () => {
    expect(() => parsePath('a[invalid]')).toThrowError('Invalid bracket content: “[invalid]”')
  })
})

describe('stringifyPath', () => {
  it('stringifies a single string segment', () => {
    expect(stringifyPath(['foo'])).toBe('foo')
  })

  it('stringifies multiple string segments using dot notation', () => {
    expect(stringifyPath(['friend', 'name'])).toBe('friend.name')
  })

  it('stringifies a path with a single numeric index', () => {
    expect(stringifyPath(['items', 0])).toBe('items[0]')
  })

  it('stringifies a path with a negative index', () => {
    expect(stringifyPath(['items', -1])).toBe('items[-1]')
  })

  it('stringifies a keyed segment', () => {
    expect(stringifyPath(['items', {_key: 'value'}])).toBe('items[_key=="value"]')
  })

  it('stringifies an array range with both start and end', () => {
    expect(stringifyPath(['array', [1, 9]])).toBe('array[1:9]')
  })

  it('stringifies an array range with missing end', () => {
    expect(stringifyPath(['array', [4, '']])).toBe('array[4:]')
  })

  it('stringifies an array range with missing start', () => {
    expect(stringifyPath(['array', ['', 4]])).toBe('array[:4]')
  })

  it('stringifies an array range with both start and end missing (i.e. ":")', () => {
    expect(stringifyPath(['array', ['', '']])).toBe('array[:]')
  })

  it('stringifies a complex combination of segments