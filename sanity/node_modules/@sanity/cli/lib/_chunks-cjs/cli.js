"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 == "object" || typeof from2 == "function")
    for (let key2 of __getOwnPropNames(from2))
      !__hasOwnProp.call(to, key2) && key2 !== except && __defProp(to, key2, { get: () => from2[key2], enumerable: !(desc = __getOwnPropDesc(from2, key2)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
));
var fs$1 = require("node:fs"), os = require("node:os"), path$3 = require("node:path"), chalk = require("chalk"), loadEnv = require("./loadEnv.js"), require$$0$5 = require("path"), require$$1$2 = require("module"), require$$0$4 = require("fs"), telemetry = require("@sanity/telemetry"), childProcess = require("node:child_process"), fs = require("node:fs/promises"), util$4 = require("node:util"), require$$0$6 = require("os"), require$$5$1 = require("url"), require$$1$3 = require("get-it"), require$$2$1 = require("get-it/middleware"), require$$0$7 = require("constants"), require$$0$8 = require("stream"), require$$0$9 = require("util"), require$$0$a = require("assert"), require$$0$b = require("events"), require$$6$1 = require("http"), semver = require("semver"), pkgDir = require("pkg-dir"), client$1 = require("@sanity/client"), require$$3$1 = require("crypto"), require$$1$4 = require("child_process"), require$$0$c = require("fs/promises"), require$$0$d = require("buffer"), getCliConfig = require("./getCliConfig.js"), journeyConfig = require("./journeyConfig.js"), Stream = require("node:stream"), promises$1 = require("node:stream/promises"), templateValidator = require("@sanity/template-validator"), require$$2$2 = require("string_decoder"), require$$0$e = require("zlib"), require$$7$1 = require("process"), http = require("node:http"), traverse = require("@babel/traverse"), node_url = require("node:url"), node_events = require("node:events"), node_string_decoder = require("node:string_decoder"), process$2 = require("node:process"), require$$2$3 = require("readline"), require$$0$f = require("tty");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
function _interopNamespaceCompat(e) {
  if (e && typeof e == "object" && "default" in e) return e;
  var n = /* @__PURE__ */ Object.create(null);
  return e && Object.keys(e).forEach(function(k) {
    if (k !== "default") {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: !0,
        get: function() {
          return e[k];
        }
      });
    }
  }), n.default = e, Object.freeze(n);
}
function _mergeNamespaces(n, m) {
  return m.forEach(function(e) {
    e && typeof e != "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {
      if (k !== "default" && !(k in n)) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: !0,
          get: function() {
            return e[k];
          }
        });
      }
    });
  }), Object.freeze(n);
}
var fs__namespace = /* @__PURE__ */ _interopNamespaceCompat(fs$1), os__default = /* @__PURE__ */ _interopDefaultCompat(os), path__default = /* @__PURE__ */ _interopDefaultCompat(path$3), chalk__default = /* @__PURE__ */ _interopDefaultCompat(chalk), require$$0__default$1 = /* @__PURE__ */ _interopDefaultCompat(require$$0$5), require$$1__default = /* @__PURE__ */ _interopDefaultCompat(require$$1$2), require$$0__default = /* @__PURE__ */ _interopDefaultCompat(require$$0$4), childProcess__default = /* @__PURE__ */ _interopDefaultCompat(childProcess), fs__default = /* @__PURE__ */ _interopDefaultCompat(fs), util__default = /* @__PURE__ */ _interopDefaultCompat(util$4), require$$0__default$2 = /* @__PURE__ */ _interopDefaultCompat(require$$0$6), require$$5__default = /* @__PURE__ */ _interopDefaultCompat(require$$5$1), require$$1__default$1 = /* @__PURE__ */ _interopDefaultCompat(require$$1$3), require$$2__default = /* @__PURE__ */ _interopDefaultCompat(require$$2$1), require$$0__default$3 = /* @__PURE__ */ _interopDefaultCompat(require$$0$7), require$$0__default$4 = /* @__PURE__ */ _interopDefaultCompat(require$$0$8), require$$0__default$5 = /* @__PURE__ */ _interopDefaultCompat(require$$0$9), require$$0__default$6 = /* @__PURE__ */ _interopDefaultCompat(require$$0$a), require$$0__default$7 = /* @__PURE__ */ _interopDefaultCompat(require$$0$b), require$$6__default = /* @__PURE__ */ _interopDefaultCompat(require$$6$1), semver__default = /* @__PURE__ */ _interopDefaultCompat(semver), pkgDir__default = /* @__PURE__ */ _interopDefaultCompat(pkgDir), require$$3__default = /* @__PURE__ */ _interopDefaultCompat(require$$3$1), require$$1__default$2 = /* @__PURE__ */ _interopDefaultCompat(require$$1$4), require$$0__default$8 = /* @__PURE__ */ _interopDefaultCompat(require$$0$c), require$$0__default$9 = /* @__PURE__ */ _interopDefaultCompat(require$$0$d), Stream__default = /* @__PURE__ */ _interopDefaultCompat(Stream), require$$2__default$1 = /* @__PURE__ */ _interopDefaultCompat(require$$2$2), require$$0__default$a = /* @__PURE__ */ _interopDefaultCompat(require$$0$e), require$$7__default = /* @__PURE__ */ _interopDefaultCompat(require$$7$1), http__default = /* @__PURE__ */ _interopDefaultCompat(http), traverse__default = /* @__PURE__ */ _interopDefaultCompat(traverse), process__default = /* @__PURE__ */ _interopDefaultCompat(process$2), require$$2__default$2 = /* @__PURE__ */ _interopDefaultCompat(require$$2$3), require$$0__default$b = /* @__PURE__ */ _interopDefaultCompat(require$$0$f), resolveFrom$1 = { exports: {} }, hasRequiredResolveFrom;
function requireResolveFrom() {
  if (hasRequiredResolveFrom) return resolveFrom$1.exports;
  hasRequiredResolveFrom = 1;
  const path2 = require$$0__default$1.default, Module = require$$1__default.default, fs2 = require$$0__default.default, resolveFrom2 = (fromDirectory, moduleId, silent) => {
    if (typeof fromDirectory != "string")
      throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory}\``);
    if (typeof moduleId != "string")
      throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
    try {
      fromDirectory = fs2.realpathSync(fromDirectory);
    } catch (error2) {
      if (error2.code === "ENOENT")
        fromDirectory = path2.resolve(fromDirectory);
      else {
        if (silent)
          return;
        throw error2;
      }
    }
    const fromFile = path2.join(fromDirectory, "noop.js"), resolveFileName = () => Module._resolveFilename(moduleId, {
      id: fromFile,
      filename: fromFile,
      paths: Module._nodeModulePaths(fromDirectory)
    });
    if (silent)
      try {
        return resolveFileName();
      } catch {
        return;
      }
    return resolveFileName();
  };
  return resolveFrom$1.exports = (fromDirectory, moduleId) => resolveFrom2(fromDirectory, moduleId), resolveFrom$1.exports.silent = (fromDirectory, moduleId) => resolveFrom2(fromDirectory, moduleId, !0), resolveFrom$1.exports;
}
var resolveFromExports = requireResolveFrom(), resolveFrom = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(resolveFromExports);
const CliCommand = telemetry.defineTrace({
  name: "CLI Command Executed",
  version: 1,
  description: "A CLI command was executed"
});
var lodash$1 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash = lodash$1.exports, hasRequiredLodash;
function requireLodash() {
  return hasRequiredLodash || (hasRequiredLodash = 1, function(module2, exports2) {
    (function() {
      var undefined$1, VERSION = "4.17.21", LARGE_ARRAY_SIZE = 200, CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`", HASH_UNDEFINED = "__lodash_hash_undefined__", MAX_MEMOIZE_SIZE = 500, PLACEHOLDER = "__lodash_placeholder__", CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2, WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512, DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...", HOT_COUNT = 800, HOT_SPAN = 16, LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3, INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = NaN, MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1, wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ], argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g, reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source), reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g, reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source), reTrimStart = /^\s+/, reWhitespace = /\s/, reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /, reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/, reEscapeChar = /\\(\\)?/g, reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, reFlags = /\w*$/, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsHostCtor = /^\[object .+?Constructor\]$/, reIsOctal = /^0o[0-7]+$/i, reIsUint = /^(?:0|[1-9]\d*)$/, reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, reNoMatch = /($^)/, reUnescapedString = /['\n\r\u2028\u2029\\]/g, rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange, rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d", rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")", reApos = RegExp(rsApos, "g"), reComboMark = RegExp(rsCombo, "g"), reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"), reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g"), reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]"), reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ], templateCounter = -1, typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
      var deburredLetters = {
        // Latin-1 Supplement block.
        \u00C0: "A",
        \u00C1: "A",
        \u00C2: "A",
        \u00C3: "A",
        \u00C4: "A",
        \u00C5: "A",
        \u00E0: "a",
        \u00E1: "a",
        \u00E2: "a",
        \u00E3: "a",
        \u00E4: "a",
        \u00E5: "a",
        \u00C7: "C",
        \u00E7: "c",
        \u00D0: "D",
        \u00F0: "d",
        \u00C8: "E",
        \u00C9: "E",
        \u00CA: "E",
        \u00CB: "E",
        \u00E8: "e",
        \u00E9: "e",
        \u00EA: "e",
        \u00EB: "e",
        \u00CC: "I",
        \u00CD: "I",
        \u00CE: "I",
        \u00CF: "I",
        \u00EC: "i",
        \u00ED: "i",
        \u00EE: "i",
        \u00EF: "i",
        \u00D1: "N",
        \u00F1: "n",
        \u00D2: "O",
        \u00D3: "O",
        \u00D4: "O",
        \u00D5: "O",
        \u00D6: "O",
        \u00D8: "O",
        \u00F2: "o",
        \u00F3: "o",
        \u00F4: "o",
        \u00F5: "o",
        \u00F6: "o",
        \u00F8: "o",
        \u00D9: "U",
        \u00DA: "U",
        \u00DB: "U",
        \u00DC: "U",
        \u00F9: "u",
        \u00FA: "u",
        \u00FB: "u",
        \u00FC: "u",
        \u00DD: "Y",
        \u00FD: "y",
        \u00FF: "y",
        \u00C6: "Ae",
        \u00E6: "ae",
        \u00DE: "Th",
        \u00FE: "th",
        \u00DF: "ss",
        // Latin Extended-A block.
        \u0100: "A",
        \u0102: "A",
        \u0104: "A",
        \u0101: "a",
        \u0103: "a",
        \u0105: "a",
        \u0106: "C",
        \u0108: "C",
        \u010A: "C",
        \u010C: "C",
        \u0107: "c",
        \u0109: "c",
        \u010B: "c",
        \u010D: "c",
        \u010E: "D",
        \u0110: "D",
        \u010F: "d",
        \u0111: "d",
        \u0112: "E",
        \u0114: "E",
        \u0116: "E",
        \u0118: "E",
        \u011A: "E",
        \u0113: "e",
        \u0115: "e",
        \u0117: "e",
        \u0119: "e",
        \u011B: "e",
        \u011C: "G",
        \u011E: "G",
        \u0120: "G",
        \u0122: "G",
        \u011D: "g",
        \u011F: "g",
        \u0121: "g",
        \u0123: "g",
        \u0124: "H",
        \u0126: "H",
        \u0125: "h",
        \u0127: "h",
        \u0128: "I",
        \u012A: "I",
        \u012C: "I",
        \u012E: "I",
        \u0130: "I",
        \u0129: "i",
        \u012B: "i",
        \u012D: "i",
        \u012F: "i",
        \u0131: "i",
        \u0134: "J",
        \u0135: "j",
        \u0136: "K",
        \u0137: "k",
        \u0138: "k",
        \u0139: "L",
        \u013B: "L",
        \u013D: "L",
        \u013F: "L",
        \u0141: "L",
        \u013A: "l",
        \u013C: "l",
        \u013E: "l",
        \u0140: "l",
        \u0142: "l",
        \u0143: "N",
        \u0145: "N",
        \u0147: "N",
        \u014A: "N",
        \u0144: "n",
        \u0146: "n",
        \u0148: "n",
        \u014B: "n",
        \u014C: "O",
        \u014E: "O",
        \u0150: "O",
        \u014D: "o",
        \u014F: "o",
        \u0151: "o",
        \u0154: "R",
        \u0156: "R",
        \u0158: "R",
        \u0155: "r",
        \u0157: "r",
        \u0159: "r",
        \u015A: "S",
        \u015C: "S",
        \u015E: "S",
        \u0160: "S",
        \u015B: "s",
        \u015D: "s",
        \u015F: "s",
        \u0161: "s",
        \u0162: "T",
        \u0164: "T",
        \u0166: "T",
        \u0163: "t",
        \u0165: "t",
        \u0167: "t",
        \u0168: "U",
        \u016A: "U",
        \u016C: "U",
        \u016E: "U",
        \u0170: "U",
        \u0172: "U",
        \u0169: "u",
        \u016B: "u",
        \u016D: "u",
        \u016F: "u",
        \u0171: "u",
        \u0173: "u",
        \u0174: "W",
        \u0175: "w",
        \u0176: "Y",
        \u0177: "y",
        \u0178: "Y",
        \u0179: "Z",
        \u017B: "Z",
        \u017D: "Z",
        \u017A: "z",
        \u017C: "z",
        \u017E: "z",
        \u0132: "IJ",
        \u0133: "ij",
        \u0152: "Oe",
        \u0153: "oe",
        \u0149: "'n",
        \u017F: "s"
      }, htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      }, htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      }, stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      }, freeParseFloat = parseFloat, freeParseInt = parseInt, freeGlobal = typeof loadEnv.commonjsGlobal == "object" && loadEnv.commonjsGlobal && loadEnv.commonjsGlobal.Object === Object && loadEnv.commonjsGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root2 = freeGlobal || freeSelf || Function("return this")(), freeExports = exports2 && !exports2.nodeType && exports2, freeModule = freeExports && !0 && module2 && !module2.nodeType && module2, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
        try {
          var types2 = freeModule && freeModule.require && freeModule.require("util").types;
          return types2 || freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch {
        }
      }(), nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        for (var index = -1, length = array == null ? 0 : array.length; ++index < length; ) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        for (var index = -1, length = array == null ? 0 : array.length; ++index < length && iteratee(array[index], index, array) !== !1; )
          ;
        return array;
      }
      function arrayEachRight(array, iteratee) {
        for (var length = array == null ? 0 : array.length; length-- && iteratee(array[length], length, array) !== !1; )
          ;
        return array;
      }
      function arrayEvery(array, predicate) {
        for (var index = -1, length = array == null ? 0 : array.length; ++index < length; )
          if (!predicate(array[index], index, array))
            return !1;
        return !0;
      }
      function arrayFilter(array, predicate) {
        for (var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
          var value = array[index];
          predicate(value, index, array) && (result[resIndex++] = value);
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        for (var index = -1, length = array == null ? 0 : array.length; ++index < length; )
          if (comparator(value, array[index]))
            return !0;
        return !1;
      }
      function arrayMap(array, iteratee) {
        for (var index = -1, length = array == null ? 0 : array.length, result = Array(length); ++index < length; )
          result[index] = iteratee(array[index], index, array);
        return result;
      }
      function arrayPush(array, values) {
        for (var index = -1, length = values.length, offset = array.length; ++index < length; )
          array[offset + index] = values[index];
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        for (initAccum && length && (accumulator = array[++index]); ++index < length; )
          accumulator = iteratee(accumulator, array[index], index, array);
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        for (initAccum && length && (accumulator = array[--length]); length--; )
          accumulator = iteratee(accumulator, array[length], length, array);
        return accumulator;
      }
      function arraySome(array, predicate) {
        for (var index = -1, length = array == null ? 0 : array.length; ++index < length; )
          if (predicate(array[index], index, array))
            return !0;
        return !1;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        return eachFunc(collection, function(value, key2, collection2) {
          if (predicate(value, key2, collection2))
            return result = key2, !1;
        }), result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        for (var length = array.length, index = fromIndex + (fromRight ? 1 : -1); fromRight ? index-- : ++index < length; )
          if (predicate(array[index], index, array))
            return index;
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        for (var index = fromIndex - 1, length = array.length; ++index < length; )
          if (comparator(array[index], value))
            return index;
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key2) {
        return function(object) {
          return object == null ? undefined$1 : object[key2];
        };
      }
      function basePropertyOf(object) {
        return function(key2) {
          return object == null ? undefined$1 : object[key2];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        return eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = !1, value) : iteratee(accumulator, value, index, collection2);
        }), accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        for (array.sort(comparer); length--; )
          array[length] = array[length].value;
        return array;
      }
      function baseSum(array, iteratee) {
        for (var result, index = -1, length = array.length; ++index < length; ) {
          var current = iteratee(array[index]);
          current !== undefined$1 && (result = result === undefined$1 ? current : result + current);
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        for (var index = -1, result = Array(n); ++index < n; )
          result[index] = iteratee(index);
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key2) {
          return [key2, object[key2]];
        });
      }
      function baseTrim(string) {
        return string && string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "");
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key2) {
          return object[key2];
        });
      }
      function cacheHas(cache, key2) {
        return cache.has(key2);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        for (var index = -1, length = strSymbols.length; ++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; )
          ;
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        for (var index = strSymbols.length; index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; )
          ;
        return index;
      }
      function countHolders(array, placeholder) {
        for (var length = array.length, result = 0; length--; )
          array[length] === placeholder && ++result;
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters), escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key2) {
        return object == null ? undefined$1 : object[key2];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator2) {
        for (var data, result = []; !(data = iterator2.next()).done; )
          result.push(data.value);
        return result;
      }
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        return map2.forEach(function(value, key2) {
          result[++index] = [key2, value];
        }), result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length; ) {
          var value = array[index];
          (value === placeholder || value === PLACEHOLDER) && (array[index] = PLACEHOLDER, result[resIndex++] = index);
        }
        return result;
      }
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        return set2.forEach(function(value) {
          result[++index] = value;
        }), result;
      }
      function setToPairs(set2) {
        var index = -1, result = Array(set2.size);
        return set2.forEach(function(value) {
          result[++index] = [value, value];
        }), result;
      }
      function strictIndexOf(array, value, fromIndex) {
        for (var index = fromIndex - 1, length = array.length; ++index < length; )
          if (array[index] === value)
            return index;
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        for (var index = fromIndex + 1; index--; )
          if (array[index] === value)
            return index;
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        for (var index = string.length; index-- && reWhitespace.test(string.charAt(index)); )
          ;
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        for (var result = reUnicode.lastIndex = 0; reUnicode.test(string); )
          ++result;
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root2 : _.defaults(root2.Object(), context, _.pick(root2, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError, arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype, coreJsData = context["__core-js_shared__"], funcToString = funcProto.toString, hasOwnProperty2 = objectProto.hasOwnProperty, idCounter = 0, maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }(), nativeObjectToString = objectProto.toString, objectCtorString = funcToString.call(Object2), oldDash = root2._, reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        ), Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1, defineProperty2 = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            return func({}, "", {}), func;
          } catch {
          }
        }(), ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout, nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse, DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create"), metaMap = WeakMap2 && new WeakMap2(), realNames = {}, dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2), symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
        function lodash2(value) {
          if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper)
              return value;
            if (hasOwnProperty2.call(value, "__wrapped__"))
              return wrapperClone(value);
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject2(proto))
              return {};
            if (objectCreate)
              return objectCreate(proto);
            object.prototype = proto;
            var result2 = new object();
            return object.prototype = undefined$1, result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value, this.__actions__ = [], this.__chain__ = !!chainAll, this.__index__ = 0, this.__values__ = undefined$1;
        }
        lodash2.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          escape: reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          evaluate: reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          interpolate: reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          variable: "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          imports: {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            _: lodash2
          }
        }, lodash2.prototype = baseLodash.prototype, lodash2.prototype.constructor = lodash2, LodashWrapper.prototype = baseCreate(baseLodash.prototype), LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = MAX_ARRAY_LENGTH, this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          return result2.__actions__ = copyArray(this.__actions__), result2.__dir__ = this.__dir__, result2.__filtered__ = this.__filtered__, result2.__iteratees__ = copyArray(this.__iteratees__), result2.__takeCount__ = this.__takeCount__, result2.__views__ = copyArray(this.__views__), result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1, result2.__filtered__ = !0;
          } else
            result2 = this.clone(), result2.__dir__ *= -1;
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length)
            return baseWrapperValue(array, this.__actions__);
          var result2 = [];
          outer:
            for (; length-- && resIndex < takeCount; ) {
              index += dir;
              for (var iterIndex = -1, value = array[index]; ++iterIndex < iterLength; ) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed = iteratee2(value);
                if (type2 == LAZY_MAP_FLAG)
                  value = computed;
                else if (!computed) {
                  if (type2 == LAZY_FILTER_FLAG)
                    continue outer;
                  break outer;
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype), LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          for (this.clear(); ++index < length; ) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
        }
        function hashDelete(key2) {
          var result2 = this.has(key2) && delete this.__data__[key2];
          return this.size -= result2 ? 1 : 0, result2;
        }
        function hashGet(key2) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key2];
            return result2 === HASH_UNDEFINED ? undefined$1 : result2;
          }
          return hasOwnProperty2.call(data, key2) ? data[key2] : undefined$1;
        }
        function hashHas(key2) {
          var data = this.__data__;
          return nativeCreate ? data[key2] !== undefined$1 : hasOwnProperty2.call(data, key2);
        }
        function hashSet(key2, value) {
          var data = this.__data__;
          return this.size += this.has(key2) ? 0 : 1, data[key2] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value, this;
        }
        Hash.prototype.clear = hashClear, Hash.prototype.delete = hashDelete, Hash.prototype.get = hashGet, Hash.prototype.has = hashHas, Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          for (this.clear(); ++index < length; ) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [], this.size = 0;
        }
        function listCacheDelete(key2) {
          var data = this.__data__, index = assocIndexOf(data, key2);
          if (index < 0)
            return !1;
          var lastIndex = data.length - 1;
          return index == lastIndex ? data.pop() : splice.call(data, index, 1), --this.size, !0;
        }
        function listCacheGet(key2) {
          var data = this.__data__, index = assocIndexOf(data, key2);
          return index < 0 ? undefined$1 : data[index][1];
        }
        function listCacheHas(key2) {
          return assocIndexOf(this.__data__, key2) > -1;
        }
        function listCacheSet(key2, value) {
          var data = this.__data__, index = assocIndexOf(data, key2);
          return index < 0 ? (++this.size, data.push([key2, value])) : data[index][1] = value, this;
        }
        ListCache.prototype.clear = listCacheClear, ListCache.prototype.delete = listCacheDelete, ListCache.prototype.get = listCacheGet, ListCache.prototype.has = listCacheHas, ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          for (this.clear(); ++index < length; ) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0, this.__data__ = {
            hash: new Hash(),
            map: new (Map2 || ListCache)(),
            string: new Hash()
          };
        }
        function mapCacheDelete(key2) {
          var result2 = getMapData(this, key2).delete(key2);
          return this.size -= result2 ? 1 : 0, result2;
        }
        function mapCacheGet(key2) {
          return getMapData(this, key2).get(key2);
        }
        function mapCacheHas(key2) {
          return getMapData(this, key2).has(key2);
        }
        function mapCacheSet(key2, value) {
          var data = getMapData(this, key2), size2 = data.size;
          return data.set(key2, value), this.size += data.size == size2 ? 0 : 1, this;
        }
        MapCache.prototype.clear = mapCacheClear, MapCache.prototype.delete = mapCacheDelete, MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          for (this.__data__ = new MapCache(); ++index < length; )
            this.add(values2[index]);
        }
        function setCacheAdd(value) {
          return this.__data__.set(value, HASH_UNDEFINED), this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd, SetCache.prototype.has = setCacheHas;
        function Stack2(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache(), this.size = 0;
        }
        function stackDelete(key2) {
          var data = this.__data__, result2 = data.delete(key2);
          return this.size = data.size, result2;
        }
        function stackGet(key2) {
          return this.__data__.get(key2);
        }
        function stackHas(key2) {
          return this.__data__.has(key2);
        }
        function stackSet(key2, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs2 = data.__data__;
            if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1)
              return pairs2.push([key2, value]), this.size = ++data.size, this;
            data = this.__data__ = new MapCache(pairs2);
          }
          return data.set(key2, value), this.size = data.size, this;
        }
        Stack2.prototype.clear = stackClear, Stack2.prototype.delete = stackDelete, Stack2.prototype.get = stackGet, Stack2.prototype.has = stackHas, Stack2.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key2 in value)
            (inherited || hasOwnProperty2.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
            isIndex(key2, length))) && result2.push(key2);
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined$1;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key2, value) {
          (value !== undefined$1 && !eq(object[key2], value) || value === undefined$1 && !(key2 in object)) && baseAssignValue(object, key2, value);
        }
        function assignValue(object, key2, value) {
          var objValue = object[key2];
          (!(hasOwnProperty2.call(object, key2) && eq(objValue, value)) || value === undefined$1 && !(key2 in object)) && baseAssignValue(object, key2, value);
        }
        function assocIndexOf(array, key2) {
          for (var length = array.length; length--; )
            if (eq(array[length][0], key2))
              return length;
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          return baseEach(collection, function(value, key2, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          }), accumulator;
        }
        function baseAssign(object, source2) {
          return object && copyObject(source2, keys(source2), object);
        }
        function baseAssignIn(object, source2) {
          return object && copyObject(source2, keysIn(source2), object);
        }
        function baseAssignValue(object, key2, value) {
          key2 == "__proto__" && defineProperty2 ? defineProperty2(object, key2, {
            configurable: !0,
            enumerable: !0,
            value,
            writable: !0
          }) : object[key2] = value;
        }
        function baseAt(object, paths) {
          for (var index = -1, length = paths.length, result2 = Array2(length), skip2 = object == null; ++index < length; )
            result2[index] = skip2 ? undefined$1 : get(object, paths[index]);
          return result2;
        }
        function baseClamp(number2, lower, upper) {
          return number2 === number2 && (upper !== undefined$1 && (number2 = number2 <= upper ? number2 : upper), lower !== undefined$1 && (number2 = number2 >= lower ? number2 : lower)), number2;
        }
        function baseClone(value, bitmask, customizer, key2, object, stack2) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer && (result2 = object ? customizer(value, key2, object, stack2) : customizer(value)), result2 !== undefined$1)
            return result2;
          if (!isObject2(value))
            return value;
          var isArr = isArray2(value);
          if (isArr) {
            if (result2 = initCloneArray(value), !isDeep)
              return copyArray(value, result2);
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value))
              return cloneBuffer(value, isDeep);
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              if (result2 = isFlat || isFunc ? {} : initCloneObject(value), !isDeep)
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            } else {
              if (!cloneableTags[tag])
                return object ? value : {};
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack2 || (stack2 = new Stack2());
          var stacked = stack2.get(value);
          if (stacked)
            return stacked;
          stack2.set(value, result2), isSet(value) ? value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
          }) : isMap(value) && value.forEach(function(subValue, key3) {
            result2.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
          });
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys, props = isArr ? undefined$1 : keysFunc(value);
          return arrayEach(props || value, function(subValue, key3) {
            props && (key3 = subValue, subValue = value[key3]), assignValue(result2, key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
          }), result2;
        }
        function baseConforms(source2) {
          var props = keys(source2);
          return function(object) {
            return baseConformsTo(object, source2, props);
          };
        }
        function baseConformsTo(object, source2, props) {
          var length = props.length;
          if (object == null)
            return !length;
          for (object = Object2(object); length--; ) {
            var key2 = props[length], predicate = source2[key2], value = object[key2];
            if (value === undefined$1 && !(key2 in object) || !predicate(value))
              return !1;
          }
          return !0;
        }
        function baseDelay(func, wait2, args) {
          if (typeof func != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          return setTimeout2(function() {
            func.apply(undefined$1, args);
          }, wait2);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = !0, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length)
            return result2;
          iteratee2 && (values2 = arrayMap(values2, baseUnary(iteratee2))), comparator ? (includes2 = arrayIncludesWith, isCommon = !1) : values2.length >= LARGE_ARRAY_SIZE && (includes2 = cacheHas, isCommon = !1, values2 = new SetCache(values2));
          outer:
            for (; ++index < length; ) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              if (value = comparator || value !== 0 ? value : 0, isCommon && computed === computed) {
                for (var valuesIndex = valuesLength; valuesIndex--; )
                  if (values2[valuesIndex] === computed)
                    continue outer;
                result2.push(value);
              } else includes2(values2, computed, comparator) || result2.push(value);
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn), baseEachRight = createBaseEach(baseForOwnRight, !0);
        function baseEvery(collection, predicate) {
          var result2 = !0;
          return baseEach(collection, function(value, index, collection2) {
            return result2 = !!predicate(value, index, collection2), result2;
          }), result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          for (var index = -1, length = array.length; ++index < length; ) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed)))
              var computed = current, result2 = value;
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          for (start = toInteger(start), start < 0 && (start = -start > length ? 0 : length + start), end = end === undefined$1 || end > length ? length : toInteger(end), end < 0 && (end += length), end = start > end ? 0 : toLength(end); start < end; )
            array[start++] = value;
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          return baseEach(collection, function(value, index, collection2) {
            predicate(value, index, collection2) && result2.push(value);
          }), result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          for (predicate || (predicate = isFlattenable), result2 || (result2 = []); ++index < length; ) {
            var value = array[index];
            depth > 0 && predicate(value) ? depth > 1 ? baseFlatten(value, depth - 1, predicate, isStrict, result2) : arrayPush(result2, value) : isStrict || (result2[result2.length] = value);
          }
          return result2;
        }
        var baseFor = createBaseFor(), baseForRight = createBaseFor(!0);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key2) {
            return isFunction2(object[key2]);
          });
        }
        function baseGet(object, path2) {
          path2 = castPath(path2, object);
          for (var index = 0, length = path2.length; object != null && index < length; )
            object = object[toKey(path2[index++])];
          return index && index == length ? object : undefined$1;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          return value == null ? value === undefined$1 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key2) {
          return object != null && hasOwnProperty2.call(object, key2);
        }
        function baseHasIn(object, key2) {
          return object != null && key2 in Object2(object);
        }
        function baseInRange(number2, start, end) {
          return number2 >= nativeMin(start, end) && number2 < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          for (var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = 1 / 0, result2 = []; othIndex--; ) {
            var array = arrays[othIndex];
            othIndex && iteratee2 && (array = arrayMap(array, baseUnary(iteratee2))), maxLength = nativeMin(array.length, maxLength), caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            for (; ++index < length && result2.length < maxLength; ) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              if (value = comparator || value !== 0 ? value : 0, !(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                for (othIndex = othLength; --othIndex; ) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator)))
                    continue outer;
                }
                seen && seen.push(computed), result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          return baseForOwn(object, function(value, key2, object2) {
            setter(accumulator, iteratee2(value), key2, object2);
          }), accumulator;
        }
        function baseInvoke(object, path2, args) {
          path2 = castPath(path2, object), object = parent(object, path2);
          var func = object == null ? object : object[toKey(last2(path2))];
          return func == null ? undefined$1 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack2) {
          return value === other ? !0 : value == null || other == null || !isObjectLike(value) && !isObjectLike(other) ? value !== value && other !== other : baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
          var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag, othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other))
              return !1;
            objIsArr = !0, objIsObj = !1;
          }
          if (isSameTag && !objIsObj)
            return stack2 || (stack2 = new Stack2()), objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              return stack2 || (stack2 = new Stack2()), equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
            }
          }
          return isSameTag ? (stack2 || (stack2 = new Stack2()), equalObjects(object, other, bitmask, customizer, equalFunc, stack2)) : !1;
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source2, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null)
            return !length;
          for (object = Object2(object); index--; ) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object))
              return !1;
          }
          for (; ++index < length; ) {
            data = matchData[index];
            var key2 = data[0], objValue = object[key2], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key2 in object))
                return !1;
            } else {
              var stack2 = new Stack2();
              if (customizer)
                var result2 = customizer(objValue, srcValue, key2, object, source2, stack2);
              if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result2))
                return !1;
            }
          }
          return !0;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value))
            return !1;
          var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          return typeof value == "function" ? value : value == null ? identity2 : typeof value == "object" ? isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value) : property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object))
            return nativeKeys(object);
          var result2 = [];
          for (var key2 in Object2(object))
            hasOwnProperty2.call(object, key2) && key2 != "constructor" && result2.push(key2);
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject2(object))
            return nativeKeysIn(object);
          var isProto = isPrototype(object), result2 = [];
          for (var key2 in object)
            key2 == "constructor" && (isProto || !hasOwnProperty2.call(object, key2)) || result2.push(key2);
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          return baseEach(collection, function(value, key2, collection2) {
            result2[++index] = iteratee2(value, key2, collection2);
          }), result2;
        }
        function baseMatches(source2) {
          var matchData = getMatchData(source2);
          return matchData.length == 1 && matchData[0][2] ? matchesStrictComparable(matchData[0][0], matchData[0][1]) : function(object) {
            return object === source2 || baseIsMatch(object, source2, matchData);
          };
        }
        function baseMatchesProperty(path2, srcValue) {
          return isKey(path2) && isStrictComparable(srcValue) ? matchesStrictComparable(toKey(path2), srcValue) : function(object) {
            var objValue = get(object, path2);
            return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source2, srcIndex, customizer, stack2) {
          object !== source2 && baseFor(source2, function(srcValue, key2) {
            if (stack2 || (stack2 = new Stack2()), isObject2(srcValue))
              baseMergeDeep(object, source2, key2, srcIndex, baseMerge, customizer, stack2);
            else {
              var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source2, stack2) : undefined$1;
              newValue === undefined$1 && (newValue = srcValue), assignMergeValue(object, key2, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source2, key2, srcIndex, mergeFunc, customizer, stack2) {
          var objValue = safeGet(object, key2), srcValue = safeGet(source2, key2), stacked = stack2.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key2, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source2, stack2) : undefined$1, isCommon = newValue === undefined$1;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue, isArr || isBuff || isTyped ? isArray2(objValue) ? newValue = objValue : isArrayLikeObject(objValue) ? newValue = copyArray(objValue) : isBuff ? (isCommon = !1, newValue = cloneBuffer(srcValue, !0)) : isTyped ? (isCommon = !1, newValue = cloneTypedArray(srcValue, !0)) : newValue = [] : isPlainObject2(srcValue) || isArguments(srcValue) ? (newValue = objValue, isArguments(objValue) ? newValue = toPlainObject(objValue) : (!isObject2(objValue) || isFunction2(objValue)) && (newValue = initCloneObject(srcValue))) : isCommon = !1;
          }
          isCommon && (stack2.set(srcValue, newValue), mergeFunc(newValue, srcValue, srcIndex, customizer, stack2), stack2.delete(srcValue)), assignMergeValue(object, key2, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (length)
            return n += n < 0 ? length : 0, isIndex(n, length) ? array[n] : undefined$1;
        }
        function baseOrderBy(collection, iteratees, orders) {
          iteratees.length ? iteratees = arrayMap(iteratees, function(iteratee2) {
            return isArray2(iteratee2) ? function(value) {
              return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
            } : iteratee2;
          }) : iteratees = [identity2];
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key2, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { criteria, index: ++index, value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path2) {
            return hasIn(object, path2);
          });
        }
        function basePickBy(object, paths, predicate) {
          for (var index = -1, length = paths.length, result2 = {}; ++index < length; ) {
            var path2 = paths[index], value = baseGet(object, path2);
            predicate(value, path2) && baseSet(result2, castPath(path2, object), value);
          }
          return result2;
        }
        function basePropertyDeep(path2) {
          return function(object) {
            return baseGet(object, path2);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          for (array === values2 && (values2 = copyArray(values2)), iteratee2 && (seen = arrayMap(array, baseUnary(iteratee2))); ++index < length; )
            for (var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value; (fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1; )
              seen !== array && splice.call(seen, fromIndex, 1), splice.call(array, fromIndex, 1);
          return array;
        }
        function basePullAt(array, indexes) {
          for (var length = array ? indexes.length : 0, lastIndex = length - 1; length--; ) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              isIndex(index) ? splice.call(array, index, 1) : baseUnset(array, index);
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          for (var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length); length--; )
            result2[fromRight ? length : ++index] = start, start += step;
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER)
            return result2;
          do
            n % 2 && (result2 += string), n = nativeFloor(n / 2), n && (string += string);
          while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity2), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path2, value, customizer) {
          if (!isObject2(object))
            return object;
          path2 = castPath(path2, object);
          for (var index = -1, length = path2.length, lastIndex = length - 1, nested = object; nested != null && ++index < length; ) {
            var key2 = toKey(path2[index]), newValue = value;
            if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype")
              return object;
            if (index != lastIndex) {
              var objValue = nested[key2];
              newValue = customizer ? customizer(objValue, key2, nested) : undefined$1, newValue === undefined$1 && (newValue = isObject2(objValue) ? objValue : isIndex(path2[index + 1]) ? [] : {});
            }
            assignValue(nested, key2, newValue), nested = nested[key2];
          }
          return object;
        }
        var baseSetData = metaMap ? function(func, data) {
          return metaMap.set(func, data), func;
        } : identity2, baseSetToString = defineProperty2 ? function(func, string) {
          return defineProperty2(func, "toString", {
            configurable: !0,
            enumerable: !1,
            value: constant(string),
            writable: !0
          });
        } : identity2;
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          start < 0 && (start = -start > length ? 0 : length + start), end = end > length ? length : end, end < 0 && (end += length), length = start > end ? 0 : end - start >>> 0, start >>>= 0;
          for (var result2 = Array2(length); ++index < length; )
            result2[index] = array[index + start];
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          return baseEach(collection, function(value, index, collection2) {
            return result2 = predicate(value, index, collection2), !result2;
          }), !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            for (; low < high; ) {
              var mid = low + high >>> 1, computed = array[mid];
              computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value) ? low = mid + 1 : high = mid;
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity2, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0)
            return 0;
          value = iteratee2(value);
          for (var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1; low < high; ) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN)
              var setLow = retHighest || othIsReflexive;
            else valIsUndefined ? setLow = othIsReflexive && (retHighest || othIsDefined) : valIsNull ? setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull) : valIsSymbol ? setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol) : othIsNull || othIsSymbol ? setLow = !1 : setLow = retHighest ? computed <= value : computed < value;
            setLow ? low = mid + 1 : high = mid;
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          for (var index = -1, length = array.length, resIndex = 0, result2 = []; ++index < length; ) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          return typeof value == "number" ? value : isSymbol(value) ? NAN : +value;
        }
        function baseToString(value) {
          if (typeof value == "string")
            return value;
          if (isArray2(value))
            return arrayMap(value, baseToString) + "";
          if (isSymbol(value))
            return symbolToString ? symbolToString.call(value) : "";
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = !0, result2 = [], seen = result2;
          if (comparator)
            isCommon = !1, includes2 = arrayIncludesWith;
          else if (length >= LARGE_ARRAY_SIZE) {
            var set3 = iteratee2 ? null : createSet(array);
            if (set3)
              return setToArray(set3);
            isCommon = !1, includes2 = cacheHas, seen = new SetCache();
          } else
            seen = iteratee2 ? [] : result2;
          outer:
            for (; ++index < length; ) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              if (value = comparator || value !== 0 ? value : 0, isCommon && computed === computed) {
                for (var seenIndex = seen.length; seenIndex--; )
                  if (seen[seenIndex] === computed)
                    continue outer;
                iteratee2 && seen.push(computed), result2.push(value);
              } else includes2(seen, computed, comparator) || (seen !== result2 && seen.push(computed), result2.push(value));
            }
          return result2;
        }
        function baseUnset(object, path2) {
          return path2 = castPath(path2, object), object = parent(object, path2), object == null || delete object[toKey(last2(path2))];
        }
        function baseUpdate(object, path2, updater, customizer) {
          return baseSet(object, path2, updater(baseGet(object, path2)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          for (var length = array.length, index = fromRight ? length : -1; (fromRight ? index-- : ++index < length) && predicate(array[index], index, array); )
            ;
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          return result2 instanceof LazyWrapper && (result2 = result2.value()), arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2)
            return length ? baseUniq(arrays[0]) : [];
          for (var index = -1, result2 = Array2(length); ++index < length; )
            for (var array = arrays[index], othIndex = -1; ++othIndex < length; )
              othIndex != index && (result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator));
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          for (var index = -1, length = props.length, valsLength = values2.length, result2 = {}; ++index < length; ) {
            var value = index < valsLength ? values2[index] : undefined$1;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity2;
        }
        function castPath(value, object) {
          return isArray2(value) ? value : isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          return end = end === undefined$1 ? length : end, !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root2.clearTimeout(id);
        };
        function cloneBuffer(buffer2, isDeep) {
          if (isDeep)
            return buffer2.slice();
          var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
          return buffer2.copy(result2), result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          return new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer)), result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp2) {
          var result2 = new regexp2.constructor(regexp2.source, reFlags.exec(regexp2));
          return result2.lastIndex = regexp2.lastIndex, result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value), othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive)
              return 1;
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive)
              return -1;
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          for (var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length; ++index < length; ) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength)
                return result2;
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          for (var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried; ++leftIndex < leftLength; )
            result2[leftIndex] = partials[leftIndex];
          for (; ++argsIndex < holdersLength; )
            (isUncurried || argsIndex < argsLength) && (result2[holders[argsIndex]] = args[argsIndex]);
          for (; rangeLength--; )
            result2[leftIndex++] = args[argsIndex++];
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          for (var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried; ++argsIndex < rangeLength; )
            result2[argsIndex] = args[argsIndex];
          for (var offset = argsIndex; ++rightIndex < rightLength; )
            result2[offset + rightIndex] = partials[rightIndex];
          for (; ++holdersIndex < holdersLength; )
            (isUncurried || argsIndex < argsLength) && (result2[offset + holders[holdersIndex]] = args[argsIndex++]);
          return result2;
        }
        function copyArray(source2, array) {
          var index = -1, length = source2.length;
          for (array || (array = Array2(length)); ++index < length; )
            array[index] = source2[index];
          return array;
        }
        function copyObject(source2, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          for (var index = -1, length = props.length; ++index < length; ) {
            var key2 = props[index], newValue = customizer ? customizer(object[key2], source2[key2], key2, object, source2) : undefined$1;
            newValue === undefined$1 && (newValue = source2[key2]), isNew ? baseAssignValue(object, key2, newValue) : assignValue(object, key2, newValue);
          }
          return object;
        }
        function copySymbols(source2, object) {
          return copyObject(source2, getSymbols(source2), object);
        }
        function copySymbolsIn(source2, object) {
          return copyObject(source2, getSymbolsIn(source2), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
            for (customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1, guard && isIterateeCall(sources[0], sources[1], guard) && (customizer = length < 3 ? undefined$1 : customizer, length = 1), object = Object2(object); ++index < length; ) {
              var source2 = sources[index];
              source2 && assigner(object, source2, index, customizer);
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null)
              return collection;
            if (!isArrayLike2(collection))
              return eachFunc(collection, iteratee2);
            for (var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection); (fromRight ? index-- : ++index < length) && iteratee2(iterable[index], index, iterable) !== !1; )
              ;
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            for (var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length; length--; ) {
              var key2 = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key2], key2, iterable) === !1)
                break;
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1, chr = strSymbols ? strSymbols[0] : string.charAt(0), trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            for (var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper); index--; )
              args[index] = arguments[index];
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            if (length -= holders.length, length < arity)
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined$1,
                args,
                holders,
                undefined$1,
                undefined$1,
                arity - length
              );
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike2(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection), predicate = function(key2) {
                return iteratee2(iterable[key2], key2, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            for (fromRight && funcs.reverse(); index--; ) {
              var func = funcs[index];
              if (typeof func != "function")
                throw new TypeError2(FUNC_ERROR_TEXT);
              if (prereq && !wrapper && getFuncName(func) == "wrapper")
                var wrapper = new LodashWrapper([], !0);
            }
            for (index = wrapper ? index : length; ++index < length; ) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
              data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1 ? wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]) : wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray2(value))
                return wrapper.plant(value).value();
              for (var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value; ++index2 < length; )
                result2 = funcs[index2].call(this, result2);
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
          function wrapper() {
            for (var length = arguments.length, args = Array2(length), index = length; index--; )
              args[index] = arguments[index];
            if (isCurried)
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            if (partials && (args = composeArgs(args, partials, holders, isCurried)), partialsRight && (args = composeArgsRight(args, partialsRight, holdersRight, isCurried)), length -= holdersCount, isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            return length = args.length, argPos ? args = reorder(args, argPos) : isFlip && length > 1 && args.reverse(), isAry && ary2 < length && (args.length = ary2), this && this !== root2 && this instanceof wrapper && (fn = Ctor || createCtor(fn)), fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined$1 && other === undefined$1)
              return defaultValue;
            if (value !== undefined$1 && (result2 = value), other !== undefined$1) {
              if (result2 === undefined$1)
                return other;
              typeof value == "string" || typeof other == "string" ? (value = baseToString(value), other = baseToString(other)) : (value = baseToNumber(value), other = baseToNumber(other)), result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            return iteratees = arrayMap(iteratees, baseUnary(getIteratee())), baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined$1 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2)
            return charsLength ? baseRepeat(chars, length) : chars;
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            for (var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func; ++leftIndex < leftLength; )
              args[leftIndex] = partials[leftIndex];
            for (; argsLength--; )
              args[leftIndex++] = arguments[++argsIndex];
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            return step && typeof step != "number" && isIterateeCall(start, end, step) && (end = step = undefined$1), start = toFinite(start), end === undefined$1 ? (end = start, start = 0) : end = toFinite(end), step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step), baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            return typeof value == "string" && typeof other == "string" || (value = toNumber(value), other = toNumber(other)), operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG, bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG), bitmask & WRAP_CURRY_BOUND_FLAG || (bitmask &= -4);
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ], result2 = wrapFunc.apply(undefined$1, newData);
          return isLaziable(func) && setData(result2, newData), result2.placeholder = placeholder, setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number2, precision) {
            if (number2 = toNumber(number2), precision = precision == null ? 0 : nativeMin(toInteger(precision), 292), precision && nativeIsFinite(number2)) {
              var pair = (toString(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              return pair = (toString(value) + "e").split("e"), +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number2);
          };
        }
        var createSet = Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY ? function(values2) {
          return new Set2(values2);
        } : noop2;
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            return tag == mapTag ? mapToArray(object) : tag == setTag ? setToPairs(object) : baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          var length = partials ? partials.length : 0;
          if (length || (bitmask &= -97, partials = holders = undefined$1), ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0), arity = arity === undefined$1 ? arity : toInteger(arity), length -= holders ? holders.length : 0, bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined$1;
          }
          var data = isBindKey ? undefined$1 : getData(func), newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data && mergeData(newData, data), func = newData[0], bitmask = newData[1], thisArg = newData[2], partials = newData[3], holders = newData[4], arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0), !arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG) && (bitmask &= -25), !bitmask || bitmask == WRAP_BIND_FLAG)
            var result2 = createBind(func, bitmask, thisArg);
          else bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG ? result2 = createCurry(func, bitmask, arity) : (bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length ? result2 = createPartial(func, bitmask, thisArg, partials) : result2 = createHybrid.apply(undefined$1, newData);
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key2, object) {
          return objValue === undefined$1 || eq(objValue, objectProto[key2]) && !hasOwnProperty2.call(object, key2) ? srcValue : objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key2, object, source2, stack2) {
          return isObject2(objValue) && isObject2(srcValue) && (stack2.set(srcValue, objValue), baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack2), stack2.delete(srcValue)), objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined$1 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength))
            return !1;
          var arrStacked = stack2.get(array), othStacked = stack2.get(other);
          if (arrStacked && othStacked)
            return arrStacked == other && othStacked == array;
          var index = -1, result2 = !0, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
          for (stack2.set(array, other), stack2.set(other, array); ++index < arrLength; ) {
            var arrValue = array[index], othValue = other[index];
            if (customizer)
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack2) : customizer(arrValue, othValue, index, array, other, stack2);
            if (compared !== undefined$1) {
              if (compared)
                continue;
              result2 = !1;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2)))
                  return seen.push(othIndex);
              })) {
                result2 = !1;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
              result2 = !1;
              break;
            }
          }
          return stack2.delete(array), stack2.delete(other), result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset)
                return !1;
              object = object.buffer, other = other.buffer;
            case arrayBufferTag:
              return !(object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other)));
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              if (convert || (convert = setToArray), object.size != other.size && !isPartial)
                return !1;
              var stacked = stack2.get(object);
              if (stacked)
                return stacked == other;
              bitmask |= COMPARE_UNORDERED_FLAG, stack2.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
              return stack2.delete(object), result2;
            case symbolTag:
              if (symbolValueOf)
                return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
          return !1;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial)
            return !1;
          for (var index = objLength; index--; ) {
            var key2 = objProps[index];
            if (!(isPartial ? key2 in other : hasOwnProperty2.call(other, key2)))
              return !1;
          }
          var objStacked = stack2.get(object), othStacked = stack2.get(other);
          if (objStacked && othStacked)
            return objStacked == other && othStacked == object;
          var result2 = !0;
          stack2.set(object, other), stack2.set(other, object);
          for (var skipCtor = isPartial; ++index < objLength; ) {
            key2 = objProps[index];
            var objValue = object[key2], othValue = other[key2];
            if (customizer)
              var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack2) : customizer(objValue, othValue, key2, object, other, stack2);
            if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
              result2 = !1;
              break;
            }
            skipCtor || (skipCtor = key2 == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor) && (result2 = !1);
          }
          return stack2.delete(object), stack2.delete(other), result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined$1, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = metaMap ? function(func) {
          return metaMap.get(func);
        } : noop2;
        function getFuncName(func) {
          for (var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0; length--; ) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func)
              return data.name;
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash2.iteratee || iteratee;
          return result2 = result2 === iteratee ? baseIteratee : result2, arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map3, key2) {
          var data = map3.__data__;
          return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          for (var result2 = keys(object), length = result2.length; length--; ) {
            var key2 = result2[length], value = object[key2];
            result2[length] = [key2, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key2) {
          var value = getValue(object, key2);
          return baseIsNative(value) ? value : undefined$1;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined$1;
            var unmasked = !0;
          } catch {
          }
          var result2 = nativeObjectToString.call(value);
          return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result2;
        }
        var getSymbols = nativeGetSymbols ? function(object) {
          return object == null ? [] : (object = Object2(object), arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          }));
        } : stubArray, getSymbolsIn = nativeGetSymbols ? function(object) {
          for (var result2 = []; object; )
            arrayPush(result2, getSymbols(object)), object = getPrototype(object);
          return result2;
        } : stubArray, getTag = baseGetTag;
        (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) && (getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString)
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          return result2;
        });
        function getView(start, end, transforms) {
          for (var index = -1, length = transforms.length; ++index < length; ) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { start, end };
        }
        function getWrapDetails(source2) {
          var match2 = source2.match(reWrapDetails);
          return match2 ? match2[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path2, hasFunc) {
          path2 = castPath(path2, object);
          for (var index = -1, length = path2.length, result2 = !1; ++index < length; ) {
            var key2 = toKey(path2[index]);
            if (!(result2 = object != null && hasFunc(object, key2)))
              break;
            object = object[key2];
          }
          return result2 || ++index != length ? result2 : (length = object == null ? 0 : object.length, !!length && isLength(length) && isIndex(key2, length) && (isArray2(object) || isArguments(object)));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          return length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index") && (result2.index = array.index, result2.input = array.input), result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source2, details) {
          var length = details.length;
          if (!length)
            return source2;
          var lastIndex = length - 1;
          return details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex], details = details.join(length > 2 ? ", " : " "), source2.replace(reWrapComment, `{
/* [wrapped with ` + details + `] */
`);
        }
        function isFlattenable(value) {
          return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type2 = typeof value;
          return length = length ?? MAX_SAFE_INTEGER, !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
          if (!isObject2(object))
            return !1;
          var type2 = typeof index;
          return (type2 == "number" ? isArrayLike2(object) && isIndex(index, object.length) : type2 == "string" && index in object) ? eq(object[index], value) : !1;
        }
        function isKey(value, object) {
          if (isArray2(value))
            return !1;
          var type2 = typeof value;
          return type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value) ? !0 : reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type2 = typeof value;
          return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash2[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype))
            return !1;
          if (func === other)
            return !0;
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction2 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key2, srcValue) {
          return function(object) {
            return object == null ? !1 : object[key2] === srcValue && (srcValue !== undefined$1 || key2 in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key2) {
            return cache.size === MAX_MEMOIZE_SIZE && cache.clear(), key2;
          }), cache = result2.cache;
          return result2;
        }
        function mergeData(data, source2) {
          var bitmask = data[1], srcBitmask = source2[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG), isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source2[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source2[7].length <= source2[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo))
            return data;
          srcBitmask & WRAP_BIND_FLAG && (data[2] = source2[2], newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG);
          var value = source2[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source2[4]) : value, data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source2[4];
          }
          return value = source2[5], value && (partials = data[5], data[5] = partials ? composeArgsRight(partials, value, source2[6]) : value, data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source2[6]), value = source2[7], value && (data[7] = value), srcBitmask & WRAP_ARY_FLAG && (data[8] = data[8] == null ? source2[8] : nativeMin(data[8], source2[8])), data[9] == null && (data[9] = source2[9]), data[0] = source2[0], data[1] = newBitmask, data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null)
            for (var key2 in Object2(object))
              result2.push(key2);
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          return start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0), function() {
            for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length); ++index < length; )
              array[index] = args[start + index];
            index = -1;
            for (var otherArgs = Array2(start + 1); ++index < start; )
              otherArgs[index] = args[index];
            return otherArgs[start] = transform2(array), apply(func, this, otherArgs);
          };
        }
        function parent(object, path2) {
          return path2.length < 2 ? object : baseGet(object, baseSlice(path2, 0, -1));
        }
        function reorder(array, indexes) {
          for (var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array); length--; ) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
          }
          return array;
        }
        function safeGet(object, key2) {
          if (!(key2 === "constructor" && typeof object[key2] == "function") && key2 != "__proto__")
            return object[key2];
        }
        var setData = shortOut(baseSetData), setTimeout2 = ctxSetTimeout || function(func, wait2) {
          return root2.setTimeout(func, wait2);
        }, setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source2 = reference + "";
          return setToString(wrapper, insertWrapDetails(source2, updateWrapDetails(getWrapDetails(source2), bitmask)));
        }
        function shortOut(func) {
          var count2 = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            if (lastCalled = stamp, remaining > 0) {
              if (++count2 >= HOT_COUNT)
                return arguments[0];
            } else
              count2 = 0;
            return func.apply(undefined$1, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          for (size2 = size2 === undefined$1 ? length : size2; ++index < size2; ) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index], array[index] = value;
          }
          return array.length = size2, array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          return string.charCodeAt(0) === 46 && result2.push(""), string.replace(rePropName, function(match2, number2, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
          }), result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value))
            return value;
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch {
            }
            try {
              return func + "";
            } catch {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          return arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            bitmask & pair[1] && !arrayIncludes(details, value) && details.push(value);
          }), details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper)
            return wrapper.clone();
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          return result2.__actions__ = copyArray(wrapper.__actions__), result2.__index__ = wrapper.__index__, result2.__values__ = wrapper.__values__, result2;
        }
        function chunk(array, size2, guard) {
          (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) ? size2 = 1 : size2 = nativeMax(toInteger(size2), 0);
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1)
            return [];
          for (var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2)); index < length; )
            result2[resIndex++] = baseSlice(array, index, index += size2);
          return result2;
        }
        function compact(array) {
          for (var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = []; ++index < length; ) {
            var value = array[index];
            value && (result2[resIndex++] = value);
          }
          return result2;
        }
        function concat2() {
          var length = arguments.length;
          if (!length)
            return [];
          for (var args = Array2(length - 1), array = arguments[0], index = length; index--; )
            args[index - 1] = arguments[index];
          return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, !0)) : [];
        }), differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last2(values2);
          return isArrayLikeObject(iteratee2) && (iteratee2 = undefined$1), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, !0), getIteratee(iteratee2, 2)) : [];
        }), differenceWith = baseRest(function(array, values2) {
          var comparator = last2(values2);
          return isArrayLikeObject(comparator) && (comparator = undefined$1), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, !0), undefined$1, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          return length ? (n = guard || n === undefined$1 ? 1 : toInteger(n), baseSlice(array, n < 0 ? 0 : n, length)) : [];
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          return length ? (n = guard || n === undefined$1 ? 1 : toInteger(n), n = length - n, baseSlice(array, 0, n < 0 ? 0 : n)) : [];
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0, !0) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          return length ? (start && typeof start != "number" && isIterateeCall(array, value, start) && (start = 0, end = length), baseFill(array, value, start, end)) : [];
        }
        function findIndex2(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length)
            return -1;
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          return index < 0 && (index = nativeMax(length + index, 0)), baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length)
            return -1;
          var index = length - 1;
          return fromIndex !== undefined$1 && (index = toInteger(fromIndex), index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), baseFindIndex(array, getIteratee(predicate, 3), index, !0);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          return length ? (depth = depth === undefined$1 ? 1 : toInteger(depth), baseFlatten(array, depth)) : [];
        }
        function fromPairs(pairs2) {
          for (var index = -1, length = pairs2 == null ? 0 : pairs2.length, result2 = {}; ++index < length; ) {
            var pair = pairs2[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined$1;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length)
            return -1;
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          return index < 0 && (index = nativeMax(length + index, 0)), baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        }), intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          return iteratee2 === last2(mapped) ? iteratee2 = undefined$1 : mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        }), intersectionWith = baseRest(function(arrays) {
          var comparator = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          return comparator = typeof comparator == "function" ? comparator : undefined$1, comparator && mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
        });
        function join(array, separator2) {
          return array == null ? "" : nativeJoin.call(array, separator2);
        }
        function last2(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined$1;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length)
            return -1;
          var index = length;
          return fromIndex !== undefined$1 && (index = toInteger(fromIndex), index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, !0);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          return basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending)), result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length))
            return result2;
          var index = -1, indexes = [], length = array.length;
          for (predicate = getIteratee(predicate, 3); ++index < length; ) {
            var value = array[index];
            predicate(value, index, array) && (result2.push(value), indexes.push(index));
          }
          return basePullAt(array, indexes), result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          return length ? (end && typeof end != "number" && isIterateeCall(array, start, end) ? (start = 0, end = length) : (start = start == null ? 0 : toInteger(start), end = end === undefined$1 ? length : toInteger(end)), baseSlice(array, start, end)) : [];
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value))
              return index;
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, !0);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), !0);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, !0) - 1;
            if (eq(array[index], value))
              return index;
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take2(array, n, guard) {
          return array && array.length ? (n = guard || n === undefined$1 ? 1 : toInteger(n), baseSlice(array, 0, n < 0 ? 0 : n)) : [];
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          return length ? (n = guard || n === undefined$1 ? 1 : toInteger(n), n = length - n, baseSlice(array, n < 0 ? 0 : n, length)) : [];
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !1, !0) : [];
        }
        function takeWhile2(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0));
        }), unionBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays);
          return isArrayLikeObject(iteratee2) && (iteratee2 = undefined$1), baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), getIteratee(iteratee2, 2));
        }), unionWith = baseRest(function(arrays) {
          var comparator = last2(arrays);
          return comparator = typeof comparator == "function" ? comparator : undefined$1, baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), undefined$1, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          return comparator = typeof comparator == "function" ? comparator : undefined$1, array && array.length ? baseUniq(array, undefined$1, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length))
            return [];
          var length = 0;
          return array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group))
              return length = nativeMax(group.length, length), !0;
          }), baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length))
            return [];
          var result2 = unzip(array);
          return iteratee2 == null ? result2 : arrayMap(result2, function(group) {
            return apply(iteratee2, undefined$1, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        }), xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        }), xorBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays);
          return isArrayLikeObject(iteratee2) && (iteratee2 = undefined$1), baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        }), xorWith = baseRest(function(arrays) {
          var comparator = last2(arrays);
          return comparator = typeof comparator == "function" ? comparator : undefined$1, baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
        }), zip2 = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
          return iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1, unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash2(value);
          return result2.__chain__ = !0, result2;
        }
        function tap2(value, interceptor) {
          return interceptor(value), value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          return length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start) ? this.thru(interceptor) : (value = value.slice(start, +start + (length ? 1 : 0)), value.__actions__.push({
            func: thru,
            args: [interceptor],
            thisArg: undefined$1
          }), new LodashWrapper(value, this.__chain__).thru(function(array) {
            return length && !array.length && array.push(undefined$1), array;
          }));
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          this.__values__ === undefined$1 && (this.__values__ = toArray2(this.value()));
          var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
          return { done, value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          for (var result2, parent2 = this; parent2 instanceof baseLodash; ) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0, clone2.__values__ = undefined$1, result2 ? previous.__wrapped__ = clone2 : result2 = clone2;
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          return previous.__wrapped__ = value, result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            return this.__actions__.length && (wrapped = new LazyWrapper(this)), wrapped = wrapped.reverse(), wrapped.__actions__.push({
              func: thru,
              args: [reverse],
              thisArg: undefined$1
            }), new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key2) {
          hasOwnProperty2.call(result2, key2) ? ++result2[key2] : baseAssignValue(result2, key2, 1);
        });
        function every2(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery;
          return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined$1), func(collection, getIteratee(predicate, 3));
        }
        function filter2(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find2 = createFind(findIndex2), findLast = createFind(findLastIndex);
        function flatMap2(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          return depth = depth === undefined$1 ? 1 : toInteger(depth), baseFlatten(map2(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy2 = createAggregator(function(result2, value, key2) {
          hasOwnProperty2.call(result2, key2) ? result2[key2].push(value) : baseAssignValue(result2, key2, [value]);
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike2(collection) ? collection : values(collection), fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          return fromIndex < 0 && (fromIndex = nativeMax(length + fromIndex, 0)), isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path2, args) {
          var index = -1, isFunc = typeof path2 == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          return baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
          }), result2;
        }), keyBy = createAggregator(function(result2, value, key2) {
          baseAssignValue(result2, key2, value);
        });
        function map2(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          return collection == null ? [] : (isArray2(iteratees) || (iteratees = iteratees == null ? [] : [iteratees]), orders = guard ? undefined$1 : orders, isArray2(orders) || (orders = orders == null ? [] : [orders]), baseOrderBy(collection, iteratees, orders));
        }
        var partition2 = createAggregator(function(result2, value, key2) {
          result2[key2 ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce2(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample2(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) ? n = 1 : n = toInteger(n);
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null)
            return 0;
          if (isArrayLike2(collection))
            return isString(collection) ? stringSize(collection) : collection.length;
          var tag = getTag(collection);
          return tag == mapTag || tag == setTag ? collection.size : baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome : baseSome;
          return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined$1), func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null)
            return [];
          var length = iteratees.length;
          return length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1]) ? iteratees = [] : length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2]) && (iteratees = [iteratees[0]]), baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        }), now = ctxNow || function() {
          return root2.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          return n = toInteger(n), function() {
            if (--n < 1)
              return func.apply(this, arguments);
          };
        }
        function ary(func, n, guard) {
          return n = guard ? undefined$1 : n, n = func && n == null ? func.length : n, createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          return n = toInteger(n), function() {
            return --n > 0 && (result2 = func.apply(this, arguments)), n <= 1 && (func = undefined$1), result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        }), bindKey = baseRest(function(object, key2, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key2, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          return result2.placeholder = curry.placeholder, result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          return result2.placeholder = curryRight.placeholder, result2;
        }
        function debounce2(func, wait2, options2) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
          if (typeof func != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          wait2 = toNumber(wait2) || 0, isObject2(options2) && (leading = !!options2.leading, maxing = "maxWait" in options2, maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait2) : maxWait, trailing = "trailing" in options2 ? !!options2.trailing : trailing);
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            return lastArgs = lastThis = undefined$1, lastInvokeTime = time, result2 = func.apply(thisArg, args), result2;
          }
          function leadingEdge(time) {
            return lastInvokeTime = time, timerId = setTimeout2(timerExpired, wait2), leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait2 - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined$1 || timeSinceLastCall >= wait2 || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time))
              return trailingEdge(time);
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            return timerId = undefined$1, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = undefined$1, result2);
          }
          function cancel() {
            timerId !== undefined$1 && clearTimeout2(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }
          function flush() {
            return timerId === undefined$1 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
              if (timerId === undefined$1)
                return leadingEdge(lastCallTime);
              if (maxing)
                return clearTimeout2(timerId), timerId = setTimeout2(timerExpired, wait2), invokeFunc(lastCallTime);
            }
            return timerId === undefined$1 && (timerId = setTimeout2(timerExpired, wait2)), result2;
          }
          return debounced.cancel = cancel, debounced.flush = flush, debounced;
        }
        var defer2 = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        }), delay2 = baseRest(function(func, wait2, args) {
          return baseDelay(func, toNumber(wait2) || 0, args);
        });
        function flip2(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          var memoized = function() {
            var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key2))
              return cache.get(key2);
            var result2 = func.apply(this, args);
            return memoized.cache = cache.set(key2, result2) || cache, result2;
          };
          return memoized.cache = new (memoize.Cache || MapCache)(), memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once2(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            for (var index = -1, length = nativeMin(args.length, funcsLength); ++index < length; )
              args[index] = transforms[index].call(this, args[index]);
            return apply(func, this, args);
          });
        }), partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
        }), partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
        }), rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          return start = start === undefined$1 ? start : toInteger(start), baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          return start = start == null ? 0 : nativeMax(toInteger(start), 0), baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            return array && arrayPush(otherArgs, array), apply(func, this, otherArgs);
          });
        }
        function throttle2(func, wait2, options2) {
          var leading = !0, trailing = !0;
          if (typeof func != "function")
            throw new TypeError2(FUNC_ERROR_TEXT);
          return isObject2(options2) && (leading = "leading" in options2 ? !!options2.leading : leading, trailing = "trailing" in options2 ? !!options2.trailing : trailing), debounce2(func, wait2, {
            leading,
            maxWait: wait2,
            trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap2(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length)
            return [];
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          return customizer = typeof customizer == "function" ? customizer : undefined$1, baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          return customizer = typeof customizer == "function" ? customizer : undefined$1, baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source2) {
          return source2 == null || baseConformsTo(object, source2, keys(source2));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt), gte = createRelationalOperation(function(value, other) {
          return value >= other;
        }), isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        }, isArray2 = Array2.isArray, isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike2(value) {
          return value != null && isLength(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike2(value);
        }
        function isBoolean(value) {
          return value === !0 || value === !1 || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse, isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty2(value) {
          if (value == null)
            return !0;
          if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value)))
            return !value.length;
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag)
            return !value.size;
          if (isPrototype(value))
            return !baseKeys(value).length;
          for (var key2 in value)
            if (hasOwnProperty2.call(value, key2))
              return !1;
          return !0;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          var result2 = customizer ? customizer(value, other) : undefined$1;
          return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value))
            return !1;
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject2(value))
            return !1;
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger2(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type2 = typeof value;
          return value != null && (type2 == "object" || type2 == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source2) {
          return object === source2 || baseIsMatch(object, source2, getMatchData(source2));
        }
        function isMatchWith(object, source2, customizer) {
          return customizer = typeof customizer == "function" ? customizer : undefined$1, baseIsMatch(object, source2, getMatchData(source2), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value))
            throw new Error2(CORE_ERROR_TEXT);
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject2(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag)
            return !1;
          var proto = getPrototype(value);
          if (proto === null)
            return !0;
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger2(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined$1;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt), lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray2(value) {
          if (!value)
            return [];
          if (isArrayLike2(value))
            return isString(value) ? stringToArray(value) : copyArray(value);
          if (symIterator && value[symIterator])
            return iteratorToArray(value[symIterator]());
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value)
            return value === 0 ? value : 0;
          if (value = toNumber(value), value === INFINITY || value === -INFINITY) {
            var sign2 = value < 0 ? -1 : 1;
            return sign2 * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number")
            return value;
          if (isSymbol(value))
            return NAN;
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string")
            return value === 0 ? value : +value;
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source2) {
          if (isPrototype(source2) || isArrayLike2(source2)) {
            copyObject(source2, keys(source2), object);
            return;
          }
          for (var key2 in source2)
            hasOwnProperty2.call(source2, key2) && assignValue(object, key2, source2[key2]);
        }), assignIn = createAssigner(function(object, source2) {
          copyObject(source2, keysIn(source2), object);
        }), assignInWith = createAssigner(function(object, source2, srcIndex, customizer) {
          copyObject(source2, keysIn(source2), object, customizer);
        }), assignWith = createAssigner(function(object, source2, srcIndex, customizer) {
          copyObject(source2, keys(source2), object, customizer);
        }), at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults2 = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1, length = sources.length, guard = length > 2 ? sources[2] : undefined$1;
          for (guard && isIterateeCall(sources[0], sources[1], guard) && (length = 1); ++index < length; )
            for (var source2 = sources[index], props = keysIn(source2), propsIndex = -1, propsLength = props.length; ++propsIndex < propsLength; ) {
              var key2 = props[propsIndex], value = object[key2];
              (value === undefined$1 || eq(value, objectProto[key2]) && !hasOwnProperty2.call(object, key2)) && (object[key2] = source2[key2]);
            }
          return object;
        }), defaultsDeep = baseRest(function(args) {
          return args.push(undefined$1, customDefaultsMerge), apply(mergeWith, undefined$1, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path2, defaultValue) {
          var result2 = object == null ? undefined$1 : baseGet(object, path2);
          return result2 === undefined$1 ? defaultValue : result2;
        }
        function has(object, path2) {
          return object != null && hasPath(object, path2, baseHas);
        }
        function hasIn(object, path2) {
          return object != null && hasPath(object, path2, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key2) {
          value != null && typeof value.toString != "function" && (value = nativeObjectToString.call(value)), result2[value] = key2;
        }, constant(identity2)), invertBy = createInverter(function(result2, value, key2) {
          value != null && typeof value.toString != "function" && (value = nativeObjectToString.call(value)), hasOwnProperty2.call(result2, value) ? result2[value].push(key2) : result2[value] = [key2];
        }, getIteratee), invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike2(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          return iteratee2 = getIteratee(iteratee2, 3), baseForOwn(object, function(value, key2, object2) {
            baseAssignValue(result2, iteratee2(value, key2, object2), value);
          }), result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          return iteratee2 = getIteratee(iteratee2, 3), baseForOwn(object, function(value, key2, object2) {
            baseAssignValue(result2, key2, iteratee2(value, key2, object2));
          }), result2;
        }
        var merge2 = createAssigner(function(object, source2, srcIndex) {
          baseMerge(object, source2, srcIndex);
        }), mergeWith = createAssigner(function(object, source2, srcIndex, customizer) {
          baseMerge(object, source2, srcIndex, customizer);
        }), omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null)
            return result2;
          var isDeep = !1;
          paths = arrayMap(paths, function(path2) {
            return path2 = castPath(path2, object), isDeep || (isDeep = path2.length > 1), path2;
          }), copyObject(object, getAllKeysIn(object), result2), isDeep && (result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
          for (var length = paths.length; length--; )
            baseUnset(result2, paths[length]);
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null)
            return {};
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          return predicate = getIteratee(predicate), basePickBy(object, props, function(value, path2) {
            return predicate(value, path2[0]);
          });
        }
        function result(object, path2, defaultValue) {
          path2 = castPath(path2, object);
          var index = -1, length = path2.length;
          for (length || (length = 1, object = undefined$1); ++index < length; ) {
            var value = object == null ? undefined$1 : object[toKey(path2[index])];
            value === undefined$1 && (index = length, value = defaultValue), object = isFunction2(value) ? value.call(object) : value;
          }
          return object;
        }
        function set2(object, path2, value) {
          return object == null ? object : baseSet(object, path2, value);
        }
        function setWith(object, path2, value, customizer) {
          return customizer = typeof customizer == "function" ? customizer : undefined$1, object == null ? object : baseSet(object, path2, value, customizer);
        }
        var toPairs = createToPairs(keys), toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          if (iteratee2 = getIteratee(iteratee2, 4), accumulator == null) {
            var Ctor = object && object.constructor;
            isArrLike ? accumulator = isArr ? new Ctor() : [] : isObject2(object) ? accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {} : accumulator = {};
          }
          return (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          }), accumulator;
        }
        function unset(object, path2) {
          return object == null ? !0 : baseUnset(object, path2);
        }
        function update2(object, path2, updater) {
          return object == null ? object : baseUpdate(object, path2, castFunction(updater));
        }
        function updateWith(object, path2, updater, customizer) {
          return customizer = typeof customizer == "function" ? customizer : undefined$1, object == null ? object : baseUpdate(object, path2, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number2, lower, upper) {
          return upper === undefined$1 && (upper = lower, lower = undefined$1), upper !== undefined$1 && (upper = toNumber(upper), upper = upper === upper ? upper : 0), lower !== undefined$1 && (lower = toNumber(lower), lower = lower === lower ? lower : 0), baseClamp(toNumber(number2), lower, upper);
        }
        function inRange(number2, start, end) {
          return start = toFinite(start), end === undefined$1 ? (end = start, start = 0) : end = toFinite(end), number2 = toNumber(number2), baseInRange(number2, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating) && (upper = floating = undefined$1), floating === undefined$1 && (typeof upper == "boolean" ? (floating = upper, upper = undefined$1) : typeof lower == "boolean" && (floating = lower, lower = undefined$1)), lower === undefined$1 && upper === undefined$1 ? (lower = 0, upper = 1) : (lower = toFinite(lower), upper === undefined$1 ? (upper = lower, lower = 0) : upper = toFinite(upper)), lower > upper) {
            var temp = lower;
            lower = upper, upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          return word = word.toLowerCase(), result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          return string = toString(string), string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string), target = baseToString(target);
          var length = string.length;
          position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          return position -= target.length, position >= 0 && string.slice(position, end) == target;
        }
        function escape2(string) {
          return string = toString(string), string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          return string = toString(string), string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        }), lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        }), lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string), length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length)
            return string;
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string), length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string), length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          return guard || radix == null ? radix = 0 : radix && (radix = +radix), nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat2(string, n, guard) {
          return (guard ? isIterateeCall(string, n, guard) : n === undefined$1) ? n = 1 : n = toInteger(n), baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator2, limit) {
          return limit && typeof limit != "number" && isIterateeCall(string, separator2, limit) && (separator2 = limit = undefined$1), limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0, limit ? (string = toString(string), string && (typeof separator2 == "string" || separator2 != null && !isRegExp(separator2)) && (separator2 = baseToString(separator2), !separator2 && hasUnicode(string)) ? castSlice(stringToArray(string), 0, limit) : string.split(separator2, limit)) : [];
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          return string = toString(string), position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length), target = baseToString(target), string.slice(position, position + target.length) == target;
        }
        function template(string, options2, guard) {
          var settings = lodash2.templateSettings;
          guard && isIterateeCall(string, options2, guard) && (options2 = undefined$1), string = toString(string), options2 = assignInWith({}, options2, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options2.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys), isEscaping, isEvaluating, index = 0, interpolate = options2.interpolate || reNoMatch, source2 = "__p += '", reDelimiters = RegExp2(
            (options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$",
            "g"
          ), sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options2, "sourceURL") ? (options2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + `
`;
          string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            return interpolateValue || (interpolateValue = esTemplateValue), source2 += string.slice(index, offset).replace(reUnescapedString, escapeStringChar), escapeValue && (isEscaping = !0, source2 += `' +
__e(` + escapeValue + `) +
'`), evaluateValue && (isEvaluating = !0, source2 += `';
` + evaluateValue + `;
__p += '`), interpolateValue && (source2 += `' +
((__t = (` + interpolateValue + `)) == null ? '' : __t) +
'`), index = offset + match2.length, match2;
          }), source2 += `';
`;
          var variable = hasOwnProperty2.call(options2, "variable") && options2.variable;
          if (!variable)
            source2 = `with (obj) {
` + source2 + `
}
`;
          else if (reForbiddenIdentifierChars.test(variable))
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          source2 = (isEvaluating ? source2.replace(reEmptyStringLeading, "") : source2).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;"), source2 = "function(" + (variable || "obj") + `) {
` + (variable ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + source2 + `return __p
}`;
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source2).apply(undefined$1, importsValues);
          });
          if (result2.source = source2, isError(result2))
            throw result2;
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          if (string = toString(string), string && (guard || chars === undefined$1))
            return baseTrim(string);
          if (!string || !(chars = baseToString(chars)))
            return string;
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          if (string = toString(string), string && (guard || chars === undefined$1))
            return string.slice(0, trimmedEndIndex(string) + 1);
          if (!string || !(chars = baseToString(chars)))
            return string;
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          if (string = toString(string), string && (guard || chars === undefined$1))
            return string.replace(reTrimStart, "");
          if (!string || !(chars = baseToString(chars)))
            return string;
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options2) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options2)) {
            var separator2 = "separator" in options2 ? options2.separator : separator2;
            length = "length" in options2 ? toInteger(options2.length) : length, omission = "omission" in options2 ? baseToString(options2.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength)
            return string;
          var end = length - stringSize(omission);
          if (end < 1)
            return omission;
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator2 === undefined$1)
            return result2 + omission;
          if (strSymbols && (end += result2.length - end), isRegExp(separator2)) {
            if (string.slice(end).search(separator2)) {
              var match2, substring = result2;
              for (separator2.global || (separator2 = RegExp2(separator2.source, toString(reFlags.exec(separator2)) + "g")), separator2.lastIndex = 0; match2 = separator2.exec(substring); )
                var newEnd = match2.index;
              result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator2), end) != end) {
            var index = result2.lastIndexOf(separator2);
            index > -1 && (result2 = result2.slice(0, index));
          }
          return result2 + omission;
        }
        function unescape2(string) {
          return string = toString(string), string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        }), upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          return string = toString(string), pattern = guard ? undefined$1 : pattern, pattern === undefined$1 ? hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string) : string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined$1, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        }), bindAll = flatRest(function(object, methodNames) {
          return arrayEach(methodNames, function(key2) {
            key2 = toKey(key2), baseAssignValue(object, key2, bind(object[key2], object));
          }), object;
        });
        function cond(pairs2) {
          var length = pairs2 == null ? 0 : pairs2.length, toIteratee = getIteratee();
          return pairs2 = length ? arrayMap(pairs2, function(pair) {
            if (typeof pair[1] != "function")
              throw new TypeError2(FUNC_ERROR_TEXT);
            return [toIteratee(pair[0]), pair[1]];
          }) : [], baseRest(function(args) {
            for (var index = -1; ++index < length; ) {
              var pair = pairs2[index];
              if (apply(pair[0], this, args))
                return apply(pair[1], this, args);
            }
          });
        }
        function conforms(source2) {
          return baseConforms(baseClone(source2, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow2 = createFlow(), flowRight = createFlow(!0);
        function identity2(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source2) {
          return baseMatches(baseClone(source2, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path2, srcValue) {
          return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path2, args) {
          return function(object) {
            return baseInvoke(object, path2, args);
          };
        }), methodOf = baseRest(function(object, args) {
          return function(path2) {
            return baseInvoke(object, path2, args);
          };
        });
        function mixin(object, source2, options2) {
          var props = keys(source2), methodNames = baseFunctions(source2, props);
          options2 == null && !(isObject2(source2) && (methodNames.length || !props.length)) && (options2 = source2, source2 = object, object = this, methodNames = baseFunctions(source2, keys(source2)));
          var chain2 = !(isObject2(options2) && "chain" in options2) || !!options2.chain, isFunc = isFunction2(object);
          return arrayEach(methodNames, function(methodName) {
            var func = source2[methodName];
            object[methodName] = func, isFunc && (object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                return actions.push({ func, args: arguments, thisArg: object }), result2.__chain__ = chainAll, result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            });
          }), object;
        }
        function noConflict() {
          return root2._ === this && (root2._ = oldDash), this;
        }
        function noop2() {
        }
        function nthArg(n) {
          return n = toInteger(n), baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap), overEvery = createOver(arrayEvery), overSome = createOver(arraySome);
        function property(path2) {
          return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
        }
        function propertyOf(object) {
          return function(path2) {
            return object == null ? undefined$1 : baseGet(object, path2);
          };
        }
        var range2 = createRange(), rangeRight = createRange(!0);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return !1;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return !0;
        }
        function times(n, iteratee2) {
          if (n = toInteger(n), n < 1 || n > MAX_SAFE_INTEGER)
            return [];
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2), n -= MAX_ARRAY_LENGTH;
          for (var result2 = baseTimes(length, iteratee2); ++index < n; )
            iteratee2(index);
          return result2;
        }
        function toPath(value) {
          return isArray2(value) ? arrayMap(value, toKey) : isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0), ceil = createRound("ceil"), divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1), floor = createRound("floor");
        function max2(array) {
          return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined$1;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
        }
        function mean(array) {
          return baseMean(array, identity2);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min2(array) {
          return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined$1;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1), round2 = createRound("round"), subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity2) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        return lodash2.after = after, lodash2.ary = ary, lodash2.assign = assign, lodash2.assignIn = assignIn, lodash2.assignInWith = assignInWith, lodash2.assignWith = assignWith, lodash2.at = at, lodash2.before = before, lodash2.bind = bind, lodash2.bindAll = bindAll, lodash2.bindKey = bindKey, lodash2.castArray = castArray, lodash2.chain = chain, lodash2.chunk = chunk, lodash2.compact = compact, lodash2.concat = concat2, lodash2.cond = cond, lodash2.conforms = conforms, lodash2.constant = constant, lodash2.countBy = countBy, lodash2.create = create, lodash2.curry = curry, lodash2.curryRight = curryRight, lodash2.debounce = debounce2, lodash2.defaults = defaults2, lodash2.defaultsDeep = defaultsDeep, lodash2.defer = defer2, lodash2.delay = delay2, lodash2.difference = difference, lodash2.differenceBy = differenceBy, lodash2.differenceWith = differenceWith, lodash2.drop = drop, lodash2.dropRight = dropRight, lodash2.dropRightWhile = dropRightWhile, lodash2.dropWhile = dropWhile, lodash2.fill = fill, lodash2.filter = filter2, lodash2.flatMap = flatMap2, lodash2.flatMapDeep = flatMapDeep, lodash2.flatMapDepth = flatMapDepth, lodash2.flatten = flatten, lodash2.flattenDeep = flattenDeep, lodash2.flattenDepth = flattenDepth, lodash2.flip = flip2, lodash2.flow = flow2, lodash2.flowRight = flowRight, lodash2.fromPairs = fromPairs, lodash2.functions = functions, lodash2.functionsIn = functionsIn, lodash2.groupBy = groupBy2, lodash2.initial = initial, lodash2.intersection = intersection, lodash2.intersectionBy = intersectionBy, lodash2.intersectionWith = intersectionWith, lodash2.invert = invert, lodash2.invertBy = invertBy, lodash2.invokeMap = invokeMap, lodash2.iteratee = iteratee, lodash2.keyBy = keyBy, lodash2.keys = keys, lodash2.keysIn = keysIn, lodash2.map = map2, lodash2.mapKeys = mapKeys, lodash2.mapValues = mapValues, lodash2.matches = matches, lodash2.matchesProperty = matchesProperty, lodash2.memoize = memoize, lodash2.merge = merge2, lodash2.mergeWith = mergeWith, lodash2.method = method, lodash2.methodOf = methodOf, lodash2.mixin = mixin, lodash2.negate = negate, lodash2.nthArg = nthArg, lodash2.omit = omit, lodash2.omitBy = omitBy, lodash2.once = once2, lodash2.orderBy = orderBy, lodash2.over = over, lodash2.overArgs = overArgs, lodash2.overEvery = overEvery, lodash2.overSome = overSome, lodash2.partial = partial, lodash2.partialRight = partialRight, lodash2.partition = partition2, lodash2.pick = pick, lodash2.pickBy = pickBy, lodash2.property = property, lodash2.propertyOf = propertyOf, lodash2.pull = pull, lodash2.pullAll = pullAll, lodash2.pullAllBy = pullAllBy, lodash2.pullAllWith = pullAllWith, lodash2.pullAt = pullAt, lodash2.range = range2, lodash2.rangeRight = rangeRight, lodash2.rearg = rearg, lodash2.reject = reject, lodash2.remove = remove, lodash2.rest = rest, lodash2.reverse = reverse, lodash2.sampleSize = sampleSize, lodash2.set = set2, lodash2.setWith = setWith, lodash2.shuffle = shuffle, lodash2.slice = slice, lodash2.sortBy = sortBy, lodash2.sortedUniq = sortedUniq, lodash2.sortedUniqBy = sortedUniqBy, lodash2.split = split, lodash2.spread = spread, lodash2.tail = tail, lodash2.take = take2, lodash2.takeRight = takeRight, lodash2.takeRightWhile = takeRightWhile, lodash2.takeWhile = takeWhile2, lodash2.tap = tap2, lodash2.throttle = throttle2, lodash2.thru = thru, lodash2.toArray = toArray2, lodash2.toPairs = toPairs, lodash2.toPairsIn = toPairsIn, lodash2.toPath = toPath, lodash2.toPlainObject = toPlainObject, lodash2.transform = transform, lodash2.unary = unary, lodash2.union = union, lodash2.unionBy = unionBy, lodash2.unionWith = unionWith, lodash2.uniq = uniq, lodash2.uniqBy = uniqBy, lodash2.uniqWith = uniqWith, lodash2.unset = unset, lodash2.unzip = unzip, lodash2.unzipWith = unzipWith, lodash2.update = update2, lodash2.updateWith = updateWith, lodash2.values = values, lodash2.valuesIn = valuesIn, lodash2.without = without, lodash2.words = words, lodash2.wrap = wrap2, lodash2.xor = xor, lodash2.xorBy = xorBy, lodash2.xorWith = xorWith, lodash2.zip = zip2, lodash2.zipObject = zipObject, lodash2.zipObjectDeep = zipObjectDeep, lodash2.zipWith = zipWith, lodash2.entries = toPairs, lodash2.entriesIn = toPairsIn, lodash2.extend = assignIn, lodash2.extendWith = assignInWith, mixin(lodash2, lodash2), lodash2.add = add, lodash2.attempt = attempt, lodash2.camelCase = camelCase, lodash2.capitalize = capitalize, lodash2.ceil = ceil, lodash2.clamp = clamp, lodash2.clone = clone, lodash2.cloneDeep = cloneDeep, lodash2.cloneDeepWith = cloneDeepWith, lodash2.cloneWith = cloneWith, lodash2.conformsTo = conformsTo, lodash2.deburr = deburr, lodash2.defaultTo = defaultTo, lodash2.divide = divide, lodash2.endsWith = endsWith, lodash2.eq = eq, lodash2.escape = escape2, lodash2.escapeRegExp = escapeRegExp, lodash2.every = every2, lodash2.find = find2, lodash2.findIndex = findIndex2, lodash2.findKey = findKey, lodash2.findLast = findLast, lodash2.findLastIndex = findLastIndex, lodash2.findLastKey = findLastKey, lodash2.floor = floor, lodash2.forEach = forEach, lodash2.forEachRight = forEachRight, lodash2.forIn = forIn, lodash2.forInRight = forInRight, lodash2.forOwn = forOwn, lodash2.forOwnRight = forOwnRight, lodash2.get = get, lodash2.gt = gt, lodash2.gte = gte, lodash2.has = has, lodash2.hasIn = hasIn, lodash2.head = head, lodash2.identity = identity2, lodash2.includes = includes, lodash2.indexOf = indexOf, lodash2.inRange = inRange, lodash2.invoke = invoke, lodash2.isArguments = isArguments, lodash2.isArray = isArray2, lodash2.isArrayBuffer = isArrayBuffer, lodash2.isArrayLike = isArrayLike2, lodash2.isArrayLikeObject = isArrayLikeObject, lodash2.isBoolean = isBoolean, lodash2.isBuffer = isBuffer, lodash2.isDate = isDate2, lodash2.isElement = isElement, lodash2.isEmpty = isEmpty2, lodash2.isEqual = isEqual, lodash2.isEqualWith = isEqualWith, lodash2.isError = isError, lodash2.isFinite = isFinite2, lodash2.isFunction = isFunction2, lodash2.isInteger = isInteger2, lodash2.isLength = isLength, lodash2.isMap = isMap, lodash2.isMatch = isMatch, lodash2.isMatchWith = isMatchWith, lodash2.isNaN = isNaN2, lodash2.isNative = isNative, lodash2.isNil = isNil, lodash2.isNull = isNull, lodash2.isNumber = isNumber2, lodash2.isObject = isObject2, lodash2.isObjectLike = isObjectLike, lodash2.isPlainObject = isPlainObject2, lodash2.isRegExp = isRegExp, lodash2.isSafeInteger = isSafeInteger, lodash2.isSet = isSet, lodash2.isString = isString, lodash2.isSymbol = isSymbol, lodash2.isTypedArray = isTypedArray, lodash2.isUndefined = isUndefined, lodash2.isWeakMap = isWeakMap, lodash2.isWeakSet = isWeakSet, lodash2.join = join, lodash2.kebabCase = kebabCase, lodash2.last = last2, lodash2.lastIndexOf = lastIndexOf, lodash2.lowerCase = lowerCase, lodash2.lowerFirst = lowerFirst, lodash2.lt = lt, lodash2.lte = lte, lodash2.max = max2, lodash2.maxBy = maxBy, lodash2.mean = mean, lodash2.meanBy = meanBy, lodash2.min = min2, lodash2.minBy = minBy, lodash2.stubArray = stubArray, lodash2.stubFalse = stubFalse, lodash2.stubObject = stubObject, lodash2.stubString = stubString, lodash2.stubTrue = stubTrue, lodash2.multiply = multiply, lodash2.nth = nth, lodash2.noConflict = noConflict, lodash2.noop = noop2, lodash2.now = now, lodash2.pad = pad, lodash2.padEnd = padEnd, lodash2.padStart = padStart, lodash2.parseInt = parseInt2, lodash2.random = random, lodash2.reduce = reduce2, lodash2.reduceRight = reduceRight, lodash2.repeat = repeat2, lodash2.replace = replace, lodash2.result = result, lodash2.round = round2, lodash2.runInContext = runInContext2, lodash2.sample = sample2, lodash2.size = size, lodash2.snakeCase = snakeCase, lodash2.some = some, lodash2.sortedIndex = sortedIndex, lodash2.sortedIndexBy = sortedIndexBy, lodash2.sortedIndexOf = sortedIndexOf, lodash2.sortedLastIndex = sortedLastIndex, lodash2.sortedLastIndexBy = sortedLastIndexBy, lodash2.sortedLastIndexOf = sortedLastIndexOf, lodash2.startCase = startCase, lodash2.startsWith = startsWith, lodash2.subtract = subtract, lodash2.sum = sum, lodash2.sumBy = sumBy, lodash2.template = template, lodash2.times = times, lodash2.toFinite = toFinite, lodash2.toInteger = toInteger, lodash2.toLength = toLength, lodash2.toLower = toLower, lodash2.toNumber = toNumber, lodash2.toSafeInteger = toSafeInteger, lodash2.toString = toString, lodash2.toUpper = toUpper, lodash2.trim = trim, lodash2.trimEnd = trimEnd, lodash2.trimStart = trimStart, lodash2.truncate = truncate, lodash2.unescape = unescape2, lodash2.uniqueId = uniqueId, lodash2.upperCase = upperCase, lodash2.upperFirst = upperFirst, lodash2.each = forEach, lodash2.eachRight = forEachRight, lodash2.first = head, mixin(lodash2, function() {
          var source2 = {};
          return baseForOwn(lodash2, function(func, methodName) {
            hasOwnProperty2.call(lodash2.prototype, methodName) || (source2[methodName] = func);
          }), source2;
        }(), { chain: !1 }), lodash2.VERSION = VERSION, arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash2[methodName].placeholder = lodash2;
        }), arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            return result2.__filtered__ ? result2.__takeCount__ = nativeMin(n, result2.__takeCount__) : result2.__views__.push({
              size: nativeMin(n, MAX_ARRAY_LENGTH),
              type: methodName + (result2.__dir__ < 0 ? "Right" : "")
            }), result2;
          }, LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        }), arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type2 = index + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            return result2.__iteratees__.push({
              iteratee: getIteratee(iteratee2, 3),
              type: type2
            }), result2.__filtered__ = result2.__filtered__ || isFilter, result2;
          };
        }), arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        }), arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        }), LazyWrapper.prototype.compact = function() {
          return this.filter(identity2);
        }, LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        }, LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        }, LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
          return typeof path2 == "function" ? new LazyWrapper(this) : this.map(function(value) {
            return baseInvoke(value, path2, args);
          });
        }), LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        }, LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          return result2.__filtered__ && (start > 0 || end < 0) ? new LazyWrapper(result2) : (start < 0 ? result2 = result2.takeRight(-start) : start && (result2 = result2.drop(start)), end !== undefined$1 && (end = toInteger(end), result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start)), result2);
        }, LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        }, LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        }, baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          lodashFunc && (lodash2.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value), interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1 && (isLazy = useLazy = !1);
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              return result2.__actions__.push({ func: thru, args: [interceptor], thisArg: undefined$1 }), new LodashWrapper(result2, chainAll);
            }
            return isUnwrapped && onlyLazy ? func.apply(this, args) : (result2 = this.thru(interceptor), isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2);
          });
        }), arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash2.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        }), baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash2[methodName];
          if (lodashFunc) {
            var key2 = lodashFunc.name + "";
            hasOwnProperty2.call(realNames, key2) || (realNames[key2] = []), realNames[key2].push({ name: methodName, func: lodashFunc });
          }
        }), realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          name: "wrapper",
          func: undefined$1
        }], LazyWrapper.prototype.clone = lazyClone, LazyWrapper.prototype.reverse = lazyReverse, LazyWrapper.prototype.value = lazyValue, lodash2.prototype.at = wrapperAt, lodash2.prototype.chain = wrapperChain, lodash2.prototype.commit = wrapperCommit, lodash2.prototype.next = wrapperNext, lodash2.prototype.plant = wrapperPlant, lodash2.prototype.reverse = wrapperReverse, lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue, lodash2.prototype.first = lodash2.prototype.head, symIterator && (lodash2.prototype[symIterator] = wrapperToIterator), lodash2;
      }, _ = runInContext();
      freeModule ? ((freeModule.exports = _)._ = _, freeExports._ = _) : root2._ = _;
    }).call(lodash);
  }(lodash$1, lodash$1.exports)), lodash$1.exports;
}
var lodashExports = requireLodash();
const helpText$n = `
Arguments
  <type>  Type of Resource to add (currently only 'function' is supported)

Options
  --name, -n <name>              Name of the Resource
  --fn-type <type>               Type of Function to add (e.g. document-publish)
  --fn-language, --lang <ts|js>  Language of the Function. Default: "ts"
  --js, --javascript             Shortcut for --fn-language=js
  --fn-helpers, --helpers        Add helpers to the Function
  --no-fn-helpers                Do not add helpers to the Function
  --fn-installer,                Package manager to use for Function helpers
    --installer <npm|pnpm|yarn>    sets --fn-helpers to true
  --install, -i                  Shortcut for --fn-installer=npm

Examples:
  # Add a Function (TypeScript by default)
  sanity blueprints add function

  # Add a Function with a specific name and install helpers with npm
  sanity blueprints add function --name my-function -i

  # Add a Function with a specific type
  sanity blueprints add function --fn-type document-publish

  # Add a Function using an example
  sanity blueprints add function --example example-name

  # Add a JavaScript Function
  sanity blueprints add function --js

  # Add a Function without helpers
  sanity blueprints add function --no-fn-helpers

  # Add a document-publish .js Function with helpers and install with npm
  sanity blueprints add function -n roboto --fn-type document-publish --js -i
`, defaultFlags$b = {
  "fn-language": "ts"
  // 'fn-helpers': true, // ask, for now
}, addBlueprintsCommand = {
  name: "add",
  group: "blueprints",
  helpText: helpText$n,
  signature: "<type> [--name <name>] [--fn-type <document-publish>] [--fn-lang <ts|js>] [--javascript]",
  description: "Add a Resource to a Blueprint",
  async action(args, context) {
    const { output, apiClient } = context, { extOptions } = args;
    if (extOptions.example) {
      const foundConflict = [
        "name",
        "n",
        "fn-type",
        "fn-language",
        "lang",
        "javascript",
        "js",
        "fn-helpers",
        "helpers",
        "fn-installer",
        "installer"
      ].find((key2) => extOptions[key2]);
      if (foundConflict)
        throw new Error(`--example can't be used with --${foundConflict}`);
    }
    const flags = { ...defaultFlags$b, ...extOptions }, client2 = apiClient({
      requireUser: !0,
      requireProject: !1
    }), { token: token2 } = client2.config();
    if (!token2) throw new Error("No API token found. Please run `sanity login`.");
    const [resourceType] = args.argsWithoutOptions;
    if (!resourceType) {
      output.error("Resource type is required. Available types: function");
      return;
    }
    const { initBlueprintConfig } = await import("@sanity/runtime-cli/cores"), { blueprintAddCore } = await import("@sanity/runtime-cli/cores/blueprints"), cmdConfig = await initBlueprintConfig({
      bin: "sanity",
      log: (message) => output.print(message),
      token: token2
    });
    if (!cmdConfig.ok) throw new Error(cmdConfig.error);
    let userWantsFnHelpers = flags.helpers || flags["fn-helpers"];
    flags["no-fn-helpers"] === !0 && (userWantsFnHelpers = !1);
    const { success, error: error2 } = await blueprintAddCore({
      ...cmdConfig.value,
      args: { type: resourceType },
      flags: {
        example: flags.example,
        name: flags.n ?? flags.name,
        "fn-type": flags["fn-type"],
        language: flags.lang ?? flags["fn-language"],
        javascript: flags.js || flags.javascript,
        "fn-helpers": userWantsFnHelpers,
        "fn-installer": flags.installer ?? flags["fn-installer"],
        install: flags.i || flags.install
      }
    });
    if (!success) throw new Error(error2);
  }
}, blueprintsGroup = {
  name: "blueprints",
  signature: "[COMMAND]",
  isGroupRoot: !0,
  description: "Deploy and manage Sanity Blueprints and Stacks (IaC)"
}, helpText$m = `
Options
  --edit, -e           Edit the configuration
  --test, -t           Test the configuration
  --project-id <id>    Project ID to use

Examples:
  # View current configuration
  sanity blueprints config

  # Edit configuration
  sanity blueprints config --edit

  # Test configuration
  sanity blueprints config --test

  # Edit and test configuration
  sanity blueprints config -et
`, defaultFlags$a = {
  //
}, configBlueprintsCommand = {
  name: "config",
  group: "blueprints",
  helpText: helpText$m,
  signature: "[--edit] [-e] [--test] [-t] [--project-id <id>]",
  description: "View or edit local Blueprints configuration",
  async action(args, context) {
    const { apiClient, output } = context, flags = { ...defaultFlags$a, ...args.extOptions }, client2 = apiClient({
      requireUser: !0,
      requireProject: !1
    }), { token: token2 } = client2.config();
    if (!token2) throw new Error("No API token found. Please run `sanity login`.");
    const { initBlueprintConfig } = await import("@sanity/runtime-cli/cores"), { blueprintConfigCore } = await import("@sanity/runtime-cli/cores/blueprints"), cmdConfig = await initBlueprintConfig({
      bin: "sanity",
      log: (message) => output.print(message),
      token: token2
    });
    if (!cmdConfig.ok) throw new Error(cmdConfig.error);
    const { success, error: error2 } = await blueprintConfigCore({
      ...cmdConfig.value,
      token: token2,
      flags: {
        "project-id": flags["project-id"] ?? flags.projectId ?? flags.project,
        "stack-id": flags["stack-id"] ?? flags.stackId ?? flags.stack,
        "test-config": flags["test-config"] ?? flags.test ?? flags.t,
        edit: flags.edit ?? flags.e
      }
    });
    if (!success) throw new Error(error2);
  }
}, helpText$l = `
Options
  --no-wait    Do not wait for deployment to complete

Examples:
  # Deploy the current blueprint
  sanity blueprints deploy

  # Deploy the current blueprint without waiting for completion
  sanity blueprints deploy --no-wait
`, defaultFlags$9 = {
  //
}, deployBlueprintsCommand = {
  name: "deploy",
  group: "blueprints",
  helpText: helpText$l,
  signature: "[--no-wait]",
  description: "Deploy a Blueprint to create or update a Stack",
  async action(args, context) {
    const { apiClient, output } = context, flags = { ...defaultFlags$9, ...args.extOptions }, client2 = apiClient({
      requireUser: !0,
      requireProject: !1
    }), { token: token2 } = client2.config();
    if (!token2) throw new Error("No API token found. Please run `sanity login`.");
    const { initDeployedBlueprintConfig } = await import("@sanity/runtime-cli/cores"), { blueprintDeployCore } = await import("@sanity/runtime-cli/cores/blueprints"), cmdConfig = await initDeployedBlueprintConfig({
      bin: "sanity",
      log: (message) => output.print(message),
      token: token2
    });
    if (!cmdConfig.ok) throw new Error(cmdConfig.error);
    const { success, error: error2 } = await blueprintDeployCore({
      ...cmdConfig.value,
      flags: {
        "no-wait": flags["no-wait"]
      }
    });
    if (!success) throw new Error(error2);
  }
}, helpText$k = `
Options
  --force, -f    Force destroy without confirmation
  --no-wait      Do not wait for destroy to complete

Examples:
  # Destroy the current deployment
  sanity blueprints destroy

  # Force destroy without confirmation
  sanity blueprints destroy --force

  # Destroy without waiting for completion
  sanity blueprints destroy --no-wait
`, defaultFlags$8 = {
  //
}, destroyBlueprintsCommand = {
  name: "destroy",
  group: "blueprints",
  helpText: helpText$k,
  signature: "[--force] [-f] [--no-wait]",
  description: "Destroy a Blueprint deployment",
  async action(args, context) {
    const { apiClient, output } = context, flags = { ...defaultFlags$8, ...args.extOptions }, client2 = apiClient({
      requireUser: !0,
      requireProject: !1
    }), { token: token2 } = client2.config();
    if (!token2) throw new Error("No API token found. Please run `sanity login`.");
    const { initBlueprintConfig } = await import("@sanity/runtime-cli/cores"), { blueprintDestroyCore } = await import("@sanity/runtime-cli/cores/blueprints"), cmdConfig = await initBlueprintConfig({
      bin: "sanity",
      log: (message) => output.print(message),
      token: token2
    });
    if (!cmdConfig.ok) throw new Error(cmdConfig.error);
    const { success, error: error2 } = await blueprintDestroyCore({
      ...cmdConfig.value,
      flags: {
        "no-wait": flags["no-wait"],
        force: flags.force ?? flags.f,
        "project-id": flags["project-id"] ?? flags.projectId ?? flags.project,
        "stack-id": flags["stack-id"] ?? flags.stackId ?? flags.stack
      }
    });
    if (!success) throw new Error(error2);
  }
}, helpText$j = `
Examples:
  # Retrieve information about the current Stack
  sanity blueprints info
`, defaultFlags$7 = {
  //
}, infoBlueprintsCommand = {
  name: "info",
  group: "blueprints",
  helpText: helpText$j,
  signature: "",
  description: "Retrieve information about a Blueprint Stack",
  async action(args, context) {
    const { apiClient, output } = context, flags = { ...defaultFlags$7, ...args.extOptions }, client2 = apiClient({
      requireUser: !0,
      requireProject: !1
    }), { token: token2 } = client2.config();
    if (!token2) throw new Error("No API token found. Please run `sanity login`.");
    const { initDeployedBlueprintConfig } = await import("@sanity/runtime-cli/cores"), { blueprintInfoCore } = await import("@sanity/runtime-cli/cores/blueprints"), cmdConfig = await initDeployedBlueprintConfig({
      bin: "sanity",
      log: (message) => output.print(message),
      token: token2
    });
    if (!cmdConfig.ok) throw new Error(cmdConfig.error);
    const { success, error: error2 } = await blueprintInfoCore({
      ...cmdConfig.value,
      flags
    });
    if (!success) throw new Error(error2);
  }
}, helpText$i = `
Arguments
  [dir]  Path to initialize the Blueprint in

Options
  --blueprint-type, --type <json>    Type of Blueprint to create
  --project-id <id>                  Project ID to use

Examples:
  # Create a new Blueprint project in the current directory
  sanity blueprints init

  # Create a new Blueprint project in a specific directory
  sanity blueprints init my-sanity-project --type json

  # Create a new Blueprint project in a specific directory with an example
  sanity blueprints init --example example-name
`, defaultFlags$6 = {
  //
}, initBlueprintsCommand = {
  name: "init",
  group: "blueprints",
  helpText: helpText$i,
  signature: "[dir] [--blueprint-type <type>] [--project-id <id>]",
  description: "Initialize a new Blueprint manifest file",
  async action(args, context) {
    const { apiClient, output } = context, flags = { ...defaultFlags$6, ...args.extOptions }, [dir] = args.argsWithoutOptions, client2 = apiClient({
      requireUser: !0,
      requireProject: !1
    }), { token: token2 } = client2.config();
    if (!token2) throw new Error("No API token found. Please run `sanity login`.");
    const { blueprintInitCore } = await import("@sanity/runtime-cli/cores/blueprints");
    if (flags.example) {
      const foundConflict = [
        "blueprint-type",
        "type",
        "stack-id",
        "stackId",
        "stack",
        "stack-name",
        "name"
      ].find((key2) => flags[key2]);
      if (foundConflict)
        throw new Error(`--example can't be used with --${foundConflict}`);
    }
    const { success, error: error2 } = await blueprintInitCore({
      bin: "sanity",
      log: (message) => output.print(message),
      token: token2,
      args: {
        dir: dir ?? flags.dir
      },
      flags: {
        example: flags.example,
        "blueprint-type": flags["blueprint-type"] ?? flags.type,
        "project-id": flags["project-id"] ?? flags.projectId ?? flags.project,
        "stack-id": flags["stack-id"] ?? flags.stackId ?? flags.stack,
        "stack-name": flags["stack-name"] ?? flags.name
      }
    });
    if (!success) throw new Error(error2);
  }
}, helpText$h = `
Options
  --watch, -w    Watch for new logs (streaming mode)

Examples:
  # Show logs for the current Stack
  sanity blueprints logs

  # Watch for new logs (streaming mode)
  sanity blueprints logs --watch
`, defaultFlags$5 = {
  //
}, logsBlueprintsCommand = {
  name: "logs",
  group: "blueprints",
  helpText: helpText$h,
  signature: "[--watch] [-w]",
  description: "Display logs for the current Blueprint Stack",
  async action(args, context) {
    const { apiClient, output } = context, flags = { ...defaultFlags$5, ...args.extOptions }, client2 = apiClient({
      requireUser: !0,
      requireProject: !1
    }), { token: token2 } = client2.config();
    if (!token2) throw new Error("No API token found. Please run `sanity login`.");
    const { initDeployedBlueprintConfig } = await import("@sanity/runtime-cli/cores"), { blueprintLogsCore } = await import("@sanity/runtime-cli/cores/blueprints"), cmdConfig = await initDeployedBlueprintConfig({
      bin: "sanity",
      log: (message) => output.print(message),
      token: token2
    });
    if (!cmdConfig.ok) throw new Error(cmdConfig.error);
    const { success, streaming, error: error2 } = await blueprintLogsCore({
      ...cmdConfig.value,
      flags: {
        watch: flags.watch ?? flags.w
      }
    });
    if (streaming && await streaming, !success) throw new Error(error2);
  }
}, helpText$g = `
Safe to run at any time. Will not modify any Resources.

Examples:
  # Show deployment plan for the current Blueprint
  sanity blueprints plan
`, planBlueprintsCommand = {
  name: "plan",
  group: "blueprints",
  helpText: helpText$g,
  signature: "",
  description: "Enumerate Resources to be deployed",
  async action(args, context) {
    const { apiClient, output } = context, client2 = apiClient({
      requireUser: !0,
      requireProject: !1
    }), { token: token2 } = client2.config();
    if (!token2) throw new Error("No API token found. Please run `sanity login`.");
    const { initBlueprintConfig } = await import("@sanity/runtime-cli/cores"), { blueprintPlanCore } = await import("@sanity/runtime-cli/cores/blueprints"), cmdConfig = await initBlueprintConfig({
      bin: "sanity",
      log: (message) => output.print(message),
      token: token2
    });
    if (!cmdConfig.ok) throw new Error(cmdConfig.error);
    const { success, error: error2 } = await blueprintPlanCore({
      ...cmdConfig.value
    });
    if (!success) throw new Error(error2);
  }
}, helpText$f = `
Options
  --project-id <id>    Project ID to use

Examples:
  # List all Stacks for the current Project
  sanity blueprints stacks

  # List Stacks for a specific project
  sanity blueprints stacks --project-id abc123
`, defaultFlags$4 = {
  //
}, stacksBlueprintsCommand = {
  name: "stacks",
  group: "blueprints",
  helpText: helpText$f,
  signature: "[--project-id <id>]",
  description: "List all Blueprint Stacks for the current Project",
  hideFromHelp: !0,
  async action(args, context) {
    const { apiClient, output } = context, flags = { ...defaultFlags$4, ...args.extOptions }, client2 = apiClient({
      requireUser: !0,
      requireProject: !1
    }), { token: token2 } = client2.config();
    if (!token2) throw new Error("No API token found. Please run `sanity login`.");
    const { initBlueprintConfig } = await import("@sanity/runtime-cli/cores"), { blueprintStacksCore } = await import("@sanity/runtime-cli/cores/blueprints"), cmdConfig = await initBlueprintConfig({
      bin: "sanity",
      log: (message) => output.print(message),
      token: token2
    });
    if (!cmdConfig.ok) throw new Error(cmdConfig.error);
    const { success, error: error2 } = await blueprintStacksCore({
      ...cmdConfig.value,
      flags: {
        "project-id": flags["project-id"] ?? flags.projectId ?? flags.project
      }
    });
    if (!success) throw new Error(error2);
  }
}, purpose$2 = "Transform `sanity/desk` imports to `sanity/structure`", description$3 = `
Modifies all code paths that are found to import  from 'sanity/desk' to instead import from
'sanity/structure', and renames any renamed members.

from: import {deskTool} from 'sanity/desk'
  to: import {structureTool} from 'sanity/structure'

from: import {StructureBuilder} from 'sanity/desk'
  to: import {StructureBuilder} from 'sanity/structure'
`.trim(), deskRename = {
  purpose: purpose$2,
  description: description$3,
  filename: "deskRename.js"
}, purpose$1 = "Add parts types directive to all ts/tsx files that has one or more part imports", description$2 = `
Adds a '///<reference types="@sanity/types/parts" />' header to all source files that has one or more part imports.
For example:

Before:
---- somefile.ts
import client from 'part:@sanity/base/client'
//\u2026
----

After:
---- somefile.ts
///<reference types="@sanity/types/parts" />
import client from 'part:@sanity/base/client'
//\u2026
----


`.trim(), partsTypeDirective = {
  purpose: purpose$1,
  description: description$2,
  filename: "partsTypeDirective.js"
};
var semverCompare$1, hasRequiredSemverCompare;
function requireSemverCompare() {
  return hasRequiredSemverCompare || (hasRequiredSemverCompare = 1, semverCompare$1 = function(a, b) {
    for (var pa = a.split("."), pb = b.split("."), i = 0; i < 3; i++) {
      var na = Number(pa[i]), nb = Number(pb[i]);
      if (na > nb) return 1;
      if (nb > na) return -1;
      if (!isNaN(na) && isNaN(nb)) return 1;
      if (isNaN(na) && !isNaN(nb)) return -1;
    }
    return 0;
  }), semverCompare$1;
}
var semverCompareExports = requireSemverCompare(), semverCompare = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(semverCompareExports);
async function readJson(filePath) {
  const content = await fs.readFile(filePath, "utf8");
  return JSON.parse(content);
}
const purpose = "Transform react-icons v2 imports to v3 form", description$1 = `
Modifies all found react-icons import and require statements from their v2 form
to the path structure used in react-icons v3. For instance:

from: import {MdPerson} from 'react-icons/lib/md'
  to: import {MdPerson} from 'react-icons/md'

from: import PersonIcon from 'react-icons/lib/md/person'
  to: import {MdPerson as PersonIcon} from 'react-icons/md'
`.trim(), reactIconsV3 = {
  purpose,
  description: description$1,
  filename: "reactIconsV3.js",
  verify: async (context) => {
    const { workDir } = context, studioPkg = await maybeReadJson(path__default.default.join(workDir, "package.json")), dependencyVersion = ((studioPkg && studioPkg.dependencies || {})["react-icons"] || "").replace(/^[\^~]/, "");
    if (!dependencyVersion)
      throw new Error("Could not find react-icons declared as dependency in package.json");
    if (semverCompare(dependencyVersion, "3.0.0") < 0)
      throw new Error("react-icons declared in package.json dependencies is lower than 3.0.0");
    const iconPkgPath = resolveFrom.silent(workDir, "react-icons/package.json"), iconPkg = iconPkgPath && await maybeReadJson(iconPkgPath);
    if (iconPkg && semverCompare(iconPkg.version, "3.0.0") < 0)
      throw new Error("The installed version of react-icon seems to be < 3.0.0");
  }
};
async function maybeReadJson(jsonPath) {
  try {
    return await readJson(jsonPath);
  } catch {
    return null;
  }
}
var mods = {
  reactIconsV3,
  partsTypeDirective,
  deskRename
};
const codemodAction = async function(args, context) {
  const { output, cliRoot, workDir } = context, [name] = args.argsWithoutOptions, cliFlags = args.extOptions;
  if (!name) {
    printMods(output);
    return;
  }
  const normalizedMods = {};
  for (const [originalName, mod2] of Object.entries(mods))
    normalizedMods[originalName.toLowerCase()] = mod2;
  const mod = normalizedMods[name.toLowerCase()];
  if (!mod)
    throw new Error(`Codemod with name "${name}" not found`);
  typeof mod.verify == "function" && cliFlags.verify !== !1 && await mod.verify(context);
  const exts = cliFlags.extensions ? cliFlags.extensions.split(",").map((ext2) => ext2.trim().replace(/^\./, "")) : ["js", "ts", "tsx"], dryRun = !!(!(typeof cliFlags.dry > "u") && cliFlags.dry);
  ensureNpx();
  const hasGitIgnore = fs__namespace.default.existsSync(path__default.default.join(workDir, ".gitignore")), modPath = path__default.default.resolve(path__default.default.join(cliRoot, "codemods", mod.filename)), cmdArgs = [
    "jscodeshift",
    "--ignore-pattern",
    "node_modules",
    "--ignore-pattern",
    "dist",
    hasGitIgnore && "--ignore-config",
    hasGitIgnore && ".gitignore",
    "-t",
    modPath,
    "--extensions",
    exts.join(","),
    dryRun && "--dry",
    workDir
  ].filter((item) => typeof item == "string"), child = childProcess__default.default.spawn("npx", cmdArgs, {
    stdio: "inherit"
  });
  process.on("SIGINT", () => {
    child.kill(2);
  }), child.on("close", (code) => {
    process.exit(code || void 0);
  });
};
function printMods(output) {
  output.print(`Available code modifications:
`);
  for (const [modName, mod] of Object.entries(mods))
    output.print(`${modName} - ${mod.purpose}`);
}
function ensureNpx() {
  try {
    if (!childProcess__default.default.execSync("npx --help", { encoding: "utf8" }).includes("npm"))
      throw new Error("Not the npx we expected");
  } catch {
    throw new Error(
      'Failed to run "npx" - required to run codemods. Do you have a recent version of npm installed?'
    );
  }
}
const helpText$e = `
Runs a given code modification script on the current studio folder.
Running the command without a specified codemod name will list available transformations.

Options
  --dry Dry run (no changes are made to files)
  --extensions=EXT Transform files with these file extensions (comma separated list)
                   (default: js,ts,tsx)
  --no-verify Skips verification steps before running codemod

Examples
  # Show available code mods
  sanity codemod

  # Run codemod to transform react-icons imports from v2 style to v3 style,
  # but only as a dry-run (do not write the files)
  sanity codemod reactIconsV3 --dry

`, codemodCommand = {
  name: "codemod",
  signature: "[CODEMOD_NAME]",
  description: "Updates Sanity Studio codebase with a code modification script",
  helpText: helpText$e,
  action: codemodAction
};
var lodash_isplainobject, hasRequiredLodash_isplainobject;
function requireLodash_isplainobject() {
  if (hasRequiredLodash_isplainobject) return lodash_isplainobject;
  hasRequiredLodash_isplainobject = 1;
  var objectTag = "[object Object]";
  function isHostObject(value) {
    var result = !1;
    if (value != null && typeof value.toString != "function")
      try {
        result = !!(value + "");
      } catch {
      }
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var funcProto = Function.prototype, objectProto = Object.prototype, funcToString = funcProto.toString, hasOwnProperty2 = objectProto.hasOwnProperty, objectCtorString = funcToString.call(Object), objectToString = objectProto.toString, getPrototype = overArg(Object.getPrototypeOf, Object);
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isPlainObject2(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value))
      return !1;
    var proto = getPrototype(value);
    if (proto === null)
      return !0;
    var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  return lodash_isplainobject = isPlainObject2, lodash_isplainobject;
}
var promisePropsRecursive_1, hasRequiredPromisePropsRecursive;
function requirePromisePropsRecursive() {
  if (hasRequiredPromisePropsRecursive) return promisePropsRecursive_1;
  hasRequiredPromisePropsRecursive = 1;
  const isPlainObject2 = requireLodash_isplainobject();
  function isPromiseLike(obj) {
    return obj && typeof obj == "object" && typeof obj.then == "function";
  }
  function promiseProps2(obj) {
    const keys = Object.keys(obj), values = keys.map((key2) => obj[key2]);
    return promiseArray(values).then((results) => {
      const result = {};
      for (let i = 0; i < keys.length; i++)
        result[keys[i]] = results[i];
      return result;
    });
  }
  function promiseArray(arr) {
    return Promise.all(arr.map(promisePropsRecursive));
  }
  function promisePropsRecursive(obj) {
    return isPromiseLike(obj) ? obj.then(promisePropsRecursive) : isPlainObject2(obj) ? promiseProps2(obj) : Array.isArray(obj) ? promiseArray(obj) : Promise.resolve(obj);
  }
  return promisePropsRecursive_1 = promisePropsRecursive, promisePropsRecursive_1;
}
var promisePropsRecursiveExports = requirePromisePropsRecursive(), promiseProps = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(promisePropsRecursiveExports), xdgBasedir$1 = {}, hasRequiredXdgBasedir;
function requireXdgBasedir() {
  return hasRequiredXdgBasedir || (hasRequiredXdgBasedir = 1, function(exports2) {
    const os2 = require$$0__default$2.default, path2 = require$$0__default$1.default, homeDirectory = os2.homedir(), { env } = process;
    exports2.data = env.XDG_DATA_HOME || (homeDirectory ? path2.join(homeDirectory, ".local", "share") : void 0), exports2.config = env.XDG_CONFIG_HOME || (homeDirectory ? path2.join(homeDirectory, ".config") : void 0), exports2.cache = env.XDG_CACHE_HOME || (homeDirectory ? path2.join(homeDirectory, ".cache") : void 0), exports2.runtime = env.XDG_RUNTIME_DIR || void 0, exports2.dataDirs = (env.XDG_DATA_DIRS || "/usr/local/share/:/usr/share/").split(":"), exports2.data && exports2.dataDirs.unshift(exports2.data), exports2.configDirs = (env.XDG_CONFIG_DIRS || "/etc/xdg").split(":"), exports2.config && exports2.configDirs.unshift(exports2.config);
  }(xdgBasedir$1)), xdgBasedir$1;
}
var xdgBasedirExports = requireXdgBasedir(), xdgBasedir = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(xdgBasedirExports), registryUrl = { exports: {} }, utils$3 = {}, ini$1 = {}, hasRequiredIni$1;
function requireIni$1() {
  if (hasRequiredIni$1) return ini$1;
  hasRequiredIni$1 = 1, ini$1.parse = ini$1.decode = decode, ini$1.stringify = ini$1.encode = encode, ini$1.safe = safe, ini$1.unsafe = unsafe;
  var eol = typeof process < "u" && process.platform === "win32" ? `\r
` : `
`;
  function encode(obj, opt) {
    var children = [], out = "";
    typeof opt == "string" ? opt = {
      section: opt,
      whitespace: !1
    } : (opt = opt || {}, opt.whitespace = opt.whitespace === !0);
    var separator2 = opt.whitespace ? " = " : "=";
    return Object.keys(obj).forEach(function(k, _, __) {
      var val = obj[k];
      val && Array.isArray(val) ? val.forEach(function(item) {
        out += safe(k + "[]") + separator2 + safe(item) + `
`;
      }) : val && typeof val == "object" ? children.push(k) : out += safe(k) + separator2 + safe(val) + eol;
    }), opt.section && out.length && (out = "[" + safe(opt.section) + "]" + eol + out), children.forEach(function(k, _, __) {
      var nk = dotSplit(k).join("\\."), section = (opt.section ? opt.section + "." : "") + nk, child = encode(obj[k], {
        section,
        whitespace: opt.whitespace
      });
      out.length && child.length && (out += eol), out += child;
    }), out;
  }
  function dotSplit(str2) {
    return str2.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
      return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
    });
  }
  function decode(str2) {
    var out = {}, p = out, section = null, re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i, lines2 = str2.split(/[\r\n]+/g);
    return lines2.forEach(function(line3, _, __) {
      if (!(!line3 || line3.match(/^\s*[;#]/))) {
        var match2 = line3.match(re);
        if (match2) {
          if (match2[1] !== void 0) {
            if (section = unsafe(match2[1]), section === "__proto__") {
              p = {};
              return;
            }
            p = out[section] = out[section] || {};
            return;
          }
          var key2 = unsafe(match2[2]);
          if (key2 !== "__proto__") {
            var value = match2[3] ? unsafe(match2[4]) : !0;
            switch (value) {
              case "true":
              case "false":
              case "null":
                value = JSON.parse(value);
            }
            if (key2.length > 2 && key2.slice(-2) === "[]") {
              if (key2 = key2.substring(0, key2.length - 2), key2 === "__proto__")
                return;
              p[key2] ? Array.isArray(p[key2]) || (p[key2] = [p[key2]]) : p[key2] = [];
            }
            Array.isArray(p[key2]) ? p[key2].push(value) : p[key2] = value;
          }
        }
      }
    }), Object.keys(out).filter(function(k, _, __) {
      if (!out[k] || typeof out[k] != "object" || Array.isArray(out[k]))
        return !1;
      var parts = dotSplit(k), p2 = out, l = parts.pop(), nl = l.replace(/\\\./g, ".");
      return parts.forEach(function(part, _2, __2) {
        part !== "__proto__" && ((!p2[part] || typeof p2[part] != "object") && (p2[part] = {}), p2 = p2[part]);
      }), p2 === out && nl === l ? !1 : (p2[nl] = out[k], !0);
    }).forEach(function(del, _, __) {
      delete out[del];
    }), out;
  }
  function isQuoted(val) {
    return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
  }
  function safe(val) {
    return typeof val != "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
  }
  function unsafe(val, doUnesc) {
    if (val = (val || "").trim(), isQuoted(val)) {
      val.charAt(0) === "'" && (val = val.substr(1, val.length - 2));
      try {
        val = JSON.parse(val);
      } catch {
      }
    } else {
      for (var esc = !1, unesc = "", i = 0, l = val.length; i < l; i++) {
        var c2 = val.charAt(i);
        if (esc)
          "\\;#".indexOf(c2) !== -1 ? unesc += c2 : unesc += "\\" + c2, esc = !1;
        else {
          if (";#".indexOf(c2) !== -1)
            break;
          c2 === "\\" ? esc = !0 : unesc += c2;
        }
      }
      return esc && (unesc += "\\"), unesc.trim();
    }
    return val;
  }
  return ini$1;
}
var stripJsonComments, hasRequiredStripJsonComments;
function requireStripJsonComments() {
  if (hasRequiredStripJsonComments) return stripJsonComments;
  hasRequiredStripJsonComments = 1;
  var singleComment = 1, multiComment = 2;
  function stripWithoutWhitespace() {
    return "";
  }
  function stripWithWhitespace(str2, start, end) {
    return str2.slice(start, end).replace(/\S/g, " ");
  }
  return stripJsonComments = function(str2, opts) {
    opts = opts || {};
    for (var currentChar, nextChar, insideString = !1, insideComment = !1, offset = 0, ret = "", strip = opts.whitespace === !1 ? stripWithoutWhitespace : stripWithWhitespace, i = 0; i < str2.length; i++) {
      if (currentChar = str2[i], nextChar = str2[i + 1], !insideComment && currentChar === '"') {
        var escaped = str2[i - 1] === "\\" && str2[i - 2] !== "\\";
        escaped || (insideString = !insideString);
      }
      if (!insideString) {
        if (!insideComment && currentChar + nextChar === "//")
          ret += str2.slice(offset, i), offset = i, insideComment = singleComment, i++;
        else if (insideComment === singleComment && currentChar + nextChar === `\r
`) {
          i++, insideComment = !1, ret += strip(str2, offset, i), offset = i;
          continue;
        } else if (insideComment === singleComment && currentChar === `
`)
          insideComment = !1, ret += strip(str2, offset, i), offset = i;
        else if (!insideComment && currentChar + nextChar === "/*") {
          ret += str2.slice(offset, i), offset = i, insideComment = multiComment, i++;
          continue;
        } else if (insideComment === multiComment && currentChar + nextChar === "*/") {
          i++, insideComment = !1, ret += strip(str2, offset, i + 1), offset = i + 1;
          continue;
        }
      }
    }
    return ret + (insideComment ? strip(str2.substr(offset)) : str2.substr(offset));
  }, stripJsonComments;
}
var hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$3;
  hasRequiredUtils$3 = 1;
  var fs2 = require$$0__default.default, ini2 = requireIni$1(), path2 = require$$0__default$1.default, stripJsonComments2 = requireStripJsonComments(), parse3 = utils$3.parse = function(content) {
    return /^\s*{/.test(content) ? JSON.parse(stripJsonComments2(content)) : ini2.parse(content);
  }, file = utils$3.file = function() {
    var args = [].slice.call(arguments).filter(function(arg) {
      return arg != null;
    });
    for (var i in args)
      if (typeof args[i] != "string")
        return;
    var file2 = path2.join.apply(null, args);
    try {
      return fs2.readFileSync(file2, "utf-8");
    } catch {
      return;
    }
  };
  return utils$3.json = function() {
    var content = file.apply(null, arguments);
    return content ? parse3(content) : null;
  }, utils$3.env = function(prefix, env) {
    env = env || process.env;
    var obj = {}, l = prefix.length;
    for (var k in env)
      if (k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {
        for (var keypath = k.substring(l).split("__"), _emptyStringIndex; (_emptyStringIndex = keypath.indexOf("")) > -1; )
          keypath.splice(_emptyStringIndex, 1);
        var cursor = obj;
        keypath.forEach(function(_subkey, i) {
          !_subkey || typeof cursor != "object" || (i === keypath.length - 1 && (cursor[_subkey] = env[k]), cursor[_subkey] === void 0 && (cursor[_subkey] = {}), cursor = cursor[_subkey]);
        });
      }
    return obj;
  }, utils$3.find = function() {
    var rel = path2.join.apply(null, [].slice.call(arguments));
    function find2(start, rel2) {
      var file2 = path2.join(start, rel2);
      try {
        return fs2.statSync(file2), file2;
      } catch {
        if (path2.dirname(start) !== start)
          return find2(path2.dirname(start), rel2);
      }
    }
    return find2(process.cwd(), rel);
  }, utils$3;
}
var deepExtend = { exports: {} };
/*!
 * @description Recursive object extending
 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var hasRequiredDeepExtend;
function requireDeepExtend() {
  if (hasRequiredDeepExtend) return deepExtend.exports;
  hasRequiredDeepExtend = 1;
  function isSpecificValue(val) {
    return val instanceof Buffer || val instanceof Date || val instanceof RegExp;
  }
  function cloneSpecificValue(val) {
    if (val instanceof Buffer) {
      var x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
      return val.copy(x), x;
    } else {
      if (val instanceof Date)
        return new Date(val.getTime());
      if (val instanceof RegExp)
        return new RegExp(val);
      throw new Error("Unexpected situation");
    }
  }
  function deepCloneArray(arr) {
    var clone = [];
    return arr.forEach(function(item, index) {
      typeof item == "object" && item !== null ? Array.isArray(item) ? clone[index] = deepCloneArray(item) : isSpecificValue(item) ? clone[index] = cloneSpecificValue(item) : clone[index] = deepExtend$1({}, item) : clone[index] = item;
    }), clone;
  }
  function safeGetProperty(object, property) {
    return property === "__proto__" ? void 0 : object[property];
  }
  var deepExtend$1 = deepExtend.exports = function() {
    if (arguments.length < 1 || typeof arguments[0] != "object")
      return !1;
    if (arguments.length < 2)
      return arguments[0];
    var target = arguments[0], args = Array.prototype.slice.call(arguments, 1), val, src2;
    return args.forEach(function(obj) {
      typeof obj != "object" || obj === null || Array.isArray(obj) || Object.keys(obj).forEach(function(key2) {
        if (src2 = safeGetProperty(target, key2), val = safeGetProperty(obj, key2), val !== target)
          if (typeof val != "object" || val === null) {
            target[key2] = val;
            return;
          } else if (Array.isArray(val)) {
            target[key2] = deepCloneArray(val);
            return;
          } else if (isSpecificValue(val)) {
            target[key2] = cloneSpecificValue(val);
            return;
          } else if (typeof src2 != "object" || src2 === null || Array.isArray(src2)) {
            target[key2] = deepExtend$1({}, val);
            return;
          } else {
            target[key2] = deepExtend$1(src2, val);
            return;
          }
      });
    }), target;
  };
  return deepExtend.exports;
}
var minimist$1, hasRequiredMinimist;
function requireMinimist() {
  if (hasRequiredMinimist) return minimist$1;
  hasRequiredMinimist = 1;
  function hasKey2(obj, keys) {
    var o = obj;
    keys.slice(0, -1).forEach(function(key3) {
      o = o[key3] || {};
    });
    var key2 = keys[keys.length - 1];
    return key2 in o;
  }
  function isNumber2(x) {
    return typeof x == "number" || /^0x[0-9a-f]+$/i.test(x) ? !0 : /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
  }
  function isConstructorOrProto(obj, key2) {
    return key2 === "constructor" && typeof obj[key2] == "function" || key2 === "__proto__";
  }
  return minimist$1 = function(args, opts) {
    opts || (opts = {});
    var flags = {
      bools: {},
      strings: {},
      unknownFn: null
    };
    typeof opts.unknown == "function" && (flags.unknownFn = opts.unknown), typeof opts.boolean == "boolean" && opts.boolean ? flags.allBools = !0 : [].concat(opts.boolean).filter(Boolean).forEach(function(key3) {
      flags.bools[key3] = !0;
    });
    var aliases = {};
    function aliasIsBoolean(key3) {
      return aliases[key3].some(function(x) {
        return flags.bools[x];
      });
    }
    Object.keys(opts.alias || {}).forEach(function(key3) {
      aliases[key3] = [].concat(opts.alias[key3]), aliases[key3].forEach(function(x) {
        aliases[x] = [key3].concat(aliases[key3].filter(function(y) {
          return x !== y;
        }));
      });
    }), [].concat(opts.string).filter(Boolean).forEach(function(key3) {
      flags.strings[key3] = !0, aliases[key3] && [].concat(aliases[key3]).forEach(function(k) {
        flags.strings[k] = !0;
      });
    });
    var defaults2 = opts.default || {}, argv = { _: [] };
    function argDefined(key3, arg2) {
      return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key3] || flags.bools[key3] || aliases[key3];
    }
    function setKey(obj, keys, value2) {
      for (var o = obj, i2 = 0; i2 < keys.length - 1; i2++) {
        var key3 = keys[i2];
        if (isConstructorOrProto(o, key3))
          return;
        o[key3] === void 0 && (o[key3] = {}), (o[key3] === Object.prototype || o[key3] === Number.prototype || o[key3] === String.prototype) && (o[key3] = {}), o[key3] === Array.prototype && (o[key3] = []), o = o[key3];
      }
      var lastKey = keys[keys.length - 1];
      isConstructorOrProto(o, lastKey) || ((o === Object.prototype || o === Number.prototype || o === String.prototype) && (o = {}), o === Array.prototype && (o = []), o[lastKey] === void 0 || flags.bools[lastKey] || typeof o[lastKey] == "boolean" ? o[lastKey] = value2 : Array.isArray(o[lastKey]) ? o[lastKey].push(value2) : o[lastKey] = [o[lastKey], value2]);
    }
    function setArg(key3, val, arg2) {
      if (!(arg2 && flags.unknownFn && !argDefined(key3, arg2) && flags.unknownFn(arg2) === !1)) {
        var value2 = !flags.strings[key3] && isNumber2(val) ? Number(val) : val;
        setKey(argv, key3.split("."), value2), (aliases[key3] || []).forEach(function(x) {
          setKey(argv, x.split("."), value2);
        });
      }
    }
    Object.keys(flags.bools).forEach(function(key3) {
      setArg(key3, defaults2[key3] === void 0 ? !1 : defaults2[key3]);
    });
    var notFlags = [];
    args.indexOf("--") !== -1 && (notFlags = args.slice(args.indexOf("--") + 1), args = args.slice(0, args.indexOf("--")));
    for (var i = 0; i < args.length; i++) {
      var arg = args[i], key2, next;
      if (/^--.+=/.test(arg)) {
        var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
        key2 = m[1];
        var value = m[2];
        flags.bools[key2] && (value = value !== "false"), setArg(key2, value, arg);
      } else if (/^--no-.+/.test(arg))
        key2 = arg.match(/^--no-(.+)/)[1], setArg(key2, !1, arg);
      else if (/^--.+/.test(arg))
        key2 = arg.match(/^--(.+)/)[1], next = args[i + 1], next !== void 0 && !/^(-|--)[^-]/.test(next) && !flags.bools[key2] && !flags.allBools && (!aliases[key2] || !aliasIsBoolean(key2)) ? (setArg(key2, next, arg), i += 1) : /^(true|false)$/.test(next) ? (setArg(key2, next === "true", arg), i += 1) : setArg(key2, flags.strings[key2] ? "" : !0, arg);
      else if (/^-[^-]+/.test(arg)) {
        for (var letters = arg.slice(1, -1).split(""), broken = !1, j = 0; j < letters.length; j++) {
          if (next = arg.slice(j + 2), next === "-") {
            setArg(letters[j], next, arg);
            continue;
          }
          if (/[A-Za-z]/.test(letters[j]) && next[0] === "=") {
            setArg(letters[j], next.slice(1), arg), broken = !0;
            break;
          }
          if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
            setArg(letters[j], next, arg), broken = !0;
            break;
          }
          if (letters[j + 1] && letters[j + 1].match(/\W/)) {
            setArg(letters[j], arg.slice(j + 2), arg), broken = !0;
            break;
          } else
            setArg(letters[j], flags.strings[letters[j]] ? "" : !0, arg);
        }
        key2 = arg.slice(-1)[0], !broken && key2 !== "-" && (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key2] && (!aliases[key2] || !aliasIsBoolean(key2)) ? (setArg(key2, args[i + 1], arg), i += 1) : args[i + 1] && /^(true|false)$/.test(args[i + 1]) ? (setArg(key2, args[i + 1] === "true", arg), i += 1) : setArg(key2, flags.strings[key2] ? "" : !0, arg));
      } else if ((!flags.unknownFn || flags.unknownFn(arg) !== !1) && argv._.push(flags.strings._ || !isNumber2(arg) ? arg : Number(arg)), opts.stopEarly) {
        argv._.push.apply(argv._, args.slice(i + 1));
        break;
      }
    }
    return Object.keys(defaults2).forEach(function(k) {
      hasKey2(argv, k.split(".")) || (setKey(argv, k.split("."), defaults2[k]), (aliases[k] || []).forEach(function(x) {
        setKey(argv, x.split("."), defaults2[k]);
      }));
    }), opts["--"] ? argv["--"] = notFlags.slice() : notFlags.forEach(function(k) {
      argv._.push(k);
    }), argv;
  }, minimist$1;
}
var rc, hasRequiredRc;
function requireRc() {
  if (hasRequiredRc) return rc;
  hasRequiredRc = 1;
  var cc = requireUtils$3(), join = require$$0__default$1.default.join, deepExtend2 = requireDeepExtend(), etc = "/etc", win = process.platform === "win32", home = win ? process.env.USERPROFILE : process.env.HOME;
  return rc = function(name, defaults2, argv, parse3) {
    if (typeof name != "string")
      throw new Error("rc(name): name *must* be string");
    argv || (argv = requireMinimist()(process.argv.slice(2))), defaults2 = (typeof defaults2 == "string" ? cc.json(defaults2) : defaults2) || {}, parse3 = parse3 || cc.parse;
    var env = cc.env(name + "_"), configs = [defaults2], configFiles = [];
    function addConfigFile(file) {
      if (!(configFiles.indexOf(file) >= 0)) {
        var fileConfig = cc.file(file);
        fileConfig && (configs.push(parse3(fileConfig)), configFiles.push(file));
      }
    }
    return win || [
      join(etc, name, "config"),
      join(etc, name + "rc")
    ].forEach(addConfigFile), home && [
      join(home, ".config", name, "config"),
      join(home, ".config", name),
      join(home, "." + name, "config"),
      join(home, "." + name + "rc")
    ].forEach(addConfigFile), addConfigFile(cc.find("." + name + "rc")), env.config && addConfigFile(env.config), argv.config && addConfigFile(argv.config), deepExtend2.apply(null, configs.concat([
      env,
      argv,
      configFiles.length ? { configs: configFiles, config: configFiles[configFiles.length - 1] } : void 0
    ]));
  }, rc;
}
var hasRequiredRegistryUrl;
function requireRegistryUrl() {
  if (hasRequiredRegistryUrl) return registryUrl.exports;
  hasRequiredRegistryUrl = 1;
  const rc2 = requireRc(), registryUrl$1 = (scope2) => {
    const result = rc2("npm", { registry: "https://registry.npmjs.org/" }), url = result[`${scope2}:registry`] || result.config_registry || result.registry;
    return url.slice(-1) === "/" ? url : `${url}/`;
  };
  return registryUrl.exports = registryUrl$1, registryUrl.exports.default = registryUrl$1, registryUrl.exports;
}
var npmConf = { exports: {} }, dist$4 = {}, caFile = {}, polyfills$1, hasRequiredPolyfills$1;
function requirePolyfills$1() {
  if (hasRequiredPolyfills$1) return polyfills$1;
  hasRequiredPolyfills$1 = 1;
  var constants2 = require$$0__default$3.default, origCwd = process.cwd, cwd = null, platform2 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    return cwd || (cwd = origCwd.call(process)), cwd;
  };
  try {
    process.cwd();
  } catch {
  }
  if (typeof process.chdir == "function") {
    var chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null, chdir.call(process, d);
    }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, chdir);
  }
  polyfills$1 = patch;
  function patch(fs2) {
    constants2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && patchLchmod(fs2), fs2.lutimes || patchLutimes(fs2), fs2.chown = chownFix(fs2.chown), fs2.fchown = chownFix(fs2.fchown), fs2.lchown = chownFix(fs2.lchown), fs2.chmod = chmodFix(fs2.chmod), fs2.fchmod = chmodFix(fs2.fchmod), fs2.lchmod = chmodFix(fs2.lchmod), fs2.chownSync = chownFixSync(fs2.chownSync), fs2.fchownSync = chownFixSync(fs2.fchownSync), fs2.lchownSync = chownFixSync(fs2.lchownSync), fs2.chmodSync = chmodFixSync(fs2.chmodSync), fs2.fchmodSync = chmodFixSync(fs2.fchmodSync), fs2.lchmodSync = chmodFixSync(fs2.lchmodSync), fs2.stat = statFix(fs2.stat), fs2.fstat = statFix(fs2.fstat), fs2.lstat = statFix(fs2.lstat), fs2.statSync = statFixSync(fs2.statSync), fs2.fstatSync = statFixSync(fs2.fstatSync), fs2.lstatSync = statFixSync(fs2.lstatSync), fs2.chmod && !fs2.lchmod && (fs2.lchmod = function(path2, mode2, cb) {
      cb && process.nextTick(cb);
    }, fs2.lchmodSync = function() {
    }), fs2.chown && !fs2.lchown && (fs2.lchown = function(path2, uid, gid, cb) {
      cb && process.nextTick(cb);
    }, fs2.lchownSync = function() {
    }), platform2 === "win32" && (fs2.rename = typeof fs2.rename != "function" ? fs2.rename : function(fs$rename) {
      function rename2(from2, to, cb) {
        var start = Date.now(), backoff = 0;
        fs$rename(from2, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
            setTimeout(function() {
              fs2.stat(to, function(stater, st) {
                stater && stater.code === "ENOENT" ? fs$rename(from2, to, CB) : cb(er);
              });
            }, backoff), backoff < 100 && (backoff += 10);
            return;
          }
          cb && cb(er);
        });
      }
      return Object.setPrototypeOf && Object.setPrototypeOf(rename2, fs$rename), rename2;
    }(fs2.rename)), fs2.read = typeof fs2.read != "function" ? fs2.read : function(fs$read) {
      function read2(fd, buffer2, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ == "function") {
          var eagCounter = 0;
          callback = function(er, _, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10)
              return eagCounter++, fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
      }
      return Object.setPrototypeOf && Object.setPrototypeOf(read2, fs$read), read2;
    }(fs2.read), fs2.readSync = typeof fs2.readSync != "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
      return function(fd, buffer2, offset, length, position) {
        for (var eagCounter = 0; ; )
          try {
            return fs$readSync.call(fs2, fd, buffer2, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
      };
    }(fs2.readSync);
    function patchLchmod(fs3) {
      fs3.lchmod = function(path2, mode2, callback) {
        fs3.open(
          path2,
          constants2.O_WRONLY | constants2.O_SYMLINK,
          mode2,
          function(err, fd) {
            if (err) {
              callback && callback(err);
              return;
            }
            fs3.fchmod(fd, mode2, function(err2) {
              fs3.close(fd, function(err22) {
                callback && callback(err2 || err22);
              });
            });
          }
        );
      }, fs3.lchmodSync = function(path2, mode2) {
        var fd = fs3.openSync(path2, constants2.O_WRONLY | constants2.O_SYMLINK, mode2), threw = !0, ret;
        try {
          ret = fs3.fchmodSync(fd, mode2), threw = !1;
        } finally {
          if (threw)
            try {
              fs3.closeSync(fd);
            } catch {
            }
          else
            fs3.closeSync(fd);
        }
        return ret;
      };
    }
    function patchLutimes(fs3) {
      constants2.hasOwnProperty("O_SYMLINK") && fs3.futimes ? (fs3.lutimes = function(path2, at, mt, cb) {
        fs3.open(path2, constants2.O_SYMLINK, function(er, fd) {
          if (er) {
            cb && cb(er);
            return;
          }
          fs3.futimes(fd, at, mt, function(er2) {
            fs3.close(fd, function(er22) {
              cb && cb(er2 || er22);
            });
          });
        });
      }, fs3.lutimesSync = function(path2, at, mt) {
        var fd = fs3.openSync(path2, constants2.O_SYMLINK), ret, threw = !0;
        try {
          ret = fs3.futimesSync(fd, at, mt), threw = !1;
        } finally {
          if (threw)
            try {
              fs3.closeSync(fd);
            } catch {
            }
          else
            fs3.closeSync(fd);
        }
        return ret;
      }) : fs3.futimes && (fs3.lutimes = function(_a, _b, _c, cb) {
        cb && process.nextTick(cb);
      }, fs3.lutimesSync = function() {
      });
    }
    function chmodFix(orig) {
      return orig && function(target, mode2, cb) {
        return orig.call(fs2, target, mode2, function(er) {
          chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      return orig && function(target, mode2) {
        try {
          return orig.call(fs2, target, mode2);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function chownFix(orig) {
      return orig && function(target, uid, gid, cb) {
        return orig.call(fs2, target, uid, gid, function(er) {
          chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      return orig && function(target, uid, gid) {
        try {
          return orig.call(fs2, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function statFix(orig) {
      return orig && function(target, options2, cb) {
        typeof options2 == "function" && (cb = options2, options2 = null);
        function callback(er, stats) {
          stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), cb && cb.apply(this, arguments);
        }
        return options2 ? orig.call(fs2, target, options2, callback) : orig.call(fs2, target, callback);
      };
    }
    function statFixSync(orig) {
      return orig && function(target, options2) {
        var stats = options2 ? orig.call(fs2, target, options2) : orig.call(fs2, target);
        return stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), stats;
      };
    }
    function chownErOk(er) {
      if (!er || er.code === "ENOSYS")
        return !0;
      var nonroot = !process.getuid || process.getuid() !== 0;
      return !!(nonroot && (er.code === "EINVAL" || er.code === "EPERM"));
    }
  }
  return polyfills$1;
}
var legacyStreams$1, hasRequiredLegacyStreams$1;
function requireLegacyStreams$1() {
  if (hasRequiredLegacyStreams$1) return legacyStreams$1;
  hasRequiredLegacyStreams$1 = 1;
  var Stream2 = require$$0__default$4.default.Stream;
  legacyStreams$1 = legacy;
  function legacy(fs2) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path2, options2) {
      if (!(this instanceof ReadStream)) return new ReadStream(path2, options2);
      Stream2.call(this);
      var self2 = this;
      this.path = path2, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, options2 = options2 || {};
      for (var keys = Object.keys(options2), index = 0, length = keys.length; index < length; index++) {
        var key2 = keys[index];
        this[key2] = options2[key2];
      }
      if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.end === void 0)
          this.end = 1 / 0;
        else if (typeof this.end != "number")
          throw TypeError("end must be a Number");
        if (this.start > this.end)
          throw new Error("start must be <= end");
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs2.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err), self2.readable = !1;
          return;
        }
        self2.fd = fd, self2.emit("open", fd), self2._read();
      });
    }
    function WriteStream(path2, options2) {
      if (!(this instanceof WriteStream)) return new WriteStream(path2, options2);
      Stream2.call(this), this.path = path2, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, options2 = options2 || {};
      for (var keys = Object.keys(options2), index = 0, length = keys.length; index < length; index++) {
        var key2 = keys[index];
        this[key2] = options2[key2];
      }
      if (this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.start < 0)
          throw new Error("start must be >= zero");
        this.pos = this.start;
      }
      this.busy = !1, this._queue = [], this.fd === null && (this._open = fs2.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
    }
  }
  return legacyStreams$1;
}
var clone_1$1, hasRequiredClone$1;
function requireClone$1() {
  if (hasRequiredClone$1) return clone_1$1;
  hasRequiredClone$1 = 1, clone_1$1 = clone;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj != "object")
      return obj;
    if (obj instanceof Object)
      var copy2 = { __proto__: getPrototypeOf(obj) };
    else
      var copy2 = /* @__PURE__ */ Object.create(null);
    return Object.getOwnPropertyNames(obj).forEach(function(key2) {
      Object.defineProperty(copy2, key2, Object.getOwnPropertyDescriptor(obj, key2));
    }), copy2;
  }
  return clone_1$1;
}
var gracefulFs$1, hasRequiredGracefulFs$1;
function requireGracefulFs$1() {
  if (hasRequiredGracefulFs$1) return gracefulFs$1;
  hasRequiredGracefulFs$1 = 1;
  var fs2 = require$$0__default.default, polyfills2 = requirePolyfills$1(), legacy = requireLegacyStreams$1(), clone = requireClone$1(), util2 = require$$0__default$5.default, gracefulQueue, previousSymbol;
  typeof Symbol == "function" && typeof Symbol.for == "function" ? (gracefulQueue = Symbol.for("graceful-fs.queue"), previousSymbol = Symbol.for("graceful-fs.previous")) : (gracefulQueue = "___graceful-fs.queue", previousSymbol = "___graceful-fs.previous");
  function noop2() {
  }
  function publishQueue(context, queue3) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue3;
      }
    });
  }
  var debug2 = noop2;
  if (util2.debuglog ? debug2 = util2.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (debug2 = function() {
    var m = util2.format.apply(util2, arguments);
    m = "GFS4: " + m.split(/\n/).join(`
GFS4: `), console.error(m);
  }), !fs2[gracefulQueue]) {
    var queue2 = loadEnv.commonjsGlobal[gracefulQueue] || [];
    publishQueue(fs2, queue2), fs2.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs2, fd, function(err) {
          err || resetQueue(), typeof cb == "function" && cb.apply(this, arguments);
        });
      }
      return Object.defineProperty(close, previousSymbol, {
        value: fs$close
      }), close;
    }(fs2.close), fs2.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs2, arguments), resetQueue();
      }
      return Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      }), closeSync;
    }(fs2.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
      debug2(fs2[gracefulQueue]), require$$0__default$6.default.equal(fs2[gracefulQueue].length, 0);
    });
  }
  loadEnv.commonjsGlobal[gracefulQueue] || publishQueue(loadEnv.commonjsGlobal, fs2[gracefulQueue]), gracefulFs$1 = patch(clone(fs2)), process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched && (gracefulFs$1 = patch(fs2), fs2.__patched = !0);
  function patch(fs3) {
    polyfills2(fs3), fs3.gracefulify = patch, fs3.createReadStream = createReadStream, fs3.createWriteStream = createWriteStream;
    var fs$readFile = fs3.readFile;
    fs3.readFile = readFile;
    function readFile(path2, options2, cb) {
      return typeof options2 == "function" && (cb = options2, options2 = null), go$readFile(path2, options2, cb);
      function go$readFile(path3, options3, cb2, startTime) {
        return fs$readFile(path3, options3, function(err) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$readFile, [path3, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    var fs$writeFile = fs3.writeFile;
    fs3.writeFile = writeFile;
    function writeFile(path2, data, options2, cb) {
      return typeof options2 == "function" && (cb = options2, options2 = null), go$writeFile(path2, data, options2, cb);
      function go$writeFile(path3, data2, options3, cb2, startTime) {
        return fs$writeFile(path3, data2, options3, function(err) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$writeFile, [path3, data2, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    var fs$appendFile = fs3.appendFile;
    fs$appendFile && (fs3.appendFile = appendFile);
    function appendFile(path2, data, options2, cb) {
      return typeof options2 == "function" && (cb = options2, options2 = null), go$appendFile(path2, data, options2, cb);
      function go$appendFile(path3, data2, options3, cb2, startTime) {
        return fs$appendFile(path3, data2, options3, function(err) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$appendFile, [path3, data2, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    var fs$copyFile = fs3.copyFile;
    fs$copyFile && (fs3.copyFile = copyFile);
    function copyFile(src2, dest, flags, cb) {
      return typeof flags == "function" && (cb = flags, flags = 0), go$copyFile(src2, dest, flags, cb);
      function go$copyFile(src3, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src3, dest2, flags2, function(err) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$copyFile, [src3, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    var fs$readdir = fs3.readdir;
    fs3.readdir = readdir2;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir2(path2, options2, cb) {
      typeof options2 == "function" && (cb = options2, options2 = null);
      var go$readdir = noReaddirOptionVersions.test(process.version) ? function(path3, options3, cb2, startTime) {
        return fs$readdir(path3, fs$readdirCallback(
          path3,
          options3,
          cb2,
          startTime
        ));
      } : function(path3, options3, cb2, startTime) {
        return fs$readdir(path3, options3, fs$readdirCallback(
          path3,
          options3,
          cb2,
          startTime
        ));
      };
      return go$readdir(path2, options2, cb);
      function fs$readdirCallback(path3, options3, cb2, startTime) {
        return function(err, files) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([
            go$readdir,
            [path3, options3, cb2],
            err,
            startTime || Date.now(),
            Date.now()
          ]) : (files && files.sort && files.sort(), typeof cb2 == "function" && cb2.call(this, err, files));
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs3);
      ReadStream = legStreams.ReadStream, WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs3.ReadStream;
    fs$ReadStream && (ReadStream.prototype = Object.create(fs$ReadStream.prototype), ReadStream.prototype.open = ReadStream$open);
    var fs$WriteStream = fs3.WriteStream;
    fs$WriteStream && (WriteStream.prototype = Object.create(fs$WriteStream.prototype), WriteStream.prototype.open = WriteStream$open), Object.defineProperty(fs3, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(fs3, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs3, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs3, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    function ReadStream(path2, options2) {
      return this instanceof ReadStream ? (fs$ReadStream.apply(this, arguments), this) : ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open2(that.path, that.flags, that.mode, function(err, fd) {
        err ? (that.autoClose && that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd), that.read());
      });
    }
    function WriteStream(path2, options2) {
      return this instanceof WriteStream ? (fs$WriteStream.apply(this, arguments), this) : WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open2(that.path, that.flags, that.mode, function(err, fd) {
        err ? (that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd));
      });
    }
    function createReadStream(path2, options2) {
      return new fs3.ReadStream(path2, options2);
    }
    function createWriteStream(path2, options2) {
      return new fs3.WriteStream(path2, options2);
    }
    var fs$open = fs3.open;
    fs3.open = open2;
    function open2(path2, flags, mode2, cb) {
      return typeof mode2 == "function" && (cb = mode2, mode2 = null), go$open(path2, flags, mode2, cb);
      function go$open(path3, flags2, mode3, cb2, startTime) {
        return fs$open(path3, flags2, mode3, function(err, fd) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$open, [path3, flags2, mode3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    return fs3;
  }
  function enqueue(elem) {
    debug2("ENQUEUE", elem[0].name, elem[1]), fs2[gracefulQueue].push(elem), retry2();
  }
  var retryTimer;
  function resetQueue() {
    for (var now = Date.now(), i = 0; i < fs2[gracefulQueue].length; ++i)
      fs2[gracefulQueue][i].length > 2 && (fs2[gracefulQueue][i][3] = now, fs2[gracefulQueue][i][4] = now);
    retry2();
  }
  function retry2() {
    if (clearTimeout(retryTimer), retryTimer = void 0, fs2[gracefulQueue].length !== 0) {
      var elem = fs2[gracefulQueue].shift(), fn = elem[0], args = elem[1], err = elem[2], startTime = elem[3], lastTime = elem[4];
      if (startTime === void 0)
        debug2("RETRY", fn.name, args), fn.apply(null, args);
      else if (Date.now() - startTime >= 6e4) {
        debug2("TIMEOUT", fn.name, args);
        var cb = args.pop();
        typeof cb == "function" && cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime, sinceStart = Math.max(lastTime - startTime, 1), desiredDelay = Math.min(sinceStart * 1.2, 100);
        sinceAttempt >= desiredDelay ? (debug2("RETRY", fn.name, args), fn.apply(null, args.concat([startTime]))) : fs2[gracefulQueue].push(elem);
      }
      retryTimer === void 0 && (retryTimer = setTimeout(retry2, 0));
    }
  }
  return gracefulFs$1;
}
var hasRequiredCaFile;
function requireCaFile() {
  if (hasRequiredCaFile) return caFile;
  hasRequiredCaFile = 1;
  var __importDefault2 = caFile && caFile.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(caFile, "__esModule", { value: !0 }), caFile.readCAFileSync = void 0;
  const graceful_fs_1 = __importDefault2(requireGracefulFs$1());
  function readCAFileSync(filePath) {
    try {
      const contents = graceful_fs_1.default.readFileSync(filePath, "utf8"), delim = "-----END CERTIFICATE-----";
      return contents.split(delim).filter((ca) => !!ca.trim()).map((ca) => `${ca.trimLeft()}${delim}`);
    } catch (err) {
      if (err.code === "ENOENT")
        return;
      throw err;
    }
  }
  return caFile.readCAFileSync = readCAFileSync, caFile;
}
var hasRequiredDist$3;
function requireDist$3() {
  return hasRequiredDist$3 || (hasRequiredDist$3 = 1, function(exports2) {
    var __createBinding2 = dist$4 && dist$4.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar2 = dist$4 && dist$4.__exportStar || function(m, exports3) {
      for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p) && __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 }), __exportStar2(requireCaFile(), exports2);
  }(dist$4)), dist$4;
}
var configChain = { exports: {} }, protoList, hasRequiredProtoList;
function requireProtoList() {
  if (hasRequiredProtoList) return protoList;
  hasRequiredProtoList = 1, protoList = ProtoList;
  function setProto(obj, proto) {
    if (typeof Object.setPrototypeOf == "function")
      return Object.setPrototypeOf(obj, proto);
    obj.__proto__ = proto;
  }
  function ProtoList() {
    this.list = [];
    var root2 = null;
    Object.defineProperty(this, "root", {
      get: function() {
        return root2;
      },
      set: function(r) {
        root2 = r, this.list.length && setProto(this.list[this.list.length - 1], r);
      },
      enumerable: !0,
      configurable: !0
    });
  }
  return ProtoList.prototype = {
    get length() {
      return this.list.length;
    },
    get keys() {
      var k = [];
      for (var i in this.list[0]) k.push(i);
      return k;
    },
    get snapshot() {
      var o = {};
      return this.keys.forEach(function(k) {
        o[k] = this.get(k);
      }, this), o;
    },
    get store() {
      return this.list[0];
    },
    push: function(obj) {
      return typeof obj != "object" && (obj = { valueOf: obj }), this.list.length >= 1 && setProto(this.list[this.list.length - 1], obj), setProto(obj, this.root), this.list.push(obj);
    },
    pop: function() {
      return this.list.length >= 2 && setProto(this.list[this.list.length - 2], this.root), this.list.pop();
    },
    unshift: function(obj) {
      return setProto(obj, this.list[0] || this.root), this.list.unshift(obj);
    },
    shift: function() {
      return this.list.length === 1 && setProto(this.list[0], this.root), this.list.shift();
    },
    get: function(key2) {
      return this.list[0][key2];
    },
    set: function(key2, val, save) {
      return this.length || this.push({}), save && this.list[0].hasOwnProperty(key2) && this.push({}), this.list[0][key2] = val;
    },
    forEach: function(fn, thisp) {
      for (var key2 in this.list[0]) fn.call(thisp, key2, this.list[0][key2]);
    },
    slice: function() {
      return this.list.slice.apply(this.list, arguments);
    },
    splice: function() {
      for (var ret = this.list.splice.apply(this.list, arguments), i = 0, l = this.list.length; i < l; i++)
        setProto(this.list[i], this.list[i + 1] || this.root);
      return ret;
    }
  }, protoList;
}
var hasRequiredConfigChain;
function requireConfigChain() {
  if (hasRequiredConfigChain) return configChain.exports;
  hasRequiredConfigChain = 1;
  var ProtoList = requireProtoList(), path2 = require$$0__default$1.default, fs2 = require$$0__default.default, ini2 = requireIni$1(), EE = require$$0__default$7.default.EventEmitter, url = require$$5__default.default, http2 = require$$6__default.default, exports2 = configChain.exports = function() {
    for (var args = [].slice.call(arguments), conf2 = new ConfigChain(); args.length; ) {
      var a = args.shift();
      a && conf2.push(typeof a == "string" ? json2(a) : a);
    }
    return conf2;
  };
  exports2.find = function() {
    var rel = path2.join.apply(null, [].slice.call(arguments));
    function find2(start, rel2) {
      var file = path2.join(start, rel2);
      try {
        return fs2.statSync(file), file;
      } catch {
        if (path2.dirname(start) !== start)
          return find2(path2.dirname(start), rel2);
      }
    }
    return find2(__dirname, rel);
  };
  var parse3 = exports2.parse = function(content, file, type2) {
    if (content = "" + content, type2)
      if (type2 === "json")
        if (this.emit)
          try {
            return JSON.parse(content);
          } catch (er) {
            this.emit("error", er);
          }
        else
          return JSON.parse(content);
      else
        return ini2.parse(content);
    else try {
      return JSON.parse(content);
    } catch {
      return ini2.parse(content);
    }
  }, json2 = exports2.json = function() {
    var args = [].slice.call(arguments).filter(function(arg) {
      return arg != null;
    }), file = path2.join.apply(null, args), content;
    try {
      content = fs2.readFileSync(file, "utf-8");
    } catch {
      return;
    }
    return parse3(content, file, "json");
  };
  exports2.env = function(prefix, env) {
    env = env || process.env;
    var obj = {}, l = prefix.length;
    for (var k in env)
      k.indexOf(prefix) === 0 && (obj[k.substring(l)] = env[k]);
    return obj;
  }, exports2.ConfigChain = ConfigChain;
  function ConfigChain() {
    EE.apply(this), ProtoList.apply(this, arguments), this._awaiting = 0, this._saving = 0, this.sources = {};
  }
  var extras = {
    constructor: { value: ConfigChain }
  };
  return Object.keys(EE.prototype).forEach(function(k) {
    extras[k] = Object.getOwnPropertyDescriptor(EE.prototype, k);
  }), ConfigChain.prototype = Object.create(ProtoList.prototype, extras), ConfigChain.prototype.del = function(key2, where) {
    if (where) {
      var target = this.sources[where];
      if (target = target && target.data, !target)
        return this.emit("error", new Error("not found " + where));
      delete target[key2];
    } else
      for (var i = 0, l = this.list.length; i < l; i++)
        delete this.list[i][key2];
    return this;
  }, ConfigChain.prototype.set = function(key2, value, where) {
    var target;
    if (where) {
      if (target = this.sources[where], target = target && target.data, !target)
        return this.emit("error", new Error("not found " + where));
    } else if (target = this.list[0], !target)
      return this.emit("error", new Error("cannot set, no confs!"));
    return target[key2] = value, this;
  }, ConfigChain.prototype.get = function(key2, where) {
    return where ? (where = this.sources[where], where && (where = where.data), where && Object.hasOwnProperty.call(where, key2) ? where[key2] : void 0) : this.list[0][key2];
  }, ConfigChain.prototype.save = function(where, type2, cb) {
    typeof type2 == "function" && (cb = type2, type2 = null);
    var target = this.sources[where];
    if (!target || !(target.path || target.source) || !target.data)
      return this.emit("error", new Error("bad save target: " + where));
    if (target.source) {
      var pref = target.prefix || "";
      return Object.keys(target.data).forEach(function(k) {
        target.source[pref + k] = target.data[k];
      }), this;
    }
    var type2 = type2 || target.type, data = target.data;
    return target.type === "json" ? data = JSON.stringify(data) : data = ini2.stringify(data), this._saving++, fs2.writeFile(target.path, data, "utf8", function(er) {
      if (this._saving--, er)
        return cb ? cb(er) : this.emit("error", er);
      this._saving === 0 && (cb && cb(), this.emit("save"));
    }.bind(this)), this;
  }, ConfigChain.prototype.addFile = function(file, type2, name) {
    name = name || file;
    var marker = { __source__: name };
    return this.sources[name] = { path: file, type: type2 }, this.push(marker), this._await(), fs2.readFile(file, "utf8", function(er, data) {
      er && this.emit("error", er), this.addString(data, file, type2, marker);
    }.bind(this)), this;
  }, ConfigChain.prototype.addEnv = function(prefix, env, name) {
    name = name || "env";
    var data = exports2.env(prefix, env);
    return this.sources[name] = { data, source: env, prefix }, this.add(data, name);
  }, ConfigChain.prototype.addUrl = function(req, type2, name) {
    this._await();
    var href = url.format(req);
    name = name || href;
    var marker = { __source__: name };
    return this.sources[name] = { href, type: type2 }, this.push(marker), http2.request(req, function(res) {
      var c2 = [], ct = res.headers["content-type"];
      type2 || (type2 = ct.indexOf("json") !== -1 ? "json" : ct.indexOf("ini") !== -1 ? "ini" : href.match(/\.json$/) ? "json" : href.match(/\.ini$/) ? "ini" : null, marker.type = type2), res.on("data", c2.push.bind(c2)).on("end", function() {
        this.addString(Buffer.concat(c2), href, type2, marker);
      }.bind(this)).on("error", this.emit.bind(this, "error"));
    }.bind(this)).on("error", this.emit.bind(this, "error")).end(), this;
  }, ConfigChain.prototype.addString = function(data, file, type2, marker) {
    return data = this.parse(data, file, type2), this.add(data, marker), this;
  }, ConfigChain.prototype.add = function(data, marker) {
    if (marker && typeof marker == "object") {
      var i = this.list.indexOf(marker);
      if (i === -1)
        return this.emit("error", new Error("bad marker"));
      this.splice(i, 1, data), marker = marker.__source__, this.sources[marker] = this.sources[marker] || {}, this.sources[marker].data = data, this._resolve();
    } else
      typeof marker == "string" && (this.sources[marker] = this.sources[marker] || {}, this.sources[marker].data = data), this._await(), this.push(data), process.nextTick(this._resolve.bind(this));
    return this;
  }, ConfigChain.prototype.parse = exports2.parse, ConfigChain.prototype._await = function() {
    this._awaiting++;
  }, ConfigChain.prototype._resolve = function() {
    this._awaiting--, this._awaiting === 0 && this.emit("load", this);
  }, configChain.exports;
}
var envKeyToSetting, hasRequiredEnvKeyToSetting;
function requireEnvKeyToSetting() {
  if (hasRequiredEnvKeyToSetting) return envKeyToSetting;
  hasRequiredEnvKeyToSetting = 1, envKeyToSetting = function(x) {
    const colonIndex = x.indexOf(":");
    if (colonIndex === -1)
      return normalize2(x);
    const firstPart = x.substr(0, colonIndex), secondPart = x.substr(colonIndex + 1);
    return `${normalize2(firstPart)}:${normalize2(secondPart)}`;
  };
  function normalize2(s) {
    if (s = s.toLowerCase(), s === "_authtoken") return "_authToken";
    let r = s[0];
    for (let i = 1; i < s.length; i++)
      r += s[i] === "_" ? "-" : s[i];
    return r;
  }
  return envKeyToSetting;
}
var util$3 = {}, dist$3 = {}, envReplace = {}, hasRequiredEnvReplace;
function requireEnvReplace() {
  if (hasRequiredEnvReplace) return envReplace;
  hasRequiredEnvReplace = 1, Object.defineProperty(envReplace, "__esModule", { value: !0 }), envReplace.envReplace = void 0;
  const ENV_EXPR = /(?<!\\)(\\*)\$\{([^${}]+)\}/g;
  function envReplace$1(settingValue, env) {
    return settingValue.replace(ENV_EXPR, replaceEnvMatch.bind(null, env));
  }
  envReplace.envReplace = envReplace$1;
  function replaceEnvMatch(env, orig, escape2, name) {
    if (escape2.length % 2)
      return orig.slice((escape2.length + 1) / 2);
    const envValue = getEnvValue(env, name);
    if (envValue === void 0)
      throw new Error(`Failed to replace env in config: ${orig}`);
    return `${escape2.slice(escape2.length / 2)}${envValue}`;
  }
  const ENV_VALUE = /([^:-]+)(:?)-(.+)/;
  function getEnvValue(env, name) {
    const matched = name.match(ENV_VALUE);
    if (!matched)
      return env[name];
    const [, variableName, colon, fallback] = matched;
    return Object.prototype.hasOwnProperty.call(env, variableName) ? !env[variableName] && colon ? fallback : env[variableName] : fallback;
  }
  return envReplace;
}
var hasRequiredDist$2;
function requireDist$2() {
  return hasRequiredDist$2 || (hasRequiredDist$2 = 1, function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.envReplace = void 0;
    var env_replace_1 = requireEnvReplace();
    Object.defineProperty(exports2, "envReplace", { enumerable: !0, get: function() {
      return env_replace_1.envReplace;
    } });
  }(dist$3)), dist$3;
}
var hasRequiredUtil$2;
function requireUtil$2() {
  if (hasRequiredUtil$2) return util$3;
  hasRequiredUtil$2 = 1;
  const fs2 = require$$0__default.default, path2 = require$$0__default$1.default, { envReplace: envReplace2 } = requireDist$2(), parseKey = (key2) => typeof key2 != "string" ? key2 : envReplace2(key2, process.env), parseField = (types2, field, key2) => {
    if (typeof field != "string")
      return field;
    const typeList = [].concat(types2[key2]), isPath = typeList.indexOf(path2) !== -1, isBool = typeList.indexOf(Boolean) !== -1, isString = typeList.indexOf(String) !== -1, isNumber2 = typeList.indexOf(Number) !== -1;
    if (field = `${field}`.trim(), /^".*"$/.test(field))
      try {
        field = JSON.parse(field);
      } catch {
        throw new Error(`Failed parsing JSON config key ${key2}: ${field}`);
      }
    if (isBool && !isString && field === "")
      return !0;
    switch (field) {
      // eslint-disable-line default-case
      case "true":
        return !0;
      case "false":
        return !1;
      case "null":
        return null;
      case "undefined":
        return;
    }
    return field = envReplace2(field, process.env), isPath && ((process.platform === "win32" ? /^~(\/|\\)/ : /^~\//).test(field) && process.env.HOME && (field = path2.resolve(process.env.HOME, field.substr(2))), field = path2.resolve(field)), isNumber2 && !isNaN(field) && (field = Number(field)), field;
  }, findPrefix = (name) => {
    name = path2.resolve(name);
    let walkedUp = !1;
    for (; path2.basename(name) === "node_modules"; )
      name = path2.dirname(name), walkedUp = !0;
    if (walkedUp)
      return name;
    const find2 = (name2, original) => {
      const regex2 = /^[a-zA-Z]:(\\|\/)?$/;
      if (name2 === "/" || process.platform === "win32" && regex2.test(name2))
        return original;
      try {
        const files = fs2.readdirSync(name2);
        if (files.includes("node_modules") || files.includes("package.json") || files.includes("package.json5") || files.includes("package.yaml") || files.includes("pnpm-workspace.yaml"))
          return name2;
        const dirname = path2.dirname(name2);
        return dirname === name2 ? original : find2(dirname, original);
      } catch (error2) {
        if (name2 === original) {
          if (error2.code === "ENOENT")
            return original;
          throw error2;
        }
        return original;
      }
    };
    return find2(name, name);
  };
  return util$3.envReplace = envReplace2, util$3.findPrefix = findPrefix, util$3.parseField = parseField, util$3.parseKey = parseKey, util$3;
}
var types$4 = {}, hasRequiredTypes$3;
function requireTypes$3() {
  if (hasRequiredTypes$3) return types$4;
  hasRequiredTypes$3 = 1;
  const path2 = require$$0__default$1.default, Stream2 = require$$0__default$4.default.Stream, url = require$$5__default.default, Umask = () => {
  }, getLocalAddresses = () => [], semver2 = () => {
  };
  return types$4.types = {
    access: [null, "restricted", "public"],
    "allow-same-version": Boolean,
    "always-auth": Boolean,
    also: [null, "dev", "development"],
    audit: Boolean,
    "auth-type": ["legacy", "sso", "saml", "oauth"],
    "bin-links": Boolean,
    browser: [null, String],
    ca: [null, String, Array],
    cafile: path2,
    cache: path2,
    "cache-lock-stale": Number,
    "cache-lock-retries": Number,
    "cache-lock-wait": Number,
    "cache-max": Number,
    "cache-min": Number,
    cert: [null, String],
    cidr: [null, String, Array],
    color: ["always", Boolean],
    depth: Number,
    description: Boolean,
    dev: Boolean,
    "dry-run": Boolean,
    editor: String,
    "engine-strict": Boolean,
    force: Boolean,
    "fetch-retries": Number,
    "fetch-retry-factor": Number,
    "fetch-retry-mintimeout": Number,
    "fetch-retry-maxtimeout": Number,
    git: String,
    "git-tag-version": Boolean,
    "commit-hooks": Boolean,
    global: Boolean,
    globalconfig: path2,
    "global-style": Boolean,
    group: [Number, String],
    "https-proxy": [null, url],
    "user-agent": String,
    "ham-it-up": Boolean,
    heading: String,
    "if-present": Boolean,
    "ignore-prepublish": Boolean,
    "ignore-scripts": Boolean,
    "init-module": path2,
    "init-author-name": String,
    "init-author-email": String,
    "init-author-url": ["", url],
    "init-license": String,
    "init-version": semver2,
    json: Boolean,
    key: [null, String],
    "legacy-bundling": Boolean,
    link: Boolean,
    // local-address must be listed as an IP for a local network interface
    // must be IPv4 due to node bug
    "local-address": getLocalAddresses(),
    loglevel: ["silent", "error", "warn", "notice", "http", "timing", "info", "verbose", "silly"],
    logstream: Stream2,
    "logs-max": Number,
    long: Boolean,
    maxsockets: Number,
    message: String,
    "metrics-registry": [null, String],
    "node-options": [null, String],
    "node-version": [null, semver2],
    "no-proxy": [null, String, Array],
    offline: Boolean,
    "onload-script": [null, String],
    only: [null, "dev", "development", "prod", "production"],
    optional: Boolean,
    "package-lock": Boolean,
    otp: [null, String],
    "package-lock-only": Boolean,
    parseable: Boolean,
    "prefer-offline": Boolean,
    "prefer-online": Boolean,
    prefix: path2,
    production: Boolean,
    progress: Boolean,
    proxy: [null, !1, url],
    provenance: Boolean,
    // allow proxy to be disabled explicitly
    "read-only": Boolean,
    "rebuild-bundle": Boolean,
    registry: [null, url],
    rollback: Boolean,
    save: Boolean,
    "save-bundle": Boolean,
    "save-dev": Boolean,
    "save-exact": Boolean,
    "save-optional": Boolean,
    "save-prefix": String,
    "save-prod": Boolean,
    scope: String,
    "script-shell": [null, String],
    "scripts-prepend-node-path": [!1, !0, "auto", "warn-only"],
    searchopts: String,
    searchexclude: [null, String],
    searchlimit: Number,
    searchstaleness: Number,
    "send-metrics": Boolean,
    shell: String,
    shrinkwrap: Boolean,
    "sign-git-tag": Boolean,
    "sso-poll-frequency": Number,
    "sso-type": [null, "oauth", "saml"],
    "strict-ssl": Boolean,
    tag: String,
    timing: Boolean,
    tmp: path2,
    unicode: Boolean,
    "unsafe-perm": Boolean,
    usage: Boolean,
    user: [Number, String],
    userconfig: path2,
    umask: Umask,
    version: Boolean,
    "tag-version-prefix": String,
    versions: Boolean,
    viewer: String,
    _exit: Boolean
  }, types$4;
}
var conf, hasRequiredConf;
function requireConf() {
  if (hasRequiredConf) return conf;
  hasRequiredConf = 1;
  const { readCAFileSync } = requireDist$3(), fs2 = require$$0__default.default, path2 = require$$0__default$1.default, { ConfigChain } = requireConfigChain(), envKeyToSetting2 = requireEnvKeyToSetting(), util2 = requireUtil$2();
  class Conf extends ConfigChain {
    // https://github.com/npm/cli/blob/latest/lib/config/core.js#L203-L217
    constructor(base2, types2) {
      super(base2), this.root = base2, this._parseField = util2.parseField.bind(null, types2 || requireTypes$3());
    }
    // https://github.com/npm/cli/blob/latest/lib/config/core.js#L326-L338
    add(data, marker) {
      try {
        for (const [key2, value] of Object.entries(data)) {
          const substKey = util2.parseKey(key2);
          substKey !== key2 && delete data[key2], data[substKey] = this._parseField(value, substKey);
        }
      } catch (error2) {
        throw error2;
      }
      return super.add(data, marker);
    }
    // https://github.com/npm/cli/blob/latest/lib/config/core.js#L306-L319
    addFile(file, name) {
      name = name || file;
      const marker = { __source__: name };
      this.sources[name] = { path: file, type: "ini" }, this.push(marker), this._await();
      try {
        const contents = fs2.readFileSync(file, "utf8");
        this.addString(contents, file, "ini", marker);
      } catch (error2) {
        if (error2.code === "ENOENT")
          this.add({}, marker);
        else if (error2.code !== "EISDIR")
          return `Issue while reading "${file}". ${error2.message}`;
      }
    }
    // https://github.com/npm/cli/blob/latest/lib/config/core.js#L341-L357
    addEnv(env) {
      env = env || process.env;
      const conf2 = {};
      return Object.keys(env).filter((x) => /^npm_config_/i.test(x)).forEach((x) => {
        if (!env[x])
          return;
        const key2 = envKeyToSetting2(x.substr(11)), rawVal = env[x];
        conf2[key2] = deserializeEnvVal(key2, rawVal);
      }), super.addEnv("", conf2, "env");
    }
    // https://github.com/npm/cli/blob/latest/lib/config/load-prefix.js
    loadPrefix() {
      const cli = this.list[0];
      Object.defineProperty(this, "prefix", {
        enumerable: !0,
        set: (prefix) => {
          const g = this.get("global");
          this[g ? "globalPrefix" : "localPrefix"] = prefix;
        },
        get: () => this.get("global") ? this.globalPrefix : this.localPrefix
      }), Object.defineProperty(this, "globalPrefix", {
        enumerable: !0,
        set: (prefix) => {
          this.set("prefix", prefix);
        },
        get: () => path2.resolve(this.get("prefix"))
      });
      let p;
      if (Object.defineProperty(this, "localPrefix", {
        enumerable: !0,
        set: (prefix) => {
          p = prefix;
        },
        get: () => p
      }), Object.prototype.hasOwnProperty.call(cli, "prefix"))
        p = path2.resolve(cli.prefix);
      else
        try {
          p = util2.findPrefix(process.cwd());
        } catch (error2) {
          throw error2;
        }
      return p;
    }
    // https://github.com/npm/cli/blob/latest/lib/config/load-cafile.js
    loadCAFile(file) {
      if (!file)
        return;
      const ca = readCAFileSync(file);
      ca && this.set("ca", ca);
    }
    // https://github.com/npm/cli/blob/latest/lib/config/set-user.js
    loadUser() {
      const defConf = this.root;
      if (this.get("global"))
        return;
      if (process.env.SUDO_UID) {
        defConf.user = Number(process.env.SUDO_UID);
        return;
      }
      const prefix = path2.resolve(this.get("prefix"));
      try {
        const stats = fs2.statSync(prefix);
        defConf.user = stats.uid;
      } catch (error2) {
        if (error2.code === "ENOENT")
          return;
        throw error2;
      }
    }
  }
  function deserializeEnvVal(envKey, envValue) {
    function deserializeList(envValue2) {
      const npmConfigSep = `

`;
      return envValue2.indexOf(npmConfigSep) ? envValue2.split(npmConfigSep) : envValue2.split(",");
    }
    switch (envKey) {
      case "hoist-pattern":
      case "public-hoist-pattern":
        return deserializeList(envValue);
    }
    return envValue;
  }
  return conf = Conf, conf;
}
var defaults$3 = {}, hasRequiredDefaults;
function requireDefaults() {
  return hasRequiredDefaults || (hasRequiredDefaults = 1, function(exports2) {
    const os2 = require$$0__default$2.default, path2 = require$$0__default$1.default, temp = os2.tmpdir(), uidOrPid = process.getuid ? process.getuid() : process.pid, hasUnicode = () => !0, isWindows = process.platform === "win32", osenv = {
      editor: () => process.env.EDITOR || process.env.VISUAL || (isWindows ? "notepad.exe" : "vi"),
      shell: () => isWindows ? process.env.COMSPEC || "cmd.exe" : process.env.SHELL || "/bin/bash"
    }, umask = {
      fromString: () => process.umask()
    };
    let home = os2.homedir();
    home ? process.env.HOME = home : home = path2.resolve(temp, "npm-" + uidOrPid);
    const cacheExtra = process.platform === "win32" ? "npm-cache" : ".npm", cacheRoot = process.platform === "win32" && process.env.APPDATA || home, cache = path2.resolve(cacheRoot, cacheExtra);
    let defaults2, globalPrefix;
    Object.defineProperty(exports2, "defaults", {
      get: function() {
        return defaults2 || (process.env.PREFIX ? globalPrefix = process.env.PREFIX : process.platform === "win32" ? globalPrefix = path2.dirname(process.execPath) : (globalPrefix = path2.dirname(path2.dirname(process.execPath)), process.env.DESTDIR && (globalPrefix = path2.join(process.env.DESTDIR, globalPrefix))), defaults2 = {
          access: null,
          "allow-same-version": !1,
          "always-auth": !1,
          also: null,
          audit: !0,
          "auth-type": "legacy",
          "bin-links": !0,
          browser: null,
          ca: null,
          cafile: null,
          cache,
          "cache-lock-stale": 6e4,
          "cache-lock-retries": 10,
          "cache-lock-wait": 1e4,
          "cache-max": 1 / 0,
          "cache-min": 10,
          cert: null,
          cidr: null,
          color: process.env.NO_COLOR == null,
          depth: 1 / 0,
          description: !0,
          dev: !1,
          "dry-run": !1,
          editor: osenv.editor(),
          "engine-strict": !1,
          force: !1,
          "fetch-retries": 2,
          "fetch-retry-factor": 10,
          "fetch-retry-mintimeout": 1e4,
          "fetch-retry-maxtimeout": 6e4,
          git: "git",
          "git-tag-version": !0,
          "commit-hooks": !0,
          global: !1,
          globalconfig: path2.resolve(globalPrefix, "etc", "npmrc"),
          "global-style": !1,
          group: process.platform === "win32" ? 0 : process.env.SUDO_GID || process.getgid && process.getgid(),
          "ham-it-up": !1,
          heading: "npm",
          "if-present": !1,
          "ignore-prepublish": !1,
          "ignore-scripts": !1,
          "init-module": path2.resolve(home, ".npm-init.js"),
          "init-author-name": "",
          "init-author-email": "",
          "init-author-url": "",
          "init-version": "1.0.0",
          "init-license": "ISC",
          json: !1,
          key: null,
          "legacy-bundling": !1,
          link: !1,
          "local-address": void 0,
          loglevel: "notice",
          logstream: process.stderr,
          "logs-max": 10,
          long: !1,
          maxsockets: 50,
          message: "%s",
          "metrics-registry": null,
          "node-options": null,
          // We remove node-version to fix the issue described here: https://github.com/pnpm/pnpm/issues/4203#issuecomment-1133872769
          offline: !1,
          "onload-script": !1,
          only: null,
          optional: !0,
          otp: null,
          "package-lock": !0,
          "package-lock-only": !1,
          parseable: !1,
          "prefer-offline": !1,
          "prefer-online": !1,
          prefix: globalPrefix,
          production: process.env.NODE_ENV === "production",
          progress: !process.env.TRAVIS && !process.env.CI,
          provenance: !1,
          proxy: null,
          "https-proxy": null,
          "no-proxy": null,
          "user-agent": "npm/{npm-version} node/{node-version} {platform} {arch}",
          "read-only": !1,
          "rebuild-bundle": !0,
          registry: "https://registry.npmjs.org/",
          rollback: !0,
          save: !0,
          "save-bundle": !1,
          "save-dev": !1,
          "save-exact": !1,
          "save-optional": !1,
          "save-prefix": "^",
          "save-prod": !1,
          scope: "",
          "script-shell": null,
          "scripts-prepend-node-path": "warn-only",
          searchopts: "",
          searchexclude: null,
          searchlimit: 20,
          searchstaleness: 15 * 60,
          "send-metrics": !1,
          shell: osenv.shell(),
          shrinkwrap: !0,
          "sign-git-tag": !1,
          "sso-poll-frequency": 500,
          "sso-type": "oauth",
          "strict-ssl": !0,
          tag: "latest",
          "tag-version-prefix": "v",
          timing: !1,
          tmp: temp,
          unicode: hasUnicode(),
          "unsafe-perm": process.platform === "win32" || process.platform === "cygwin" || !(process.getuid && process.setuid && process.getgid && process.setgid) || process.getuid() !== 0,
          usage: !1,
          user: process.platform === "win32" ? 0 : "nobody",
          userconfig: path2.resolve(home, ".npmrc"),
          umask: process.umask ? process.umask() : umask.fromString("022"),
          version: !1,
          versions: !1,
          viewer: process.platform === "win32" ? "browser" : "man",
          _exit: !0
        }, defaults2);
      }
    });
  }(defaults$3)), defaults$3;
}
var hasRequiredNpmConf;
function requireNpmConf() {
  return hasRequiredNpmConf || (hasRequiredNpmConf = 1, function(module2) {
    const path2 = require$$0__default$1.default, Conf = requireConf(), _defaults = requireDefaults();
    module2.exports = (opts, types2, defaults2) => {
      const conf2 = new Conf(Object.assign({}, _defaults.defaults, defaults2), types2);
      conf2.add(Object.assign({}, opts), "cli");
      const warnings = [];
      let failedToLoadBuiltInConfig = !1;
      if (require.resolve.paths) {
        const paths = require.resolve.paths("npm");
        let npmPath;
        try {
          npmPath = require.resolve("npm", { paths: paths.slice(-1) });
        } catch {
          failedToLoadBuiltInConfig = !0;
        }
        npmPath && warnings.push(conf2.addFile(path2.resolve(path2.dirname(npmPath), "..", "npmrc"), "builtin"));
      }
      conf2.addEnv(), conf2.loadPrefix();
      const projectConf = path2.resolve(conf2.localPrefix, ".npmrc"), userConf = conf2.get("userconfig");
      if (!conf2.get("global") && projectConf !== userConf ? warnings.push(conf2.addFile(projectConf, "project")) : conf2.add({}, "project"), conf2.get("workspace-prefix") && conf2.get("workspace-prefix") !== projectConf) {
        const workspaceConf = path2.resolve(conf2.get("workspace-prefix"), ".npmrc");
        warnings.push(conf2.addFile(workspaceConf, "workspace"));
      }
      if (warnings.push(conf2.addFile(conf2.get("userconfig"), "user")), conf2.get("prefix")) {
        const etc = path2.resolve(conf2.get("prefix"), "etc");
        conf2.root.globalconfig = path2.resolve(etc, "npmrc"), conf2.root.globalignorefile = path2.resolve(etc, "npmignore");
      }
      warnings.push(conf2.addFile(conf2.get("globalconfig"), "global")), conf2.loadUser();
      const caFile2 = conf2.get("cafile");
      return caFile2 && conf2.loadCAFile(caFile2), {
        config: conf2,
        warnings: warnings.filter(Boolean),
        failedToLoadBuiltInConfig
      };
    }, Object.defineProperty(module2.exports, "defaults", {
      get() {
        return _defaults.defaults;
      },
      enumerable: !0
    });
  }(npmConf)), npmConf.exports;
}
var registryAuthToken, hasRequiredRegistryAuthToken;
function requireRegistryAuthToken() {
  if (hasRequiredRegistryAuthToken) return registryAuthToken;
  hasRequiredRegistryAuthToken = 1;
  const npmConf2 = requireNpmConf(), tokenKey = ":_authToken", legacyTokenKey = ":_auth", userKey = ":username", passwordKey = ":_password";
  registryAuthToken = function() {
    let checkUrl, options2;
    arguments.length >= 2 ? (checkUrl = arguments[0], options2 = Object.assign({}, arguments[1])) : typeof arguments[0] == "string" ? checkUrl = arguments[0] : options2 = Object.assign({}, arguments[0]), options2 = options2 || {};
    const providedNpmrc = options2.npmrc;
    return options2.npmrc = (options2.npmrc ? {
      config: {
        get: (key2) => providedNpmrc[key2]
      }
    } : npmConf2()).config, checkUrl = checkUrl || options2.npmrc.get("registry") || npmConf2.defaults.registry, getRegistryAuthInfo(checkUrl, options2) || getLegacyAuthInfo(options2.npmrc);
  };
  function urlResolve(from2, to) {
    const resolvedUrl = new URL(to, new URL(from2.startsWith("//") ? `./${from2}` : from2, "resolve://"));
    if (resolvedUrl.protocol === "resolve:") {
      const { pathname, search, hash } = resolvedUrl;
      return pathname + search + hash;
    }
    return resolvedUrl.toString();
  }
  function getRegistryAuthInfo(checkUrl, options2) {
    let parsed = checkUrl instanceof URL ? checkUrl : new URL(checkUrl.startsWith("//") ? `http:${checkUrl}` : checkUrl), pathname;
    for (; pathname !== "/" && parsed.pathname !== pathname; ) {
      pathname = parsed.pathname || "/";
      const regUrl = "//" + parsed.host + pathname.replace(/\/$/, ""), authInfo = getAuthInfoForUrl(regUrl, options2.npmrc);
      if (authInfo)
        return authInfo;
      if (!options2.recursive)
        return /\/$/.test(checkUrl) ? void 0 : getRegistryAuthInfo(new URL("./", parsed), options2);
      parsed.pathname = urlResolve(normalizePath(pathname), "..") || "/";
    }
  }
  function getLegacyAuthInfo(npmrc) {
    return npmrc.get("_auth") ? { token: replaceEnvironmentVariable(npmrc.get("_auth")), type: "Basic" } : void 0;
  }
  function normalizePath(path2) {
    return path2[path2.length - 1] === "/" ? path2 : path2 + "/";
  }
  function getAuthInfoForUrl(regUrl, npmrc) {
    const bearerAuth = getBearerToken(npmrc.get(regUrl + tokenKey) || npmrc.get(regUrl + "/" + tokenKey));
    if (bearerAuth)
      return bearerAuth;
    const username = npmrc.get(regUrl + userKey) || npmrc.get(regUrl + "/" + userKey), password2 = npmrc.get(regUrl + passwordKey) || npmrc.get(regUrl + "/" + passwordKey), basicAuth = getTokenForUsernameAndPassword(username, password2);
    if (basicAuth)
      return basicAuth;
    const basicAuthWithToken = getLegacyAuthToken(npmrc.get(regUrl + legacyTokenKey) || npmrc.get(regUrl + "/" + legacyTokenKey));
    if (basicAuthWithToken)
      return basicAuthWithToken;
  }
  function replaceEnvironmentVariable(token2) {
    return token2.replace(/^\$\{?([^}]*)\}?$/, function(fullMatch, envVar) {
      return process.env[envVar];
    });
  }
  function getBearerToken(tok) {
    return tok ? { token: replaceEnvironmentVariable(tok), type: "Bearer" } : void 0;
  }
  function getTokenForUsernameAndPassword(username, password2) {
    if (!username || !password2)
      return;
    const pass = Buffer.from(replaceEnvironmentVariable(password2), "base64").toString("utf8");
    return {
      token: Buffer.from(username + ":" + pass, "utf8").toString("base64"),
      type: "Basic",
      password: pass,
      username
    };
  }
  function getLegacyAuthToken(tok) {
    return tok ? { token: replaceEnvironmentVariable(tok), type: "Basic" } : void 0;
  }
  return registryAuthToken;
}
var src, hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src;
  hasRequiredSrc = 1;
  const url = require$$5__default.default, { getIt } = require$$1__default$1.default, { debug: debug2, retry: retry2, promise: promise2, httpErrors, jsonResponse } = require$$2__default.default, registryUrl2 = requireRegistryUrl(), registryAuthToken2 = requireRegistryAuthToken(), semver2 = semver__default.default, isJson = (contentType) => /(application\/json|\+json)/.test(contentType || "");
  function shouldRetry(err, num, options2) {
    const response = err.response || { statusCode: 500, headers: {} };
    return (
      // allow retries on low-level errors (socket errors et al)
      retry2.shouldRetry(err, num, options2) || // npm registry routinely fails, giving 503 and similar
      response && response.statusCode >= 500 || // npm registry sometimes returns 2xx with HTML content
      response.statusCode < 300 && !isJson(response.headers["content-type"])
    );
  }
  function resolveRegistryUrl(pkgName, options2) {
    if (options2.registryUrl)
      return options2.registryUrl;
    const scope2 = pkgName.split("/")[0];
    return registryUrl2(scope2);
  }
  const httpRequest = getIt([
    jsonResponse({ force: !0 }),
    httpErrors(),
    debug2({ namespace: "get-latest-version" }),
    promise2(),
    retry2({ shouldRetry })
  ]);
  async function getLatestVersion(pkgName, opts) {
    const options2 = typeof opts == "string" ? { range: opts, auth: !0 } : Object.assign({ range: "latest", auth: !0 }, opts), regUrl = resolveRegistryUrl(pkgName, options2), pkgUrl = url.resolve(regUrl, encodeURIComponent(pkgName).replace(/^%40/, "@")), authInfo = options2.auth && registryAuthToken2(regUrl, { recursive: !0 }), request = options2.request || httpRequest, headers = {
      accept: "application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*"
    };
    authInfo && (headers.authorization = `${authInfo.type} ${authInfo.token}`);
    let res;
    try {
      res = await request({ url: pkgUrl, headers });
    } catch (err) {
      throw err.response && err.response.statusCode === 404 ? new Error(`Package \`${pkgName}\` doesn't exist`) : err;
    }
    const data = res.body, range2 = options2.range, latest = data["dist-tags"].latest;
    if (data["dist-tags"][range2])
      return options2.includeLatest ? { latest, inRange: data["dist-tags"][range2] } : data["dist-tags"][range2];
    if (data.versions[range2])
      return options2.includeLatest ? { latest, inRange: range2 } : range2;
    const versions = Object.keys(data.versions), version2 = semver2.maxSatisfying(versions, range2);
    return version2 ? options2.includeLatest ? { latest, inRange: version2 } : version2 : options2.includeLatest ? { latest, inRange: void 0 } : void 0;
  }
  return getLatestVersion.request = httpRequest, src = getLatestVersion, src;
}
var srcExports = requireSrc(), latestVersion = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(srcExports);
async function getCliVersion() {
  const cliPath = pkgDir__default.default.sync(__dirname);
  if (!cliPath)
    throw new Error("Unable to resolve root of @sanity/cli module");
  let data;
  try {
    data = await fs__default.default.readFile(path__default.default.join(cliPath, "package.json"), "utf-8");
  } catch (err) {
    throw new Error(`Unable to read @sanity/cli/package.json: ${err.message}`);
  }
  return JSON.parse(data).version;
}
function getLocalVersion(moduleId, workDir) {
  const fromPath = workDir || process.cwd(), modulePath = resolveFrom.silent(fromPath, path$3.join(moduleId, "package.json"));
  if (modulePath)
    return tryGetVersion(modulePath);
  const pathSegment = path$3.normalize(moduleId), parentPath = resolveFrom.silent(fromPath, moduleId);
  if (!parentPath)
    return;
  const moduleRoot = parentPath.slice(0, parentPath.lastIndexOf(pathSegment) + pathSegment.length), manifestPath = path$3.join(moduleRoot, "package.json");
  return tryGetVersion(manifestPath);
}
function tryGetVersion(modulePath) {
  try {
    const fileContent = fs$1.readFileSync(modulePath, "utf8");
    return JSON.parse(fileContent).version;
  } catch {
    return;
  }
}
const PACKAGES_TO_EXCLUDE = [
  "@sanity/block-content-to-html",
  "@sanity/block-content-to-react",
  "@sanity/client"
], defaultOptions = {
  includeCli: !0
};
async function findSanityModuleVersions(context, options2 = {}) {
  const { spinner } = context.output, { target, includeCli } = { ...defaultOptions, ...options2 }, cliVersion = await getCliVersion(), sanityModules = filterSanityModules(getLocalManifest(context.workDir)), resolveOpts = { includeCli, target }, spin = spinner("Resolving latest versions").start(), versions = await promiseProps(
    buildPackageArray(sanityModules, context.workDir, resolveOpts, cliVersion)
  ), packages = Object.values(versions);
  return spin.stop(), packages.map((mod) => {
    const current = mod.installed || semver__default.default.minVersion(mod.declared)?.toString() || "", needsUpdate = target === "latest" ? semverCompare(current, mod.latest) === -1 : typeof mod.latestInRange < "u" && mod.installed !== mod.latestInRange;
    return { ...mod, needsUpdate };
  });
}
function getLocalManifest(workDir) {
  try {
    const fileContent = fs$1.readFileSync(path$3.join(workDir, "package.json"), "utf8");
    return JSON.parse(fileContent);
  } catch {
    return {};
  }
}
function filterSanityModules(manifest) {
  const dependencies = {
    ...manifest.dependencies,
    ...manifest.devDependencies
  };
  return Object.keys(dependencies).filter((mod) => mod.startsWith("@sanity/") || mod === "sanity").filter((mod) => !PACKAGES_TO_EXCLUDE.includes(mod)).sort().reduce(
    (versions, dependency) => (versions[dependency] = dependencies[dependency], versions),
    {}
  );
}
function buildPackageArray(packages, workDir, options2 = {}, cliVersion) {
  const { includeCli, target } = options2, modules = [];
  if (includeCli) {
    const [cliMajor] = cliVersion.split("."), latest = tryFindLatestVersion("@sanity/cli", target || `^${cliMajor}`);
    modules.push({
      name: "@sanity/cli",
      declared: `^${cliVersion}`,
      installed: trimHash(cliVersion),
      latest: latest.then((versions) => versions.latest),
      latestInRange: latest.then((versions) => versions.latestInRange),
      isPinned: !1,
      isGlobal: !0
    });
  }
  return [
    ...modules,
    ...Object.keys(packages).map((pkgName) => {
      const latest = tryFindLatestVersion(pkgName, target || packages[pkgName] || "latest"), localVersion = getLocalVersion(pkgName, workDir);
      return {
        name: pkgName,
        declared: packages[pkgName],
        installed: localVersion ? trimHash(localVersion) : void 0,
        latest: latest.then((versions) => versions.latest),
        latestInRange: latest.then((versions) => versions.latestInRange),
        isPinned: isPinnedVersion(packages[pkgName]),
        isGlobal: !1
      };
    })
  ];
}
async function tryFindLatestVersion(pkgName, range2) {
  try {
    const { latest, inRange } = await latestVersion(pkgName, { range: range2, includeLatest: !0 });
    return { latest, latestInRange: inRange };
  } catch (err) {
    if (!(err instanceof Error) || !err.message.includes("No version exists"))
      throw err;
    return { latest: await latestVersion(pkgName), latestInRange: void 0 };
  }
}
function isPinnedVersion(version2) {
  return /^\d+\.\d+\.\d+/.test(version2);
}
function trimHash(version2) {
  return version2.replace(/\+[a-z0-9]{8,}$/, "");
}
const BASE_URL = "https://docs.sanity.io/help/";
function generateHelpUrl(slug) {
  return BASE_URL + slug;
}
var polyfills, hasRequiredPolyfills;
function requirePolyfills() {
  if (hasRequiredPolyfills) return polyfills;
  hasRequiredPolyfills = 1;
  var constants2 = require$$0__default$3.default, origCwd = process.cwd, cwd = null, platform2 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    return cwd || (cwd = origCwd.call(process)), cwd;
  };
  try {
    process.cwd();
  } catch {
  }
  if (typeof process.chdir == "function") {
    var chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null, chdir.call(process, d);
    }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, chdir);
  }
  polyfills = patch;
  function patch(fs2) {
    constants2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && patchLchmod(fs2), fs2.lutimes || patchLutimes(fs2), fs2.chown = chownFix(fs2.chown), fs2.fchown = chownFix(fs2.fchown), fs2.lchown = chownFix(fs2.lchown), fs2.chmod = chmodFix(fs2.chmod), fs2.fchmod = chmodFix(fs2.fchmod), fs2.lchmod = chmodFix(fs2.lchmod), fs2.chownSync = chownFixSync(fs2.chownSync), fs2.fchownSync = chownFixSync(fs2.fchownSync), fs2.lchownSync = chownFixSync(fs2.lchownSync), fs2.chmodSync = chmodFixSync(fs2.chmodSync), fs2.fchmodSync = chmodFixSync(fs2.fchmodSync), fs2.lchmodSync = chmodFixSync(fs2.lchmodSync), fs2.stat = statFix(fs2.stat), fs2.fstat = statFix(fs2.fstat), fs2.lstat = statFix(fs2.lstat), fs2.statSync = statFixSync(fs2.statSync), fs2.fstatSync = statFixSync(fs2.fstatSync), fs2.lstatSync = statFixSync(fs2.lstatSync), fs2.chmod && !fs2.lchmod && (fs2.lchmod = function(path2, mode2, cb) {
      cb && process.nextTick(cb);
    }, fs2.lchmodSync = function() {
    }), fs2.chown && !fs2.lchown && (fs2.lchown = function(path2, uid, gid, cb) {
      cb && process.nextTick(cb);
    }, fs2.lchownSync = function() {
    }), platform2 === "win32" && (fs2.rename = typeof fs2.rename != "function" ? fs2.rename : function(fs$rename) {
      function rename2(from2, to, cb) {
        var start = Date.now(), backoff = 0;
        fs$rename(from2, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
            setTimeout(function() {
              fs2.stat(to, function(stater, st) {
                stater && stater.code === "ENOENT" ? fs$rename(from2, to, CB) : cb(er);
              });
            }, backoff), backoff < 100 && (backoff += 10);
            return;
          }
          cb && cb(er);
        });
      }
      return Object.setPrototypeOf && Object.setPrototypeOf(rename2, fs$rename), rename2;
    }(fs2.rename)), fs2.read = typeof fs2.read != "function" ? fs2.read : function(fs$read) {
      function read2(fd, buffer2, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ == "function") {
          var eagCounter = 0;
          callback = function(er, _, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10)
              return eagCounter++, fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
      }
      return Object.setPrototypeOf && Object.setPrototypeOf(read2, fs$read), read2;
    }(fs2.read), fs2.readSync = typeof fs2.readSync != "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
      return function(fd, buffer2, offset, length, position) {
        for (var eagCounter = 0; ; )
          try {
            return fs$readSync.call(fs2, fd, buffer2, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
      };
    }(fs2.readSync);
    function patchLchmod(fs3) {
      fs3.lchmod = function(path2, mode2, callback) {
        fs3.open(
          path2,
          constants2.O_WRONLY | constants2.O_SYMLINK,
          mode2,
          function(err, fd) {
            if (err) {
              callback && callback(err);
              return;
            }
            fs3.fchmod(fd, mode2, function(err2) {
              fs3.close(fd, function(err22) {
                callback && callback(err2 || err22);
              });
            });
          }
        );
      }, fs3.lchmodSync = function(path2, mode2) {
        var fd = fs3.openSync(path2, constants2.O_WRONLY | constants2.O_SYMLINK, mode2), threw = !0, ret;
        try {
          ret = fs3.fchmodSync(fd, mode2), threw = !1;
        } finally {
          if (threw)
            try {
              fs3.closeSync(fd);
            } catch {
            }
          else
            fs3.closeSync(fd);
        }
        return ret;
      };
    }
    function patchLutimes(fs3) {
      constants2.hasOwnProperty("O_SYMLINK") && fs3.futimes ? (fs3.lutimes = function(path2, at, mt, cb) {
        fs3.open(path2, constants2.O_SYMLINK, function(er, fd) {
          if (er) {
            cb && cb(er);
            return;
          }
          fs3.futimes(fd, at, mt, function(er2) {
            fs3.close(fd, function(er22) {
              cb && cb(er2 || er22);
            });
          });
        });
      }, fs3.lutimesSync = function(path2, at, mt) {
        var fd = fs3.openSync(path2, constants2.O_SYMLINK), ret, threw = !0;
        try {
          ret = fs3.futimesSync(fd, at, mt), threw = !1;
        } finally {
          if (threw)
            try {
              fs3.closeSync(fd);
            } catch {
            }
          else
            fs3.closeSync(fd);
        }
        return ret;
      }) : fs3.futimes && (fs3.lutimes = function(_a, _b, _c, cb) {
        cb && process.nextTick(cb);
      }, fs3.lutimesSync = function() {
      });
    }
    function chmodFix(orig) {
      return orig && function(target, mode2, cb) {
        return orig.call(fs2, target, mode2, function(er) {
          chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      return orig && function(target, mode2) {
        try {
          return orig.call(fs2, target, mode2);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function chownFix(orig) {
      return orig && function(target, uid, gid, cb) {
        return orig.call(fs2, target, uid, gid, function(er) {
          chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      return orig && function(target, uid, gid) {
        try {
          return orig.call(fs2, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function statFix(orig) {
      return orig && function(target, options2, cb) {
        typeof options2 == "function" && (cb = options2, options2 = null);
        function callback(er, stats) {
          stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), cb && cb.apply(this, arguments);
        }
        return options2 ? orig.call(fs2, target, options2, callback) : orig.call(fs2, target, callback);
      };
    }
    function statFixSync(orig) {
      return orig && function(target, options2) {
        var stats = options2 ? orig.call(fs2, target, options2) : orig.call(fs2, target);
        return stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), stats;
      };
    }
    function chownErOk(er) {
      if (!er || er.code === "ENOSYS")
        return !0;
      var nonroot = !process.getuid || process.getuid() !== 0;
      return !!(nonroot && (er.code === "EINVAL" || er.code === "EPERM"));
    }
  }
  return polyfills;
}
var legacyStreams, hasRequiredLegacyStreams;
function requireLegacyStreams() {
  if (hasRequiredLegacyStreams) return legacyStreams;
  hasRequiredLegacyStreams = 1;
  var Stream2 = require$$0__default$4.default.Stream;
  legacyStreams = legacy;
  function legacy(fs2) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path2, options2) {
      if (!(this instanceof ReadStream)) return new ReadStream(path2, options2);
      Stream2.call(this);
      var self2 = this;
      this.path = path2, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, options2 = options2 || {};
      for (var keys = Object.keys(options2), index = 0, length = keys.length; index < length; index++) {
        var key2 = keys[index];
        this[key2] = options2[key2];
      }
      if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.end === void 0)
          this.end = 1 / 0;
        else if (typeof this.end != "number")
          throw TypeError("end must be a Number");
        if (this.start > this.end)
          throw new Error("start must be <= end");
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs2.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err), self2.readable = !1;
          return;
        }
        self2.fd = fd, self2.emit("open", fd), self2._read();
      });
    }
    function WriteStream(path2, options2) {
      if (!(this instanceof WriteStream)) return new WriteStream(path2, options2);
      Stream2.call(this), this.path = path2, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, options2 = options2 || {};
      for (var keys = Object.keys(options2), index = 0, length = keys.length; index < length; index++) {
        var key2 = keys[index];
        this[key2] = options2[key2];
      }
      if (this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.start < 0)
          throw new Error("start must be >= zero");
        this.pos = this.start;
      }
      this.busy = !1, this._queue = [], this.fd === null && (this._open = fs2.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
    }
  }
  return legacyStreams;
}
var clone_1, hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone_1;
  hasRequiredClone = 1, clone_1 = clone;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj != "object")
      return obj;
    if (obj instanceof Object)
      var copy2 = { __proto__: getPrototypeOf(obj) };
    else
      var copy2 = /* @__PURE__ */ Object.create(null);
    return Object.getOwnPropertyNames(obj).forEach(function(key2) {
      Object.defineProperty(copy2, key2, Object.getOwnPropertyDescriptor(obj, key2));
    }), copy2;
  }
  return clone_1;
}
var gracefulFs, hasRequiredGracefulFs;
function requireGracefulFs() {
  if (hasRequiredGracefulFs) return gracefulFs;
  hasRequiredGracefulFs = 1;
  var fs2 = require$$0__default.default, polyfills2 = requirePolyfills(), legacy = requireLegacyStreams(), clone = requireClone(), util2 = require$$0__default$5.default, gracefulQueue, previousSymbol;
  typeof Symbol == "function" && typeof Symbol.for == "function" ? (gracefulQueue = Symbol.for("graceful-fs.queue"), previousSymbol = Symbol.for("graceful-fs.previous")) : (gracefulQueue = "___graceful-fs.queue", previousSymbol = "___graceful-fs.previous");
  function noop2() {
  }
  function publishQueue(context, queue3) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue3;
      }
    });
  }
  var debug2 = noop2;
  if (util2.debuglog ? debug2 = util2.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (debug2 = function() {
    var m = util2.format.apply(util2, arguments);
    m = "GFS4: " + m.split(/\n/).join(`
GFS4: `), console.error(m);
  }), !fs2[gracefulQueue]) {
    var queue2 = loadEnv.commonjsGlobal[gracefulQueue] || [];
    publishQueue(fs2, queue2), fs2.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs2, fd, function(err) {
          err || resetQueue(), typeof cb == "function" && cb.apply(this, arguments);
        });
      }
      return Object.defineProperty(close, previousSymbol, {
        value: fs$close
      }), close;
    }(fs2.close), fs2.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs2, arguments), resetQueue();
      }
      return Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      }), closeSync;
    }(fs2.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
      debug2(fs2[gracefulQueue]), require$$0__default$6.default.equal(fs2[gracefulQueue].length, 0);
    });
  }
  loadEnv.commonjsGlobal[gracefulQueue] || publishQueue(loadEnv.commonjsGlobal, fs2[gracefulQueue]), gracefulFs = patch(clone(fs2)), process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched && (gracefulFs = patch(fs2), fs2.__patched = !0);
  function patch(fs3) {
    polyfills2(fs3), fs3.gracefulify = patch, fs3.createReadStream = createReadStream, fs3.createWriteStream = createWriteStream;
    var fs$readFile = fs3.readFile;
    fs3.readFile = readFile;
    function readFile(path2, options2, cb) {
      return typeof options2 == "function" && (cb = options2, options2 = null), go$readFile(path2, options2, cb);
      function go$readFile(path3, options3, cb2, startTime) {
        return fs$readFile(path3, options3, function(err) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$readFile, [path3, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    var fs$writeFile = fs3.writeFile;
    fs3.writeFile = writeFile;
    function writeFile(path2, data, options2, cb) {
      return typeof options2 == "function" && (cb = options2, options2 = null), go$writeFile(path2, data, options2, cb);
      function go$writeFile(path3, data2, options3, cb2, startTime) {
        return fs$writeFile(path3, data2, options3, function(err) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$writeFile, [path3, data2, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    var fs$appendFile = fs3.appendFile;
    fs$appendFile && (fs3.appendFile = appendFile);
    function appendFile(path2, data, options2, cb) {
      return typeof options2 == "function" && (cb = options2, options2 = null), go$appendFile(path2, data, options2, cb);
      function go$appendFile(path3, data2, options3, cb2, startTime) {
        return fs$appendFile(path3, data2, options3, function(err) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$appendFile, [path3, data2, options3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    var fs$copyFile = fs3.copyFile;
    fs$copyFile && (fs3.copyFile = copyFile);
    function copyFile(src2, dest, flags, cb) {
      return typeof flags == "function" && (cb = flags, flags = 0), go$copyFile(src2, dest, flags, cb);
      function go$copyFile(src3, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src3, dest2, flags2, function(err) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$copyFile, [src3, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    var fs$readdir = fs3.readdir;
    fs3.readdir = readdir2;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir2(path2, options2, cb) {
      typeof options2 == "function" && (cb = options2, options2 = null);
      var go$readdir = noReaddirOptionVersions.test(process.version) ? function(path3, options3, cb2, startTime) {
        return fs$readdir(path3, fs$readdirCallback(
          path3,
          options3,
          cb2,
          startTime
        ));
      } : function(path3, options3, cb2, startTime) {
        return fs$readdir(path3, options3, fs$readdirCallback(
          path3,
          options3,
          cb2,
          startTime
        ));
      };
      return go$readdir(path2, options2, cb);
      function fs$readdirCallback(path3, options3, cb2, startTime) {
        return function(err, files) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([
            go$readdir,
            [path3, options3, cb2],
            err,
            startTime || Date.now(),
            Date.now()
          ]) : (files && files.sort && files.sort(), typeof cb2 == "function" && cb2.call(this, err, files));
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs3);
      ReadStream = legStreams.ReadStream, WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs3.ReadStream;
    fs$ReadStream && (ReadStream.prototype = Object.create(fs$ReadStream.prototype), ReadStream.prototype.open = ReadStream$open);
    var fs$WriteStream = fs3.WriteStream;
    fs$WriteStream && (WriteStream.prototype = Object.create(fs$WriteStream.prototype), WriteStream.prototype.open = WriteStream$open), Object.defineProperty(fs3, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(fs3, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs3, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs3, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    function ReadStream(path2, options2) {
      return this instanceof ReadStream ? (fs$ReadStream.apply(this, arguments), this) : ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open2(that.path, that.flags, that.mode, function(err, fd) {
        err ? (that.autoClose && that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd), that.read());
      });
    }
    function WriteStream(path2, options2) {
      return this instanceof WriteStream ? (fs$WriteStream.apply(this, arguments), this) : WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open2(that.path, that.flags, that.mode, function(err, fd) {
        err ? (that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd));
      });
    }
    function createReadStream(path2, options2) {
      return new fs3.ReadStream(path2, options2);
    }
    function createWriteStream(path2, options2) {
      return new fs3.WriteStream(path2, options2);
    }
    var fs$open = fs3.open;
    fs3.open = open2;
    function open2(path2, flags, mode2, cb) {
      return typeof mode2 == "function" && (cb = mode2, mode2 = null), go$open(path2, flags, mode2, cb);
      function go$open(path3, flags2, mode3, cb2, startTime) {
        return fs$open(path3, flags2, mode3, function(err, fd) {
          err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$open, [path3, flags2, mode3, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
        });
      }
    }
    return fs3;
  }
  function enqueue(elem) {
    debug2("ENQUEUE", elem[0].name, elem[1]), fs2[gracefulQueue].push(elem), retry2();
  }
  var retryTimer;
  function resetQueue() {
    for (var now = Date.now(), i = 0; i < fs2[gracefulQueue].length; ++i)
      fs2[gracefulQueue][i].length > 2 && (fs2[gracefulQueue][i][3] = now, fs2[gracefulQueue][i][4] = now);
    retry2();
  }
  function retry2() {
    if (clearTimeout(retryTimer), retryTimer = void 0, fs2[gracefulQueue].length !== 0) {
      var elem = fs2[gracefulQueue].shift(), fn = elem[0], args = elem[1], err = elem[2], startTime = elem[3], lastTime = elem[4];
      if (startTime === void 0)
        debug2("RETRY", fn.name, args), fn.apply(null, args);
      else if (Date.now() - startTime >= 6e4) {
        debug2("TIMEOUT", fn.name, args);
        var cb = args.pop();
        typeof cb == "function" && cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime, sinceStart = Math.max(lastTime - startTime, 1), desiredDelay = Math.min(sinceStart * 1.2, 100);
        sinceAttempt >= desiredDelay ? (debug2("RETRY", fn.name, args), fn.apply(null, args.concat([startTime]))) : fs2[gracefulQueue].push(elem);
      }
      retryTimer === void 0 && (retryTimer = setTimeout(retry2, 0));
    }
  }
  return gracefulFs;
}
var makeDir = { exports: {} }, hasRequiredMakeDir;
function requireMakeDir() {
  if (hasRequiredMakeDir) return makeDir.exports;
  hasRequiredMakeDir = 1;
  const fs2 = require$$0__default.default, path2 = require$$0__default$1.default, { promisify } = require$$0__default$5.default, useNativeRecursiveOption = semver__default.default.satisfies(process.version, ">=10.12.0"), checkPath = (pth) => {
    if (process.platform === "win32" && /[<>:"|?*]/.test(pth.replace(path2.parse(pth).root, ""))) {
      const error2 = new Error(`Path contains invalid characters: ${pth}`);
      throw error2.code = "EINVAL", error2;
    }
  }, processOptions = (options2) => ({
    ...{
      mode: 511,
      fs: fs2
    },
    ...options2
  }), permissionError = (pth) => {
    const error2 = new Error(`operation not permitted, mkdir '${pth}'`);
    return error2.code = "EPERM", error2.errno = -4048, error2.path = pth, error2.syscall = "mkdir", error2;
  }, makeDir$1 = async (input2, options2) => {
    checkPath(input2), options2 = processOptions(options2);
    const mkdir2 = promisify(options2.fs.mkdir), stat2 = promisify(options2.fs.stat);
    if (useNativeRecursiveOption && options2.fs.mkdir === fs2.mkdir) {
      const pth = path2.resolve(input2);
      return await mkdir2(pth, {
        mode: options2.mode,
        recursive: !0
      }), pth;
    }
    const make = async (pth) => {
      try {
        return await mkdir2(pth, options2.mode), pth;
      } catch (error2) {
        if (error2.code === "EPERM")
          throw error2;
        if (error2.code === "ENOENT") {
          if (path2.dirname(pth) === pth)
            throw permissionError(pth);
          if (error2.message.includes("null bytes"))
            throw error2;
          return await make(path2.dirname(pth)), make(pth);
        }
        try {
          if (!(await stat2(pth)).isDirectory())
            throw new Error("The path is not a directory");
        } catch {
          throw error2;
        }
        return pth;
      }
    };
    return make(path2.resolve(input2));
  };
  return makeDir.exports = makeDir$1, makeDir.exports.sync = (input2, options2) => {
    if (checkPath(input2), options2 = processOptions(options2), useNativeRecursiveOption && options2.fs.mkdirSync === fs2.mkdirSync) {
      const pth = path2.resolve(input2);
      return fs2.mkdirSync(pth, {
        mode: options2.mode,
        recursive: !0
      }), pth;
    }
    const make = (pth) => {
      try {
        options2.fs.mkdirSync(pth, options2.mode);
      } catch (error2) {
        if (error2.code === "EPERM")
          throw error2;
        if (error2.code === "ENOENT") {
          if (path2.dirname(pth) === pth)
            throw permissionError(pth);
          if (error2.message.includes("null bytes"))
            throw error2;
          return make(path2.dirname(pth)), make(pth);
        }
        try {
          if (!options2.fs.statSync(pth).isDirectory())
            throw new Error("The path is not a directory");
        } catch {
          throw error2;
        }
      }
      return pth;
    };
    return make(path2.resolve(input2));
  }, makeDir.exports;
}
var writeFileAtomic = { exports: {} }, imurmurhash = { exports: {} };
/**
 * @preserve
 * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
 *
 * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
 * @see http://github.com/homebrewing/brauhaus-diff
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/murmurhash-js
 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
 * @see http://sites.google.com/site/murmurhash/
 */
var hasRequiredImurmurhash;
function requireImurmurhash() {
  return hasRequiredImurmurhash || (hasRequiredImurmurhash = 1, function(module2) {
    (function() {
      var cache;
      function MurmurHash3(key2, seed) {
        var m = this instanceof MurmurHash3 ? this : cache;
        if (m.reset(seed), typeof key2 == "string" && key2.length > 0 && m.hash(key2), m !== this)
          return m;
      }
      MurmurHash3.prototype.hash = function(key2) {
        var h1, k1, i, top, len;
        switch (len = key2.length, this.len += len, k1 = this.k1, i = 0, this.rem) {
          case 0:
            k1 ^= len > i ? key2.charCodeAt(i++) & 65535 : 0;
          case 1:
            k1 ^= len > i ? (key2.charCodeAt(i++) & 65535) << 8 : 0;
          case 2:
            k1 ^= len > i ? (key2.charCodeAt(i++) & 65535) << 16 : 0;
          case 3:
            k1 ^= len > i ? (key2.charCodeAt(i) & 255) << 24 : 0, k1 ^= len > i ? (key2.charCodeAt(i++) & 65280) >> 8 : 0;
        }
        if (this.rem = len + this.rem & 3, len -= this.rem, len > 0) {
          for (h1 = this.h1; k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295, k1 = k1 << 15 | k1 >>> 17, k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295, h1 ^= k1, h1 = h1 << 13 | h1 >>> 19, h1 = h1 * 5 + 3864292196 & 4294967295, !(i >= len); )
            k1 = key2.charCodeAt(i++) & 65535 ^ (key2.charCodeAt(i++) & 65535) << 8 ^ (key2.charCodeAt(i++) & 65535) << 16, top = key2.charCodeAt(i++), k1 ^= (top & 255) << 24 ^ (top & 65280) >> 8;
          switch (k1 = 0, this.rem) {
            case 3:
              k1 ^= (key2.charCodeAt(i + 2) & 65535) << 16;
            case 2:
              k1 ^= (key2.charCodeAt(i + 1) & 65535) << 8;
            case 1:
              k1 ^= key2.charCodeAt(i) & 65535;
          }
          this.h1 = h1;
        }
        return this.k1 = k1, this;
      }, MurmurHash3.prototype.result = function() {
        var k1, h1;
        return k1 = this.k1, h1 = this.h1, k1 > 0 && (k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295, k1 = k1 << 15 | k1 >>> 17, k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295, h1 ^= k1), h1 ^= this.len, h1 ^= h1 >>> 16, h1 = h1 * 51819 + (h1 & 65535) * 2246770688 & 4294967295, h1 ^= h1 >>> 13, h1 = h1 * 44597 + (h1 & 65535) * 3266445312 & 4294967295, h1 ^= h1 >>> 16, h1 >>> 0;
      }, MurmurHash3.prototype.reset = function(seed) {
        return this.h1 = typeof seed == "number" ? seed : 0, this.rem = this.k1 = this.len = 0, this;
      }, cache = new MurmurHash3(), module2.exports = MurmurHash3;
    })();
  }(imurmurhash)), imurmurhash.exports;
}
var signalExit = { exports: {} }, signals$1 = { exports: {} }, hasRequiredSignals;
function requireSignals() {
  return hasRequiredSignals || (hasRequiredSignals = 1, function(module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ], process.platform !== "win32" && module2.exports.push(
      "SIGVTALRM",
      "SIGXCPU",
      "SIGXFSZ",
      "SIGUSR2",
      "SIGTRAP",
      "SIGSYS",
      "SIGQUIT",
      "SIGIOT"
      // should detect profiler and enable/disable accordingly.
      // see #21
      // 'SIGPROF'
    ), process.platform === "linux" && module2.exports.push(
      "SIGIO",
      "SIGPOLL",
      "SIGPWR",
      "SIGSTKFLT",
      "SIGUNUSED"
    );
  }(signals$1)), signals$1.exports;
}
var hasRequiredSignalExit;
function requireSignalExit() {
  if (hasRequiredSignalExit) return signalExit.exports;
  hasRequiredSignalExit = 1;
  var process2 = loadEnv.commonjsGlobal.process;
  const processOk2 = function(process3) {
    return process3 && typeof process3 == "object" && typeof process3.removeListener == "function" && typeof process3.emit == "function" && typeof process3.reallyExit == "function" && typeof process3.listeners == "function" && typeof process3.kill == "function" && typeof process3.pid == "number" && typeof process3.on == "function";
  };
  if (!processOk2(process2))
    signalExit.exports = function() {
      return function() {
      };
    };
  else {
    var assert = require$$0__default$6.default, signals2 = requireSignals(), isWin = /^win/i.test(process2.platform), EE = require$$0__default$7.default;
    typeof EE != "function" && (EE = EE.EventEmitter);
    var emitter;
    process2.__signal_exit_emitter__ ? emitter = process2.__signal_exit_emitter__ : (emitter = process2.__signal_exit_emitter__ = new EE(), emitter.count = 0, emitter.emitted = {}), emitter.infinite || (emitter.setMaxListeners(1 / 0), emitter.infinite = !0), signalExit.exports = function(cb, opts) {
      if (!processOk2(loadEnv.commonjsGlobal.process))
        return function() {
        };
      assert.equal(typeof cb, "function", "a callback must be provided for exit handler"), loaded === !1 && load();
      var ev = "exit";
      opts && opts.alwaysLast && (ev = "afterexit");
      var remove = function() {
        emitter.removeListener(ev, cb), emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0 && unload();
      };
      return emitter.on(ev, cb), remove;
    };
    var unload = function() {
      !loaded || !processOk2(loadEnv.commonjsGlobal.process) || (loaded = !1, signals2.forEach(function(sig) {
        try {
          process2.removeListener(sig, sigListeners[sig]);
        } catch {
        }
      }), process2.emit = originalProcessEmit, process2.reallyExit = originalProcessReallyExit, emitter.count -= 1);
    };
    signalExit.exports.unload = unload;
    var emit = function(event, code, signal) {
      emitter.emitted[event] || (emitter.emitted[event] = !0, emitter.emit(event, code, signal));
    }, sigListeners = {};
    signals2.forEach(function(sig) {
      sigListeners[sig] = function() {
        if (processOk2(loadEnv.commonjsGlobal.process)) {
          var listeners = process2.listeners(sig);
          listeners.length === emitter.count && (unload(), emit("exit", null, sig), emit("afterexit", null, sig), isWin && sig === "SIGHUP" && (sig = "SIGINT"), process2.kill(process2.pid, sig));
        }
      };
    }), signalExit.exports.signals = function() {
      return signals2;
    };
    var loaded = !1, load = function() {
      loaded || !processOk2(loadEnv.commonjsGlobal.process) || (loaded = !0, emitter.count += 1, signals2 = signals2.filter(function(sig) {
        try {
          return process2.on(sig, sigListeners[sig]), !0;
        } catch {
          return !1;
        }
      }), process2.emit = processEmit, process2.reallyExit = processReallyExit);
    };
    signalExit.exports.load = load;
    var originalProcessReallyExit = process2.reallyExit, processReallyExit = function(code) {
      processOk2(loadEnv.commonjsGlobal.process) && (process2.exitCode = code || /* istanbul ignore next */
      0, emit("exit", process2.exitCode, null), emit("afterexit", process2.exitCode, null), originalProcessReallyExit.call(process2, process2.exitCode));
    }, originalProcessEmit = process2.emit, processEmit = function(ev, arg) {
      if (ev === "exit" && processOk2(loadEnv.commonjsGlobal.process)) {
        arg !== void 0 && (process2.exitCode = arg);
        var ret = originalProcessEmit.apply(this, arguments);
        return emit("exit", process2.exitCode, null), emit("afterexit", process2.exitCode, null), ret;
      } else
        return originalProcessEmit.apply(this, arguments);
    };
  }
  return signalExit.exports;
}
var isTypedarray, hasRequiredIsTypedarray;
function requireIsTypedarray() {
  if (hasRequiredIsTypedarray) return isTypedarray;
  hasRequiredIsTypedarray = 1, isTypedarray = isTypedArray, isTypedArray.strict = isStrictTypedArray, isTypedArray.loose = isLooseTypedArray;
  var toString = Object.prototype.toString, names = {
    "[object Int8Array]": !0,
    "[object Int16Array]": !0,
    "[object Int32Array]": !0,
    "[object Uint8Array]": !0,
    "[object Uint8ClampedArray]": !0,
    "[object Uint16Array]": !0,
    "[object Uint32Array]": !0,
    "[object Float32Array]": !0,
    "[object Float64Array]": !0
  };
  function isTypedArray(arr) {
    return isStrictTypedArray(arr) || isLooseTypedArray(arr);
  }
  function isStrictTypedArray(arr) {
    return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
  }
  function isLooseTypedArray(arr) {
    return names[toString.call(arr)];
  }
  return isTypedarray;
}
var typedarrayToBuffer, hasRequiredTypedarrayToBuffer;
function requireTypedarrayToBuffer() {
  if (hasRequiredTypedarrayToBuffer) return typedarrayToBuffer;
  hasRequiredTypedarrayToBuffer = 1;
  var isTypedArray = requireIsTypedarray().strict;
  return typedarrayToBuffer = function(arr) {
    if (isTypedArray(arr)) {
      var buf = Buffer.from(arr.buffer);
      return arr.byteLength !== arr.buffer.byteLength && (buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)), buf;
    } else
      return Buffer.from(arr);
  }, typedarrayToBuffer;
}
var hasRequiredWriteFileAtomic;
function requireWriteFileAtomic() {
  if (hasRequiredWriteFileAtomic) return writeFileAtomic.exports;
  hasRequiredWriteFileAtomic = 1, writeFileAtomic.exports = writeFile, writeFileAtomic.exports.sync = writeFileSync, writeFileAtomic.exports._getTmpname = getTmpname, writeFileAtomic.exports._cleanupOnExit = cleanupOnExit;
  const fs2 = require$$0__default.default, MurmurHash3 = requireImurmurhash(), onExit2 = requireSignalExit(), path2 = require$$0__default$1.default, isTypedArray = requireIsTypedarray(), typedArrayToBuffer = requireTypedarrayToBuffer(), { promisify } = require$$0__default$5.default, activeFiles = {}, threadId = function() {
    try {
      return require("worker_threads").threadId;
    } catch {
      return 0;
    }
  }();
  let invocations = 0;
  function getTmpname(filename) {
    return filename + "." + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
  }
  function cleanupOnExit(tmpfile) {
    return () => {
      try {
        fs2.unlinkSync(typeof tmpfile == "function" ? tmpfile() : tmpfile);
      } catch {
      }
    };
  }
  function serializeActiveFile(absoluteName) {
    return new Promise((resolve) => {
      activeFiles[absoluteName] || (activeFiles[absoluteName] = []), activeFiles[absoluteName].push(resolve), activeFiles[absoluteName].length === 1 && resolve();
    });
  }
  function isChownErrOk(err) {
    return err.code === "ENOSYS" || (!process.getuid || process.getuid() !== 0) && (err.code === "EINVAL" || err.code === "EPERM");
  }
  async function writeFileAsync(filename, data, options2 = {}) {
    typeof options2 == "string" && (options2 = { encoding: options2 });
    let fd, tmpfile;
    const removeOnExitHandler = onExit2(cleanupOnExit(() => tmpfile)), absoluteName = path2.resolve(filename);
    try {
      await serializeActiveFile(absoluteName);
      const truename = await promisify(fs2.realpath)(filename).catch(() => filename);
      if (tmpfile = getTmpname(truename), !options2.mode || !options2.chown) {
        const stats = await promisify(fs2.stat)(truename).catch(() => {
        });
        stats && (options2.mode == null && (options2.mode = stats.mode), options2.chown == null && process.getuid && (options2.chown = { uid: stats.uid, gid: stats.gid }));
      }
      fd = await promisify(fs2.open)(tmpfile, "w", options2.mode), options2.tmpfileCreated && await options2.tmpfileCreated(tmpfile), isTypedArray(data) && (data = typedArrayToBuffer(data)), Buffer.isBuffer(data) ? await promisify(fs2.write)(fd, data, 0, data.length, 0) : data != null && await promisify(fs2.write)(fd, String(data), 0, String(options2.encoding || "utf8")), options2.fsync !== !1 && await promisify(fs2.fsync)(fd), await promisify(fs2.close)(fd), fd = null, options2.chown && await promisify(fs2.chown)(tmpfile, options2.chown.uid, options2.chown.gid).catch((err) => {
        if (!isChownErrOk(err))
          throw err;
      }), options2.mode && await promisify(fs2.chmod)(tmpfile, options2.mode).catch((err) => {
        if (!isChownErrOk(err))
          throw err;
      }), await promisify(fs2.rename)(tmpfile, truename);
    } finally {
      fd && await promisify(fs2.close)(fd).catch(
        /* istanbul ignore next */
        () => {
        }
      ), removeOnExitHandler(), await promisify(fs2.unlink)(tmpfile).catch(() => {
      }), activeFiles[absoluteName].shift(), activeFiles[absoluteName].length > 0 ? activeFiles[absoluteName][0]() : delete activeFiles[absoluteName];
    }
  }
  function writeFile(filename, data, options2, callback) {
    options2 instanceof Function && (callback = options2, options2 = {});
    const promise2 = writeFileAsync(filename, data, options2);
    return callback && promise2.then(callback, callback), promise2;
  }
  function writeFileSync(filename, data, options2) {
    typeof options2 == "string" ? options2 = { encoding: options2 } : options2 || (options2 = {});
    try {
      filename = fs2.realpathSync(filename);
    } catch {
    }
    const tmpfile = getTmpname(filename);
    if (!options2.mode || !options2.chown)
      try {
        const stats = fs2.statSync(filename);
        options2 = Object.assign({}, options2), options2.mode || (options2.mode = stats.mode), !options2.chown && process.getuid && (options2.chown = { uid: stats.uid, gid: stats.gid });
      } catch {
      }
    let fd;
    const cleanup = cleanupOnExit(tmpfile), removeOnExitHandler = onExit2(cleanup);
    let threw = !0;
    try {
      if (fd = fs2.openSync(tmpfile, "w", options2.mode || 438), options2.tmpfileCreated && options2.tmpfileCreated(tmpfile), isTypedArray(data) && (data = typedArrayToBuffer(data)), Buffer.isBuffer(data) ? fs2.writeSync(fd, data, 0, data.length, 0) : data != null && fs2.writeSync(fd, String(data), 0, String(options2.encoding || "utf8")), options2.fsync !== !1 && fs2.fsyncSync(fd), fs2.closeSync(fd), fd = null, options2.chown)
        try {
          fs2.chownSync(tmpfile, options2.chown.uid, options2.chown.gid);
        } catch (err) {
          if (!isChownErrOk(err))
            throw err;
        }
      if (options2.mode)
        try {
          fs2.chmodSync(tmpfile, options2.mode);
        } catch (err) {
          if (!isChownErrOk(err))
            throw err;
        }
      fs2.renameSync(tmpfile, filename), threw = !1;
    } finally {
      if (fd)
        try {
          fs2.closeSync(fd);
        } catch {
        }
      removeOnExitHandler(), threw && cleanup();
    }
  }
  return writeFileAtomic.exports;
}
var isObj, hasRequiredIsObj;
function requireIsObj() {
  return hasRequiredIsObj || (hasRequiredIsObj = 1, isObj = (value) => {
    const type2 = typeof value;
    return value !== null && (type2 === "object" || type2 === "function");
  }), isObj;
}
var dotProp, hasRequiredDotProp;
function requireDotProp() {
  if (hasRequiredDotProp) return dotProp;
  hasRequiredDotProp = 1;
  const isObj2 = requireIsObj(), disallowedKeys = [
    "__proto__",
    "prototype",
    "constructor"
  ], isValidPath = (pathSegments) => !pathSegments.some((segment) => disallowedKeys.includes(segment));
  function getPathSegments(path2) {
    const pathArray = path2.split("."), parts = [];
    for (let i = 0; i < pathArray.length; i++) {
      let p = pathArray[i];
      for (; p[p.length - 1] === "\\" && pathArray[i + 1] !== void 0; )
        p = p.slice(0, -1) + ".", p += pathArray[++i];
      parts.push(p);
    }
    return isValidPath(parts) ? parts : [];
  }
  return dotProp = {
    get(object, path2, value) {
      if (!isObj2(object) || typeof path2 != "string")
        return value === void 0 ? object : value;
      const pathArray = getPathSegments(path2);
      if (pathArray.length !== 0) {
        for (let i = 0; i < pathArray.length; i++) {
          if (!Object.prototype.propertyIsEnumerable.call(object, pathArray[i]))
            return value;
          if (object = object[pathArray[i]], object == null) {
            if (i !== pathArray.length - 1)
              return value;
            break;
          }
        }
        return object;
      }
    },
    set(object, path2, value) {
      if (!isObj2(object) || typeof path2 != "string")
        return object;
      const root2 = object, pathArray = getPathSegments(path2);
      for (let i = 0; i < pathArray.length; i++) {
        const p = pathArray[i];
        isObj2(object[p]) || (object[p] = {}), i === pathArray.length - 1 && (object[p] = value), object = object[p];
      }
      return root2;
    },
    delete(object, path2) {
      if (!isObj2(object) || typeof path2 != "string")
        return !1;
      const pathArray = getPathSegments(path2);
      for (let i = 0; i < pathArray.length; i++) {
        const p = pathArray[i];
        if (i === pathArray.length - 1)
          return delete object[p], !0;
        if (object = object[p], !isObj2(object))
          return !1;
      }
    },
    has(object, path2) {
      if (!isObj2(object) || typeof path2 != "string")
        return !1;
      const pathArray = getPathSegments(path2);
      if (pathArray.length === 0)
        return !1;
      for (let i = 0; i < pathArray.length; i++)
        if (isObj2(object)) {
          if (!(pathArray[i] in object))
            return !1;
          object = object[pathArray[i]];
        } else
          return !1;
      return !0;
    }
  }, dotProp;
}
var cryptoRandomString, hasRequiredCryptoRandomString;
function requireCryptoRandomString() {
  if (hasRequiredCryptoRandomString) return cryptoRandomString;
  hasRequiredCryptoRandomString = 1;
  const crypto = require$$3__default.default;
  return cryptoRandomString = (length) => {
    if (!Number.isFinite(length))
      throw new TypeError("Expected a finite number");
    return crypto.randomBytes(Math.ceil(length / 2)).toString("hex").slice(0, length);
  }, cryptoRandomString;
}
var uniqueString, hasRequiredUniqueString;
function requireUniqueString() {
  if (hasRequiredUniqueString) return uniqueString;
  hasRequiredUniqueString = 1;
  const cryptoRandomString2 = requireCryptoRandomString();
  return uniqueString = () => cryptoRandomString2(32), uniqueString;
}
var configstore, hasRequiredConfigstore;
function requireConfigstore() {
  if (hasRequiredConfigstore) return configstore;
  hasRequiredConfigstore = 1;
  const path2 = require$$0__default$1.default, os2 = require$$0__default$2.default, fs2 = requireGracefulFs(), makeDir2 = requireMakeDir(), xdgBasedir2 = requireXdgBasedir(), writeFileAtomic2 = requireWriteFileAtomic(), dotProp2 = requireDotProp(), uniqueString2 = requireUniqueString(), configDirectory = xdgBasedir2.config || path2.join(os2.tmpdir(), uniqueString2()), permissionError = "You don't have access to this file.", makeDirOptions = { mode: 448 }, writeFileOptions = { mode: 384 };
  class Configstore {
    constructor(id, defaults2, options2 = {}) {
      const pathPrefix = options2.globalConfigPath ? path2.join(id, "config.json") : path2.join("configstore", `${id}.json`);
      this.path = options2.configPath || path2.join(configDirectory, pathPrefix), defaults2 && (this.all = {
        ...defaults2,
        ...this.all
      });
    }
    get all() {
      try {
        return JSON.parse(fs2.readFileSync(this.path, "utf8"));
      } catch (error2) {
        if (error2.code === "ENOENT")
          return {};
        if (error2.code === "EACCES" && (error2.message = `${error2.message}
${permissionError}
`), error2.name === "SyntaxError")
          return writeFileAtomic2.sync(this.path, "", writeFileOptions), {};
        throw error2;
      }
    }
    set all(value) {
      try {
        makeDir2.sync(path2.dirname(this.path), makeDirOptions), writeFileAtomic2.sync(this.path, JSON.stringify(value, void 0, "	"), writeFileOptions);
      } catch (error2) {
        throw error2.code === "EACCES" && (error2.message = `${error2.message}
${permissionError}
`), error2;
      }
    }
    get size() {
      return Object.keys(this.all || {}).length;
    }
    get(key2) {
      return dotProp2.get(this.all, key2);
    }
    set(key2, value) {
      const config2 = this.all;
      if (arguments.length === 1)
        for (const k of Object.keys(key2))
          dotProp2.set(config2, k, key2[k]);
      else
        dotProp2.set(config2, key2, value);
      this.all = config2;
    }
    has(key2) {
      return dotProp2.has(this.all, key2);
    }
    delete(key2) {
      const config2 = this.all;
      dotProp2.delete(config2, key2), this.all = config2;
    }
    clear() {
      this.all = {};
    }
  }
  return configstore = Configstore, configstore;
}
var configstoreExports = requireConfigstore(), ConfigStore = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(configstoreExports);
const sanityEnv$1 = (process.env.SANITY_INTERNAL_ENV || "").toLowerCase(), configName = sanityEnv$1 && sanityEnv$1 !== "production" ? `sanity-${sanityEnv$1}` : "sanity", defaults$2 = {};
let config$1;
const getUserConfig = () => (config$1 || (config$1 = new ConfigStore(configName, defaults$2, { globalConfigPath: !0 })), config$1), apiHosts = {
  staging: "https://api.sanity.work",
  development: "http://api.sanity.local"
}, defaults$1 = {
  requireUser: !0,
  requireProject: !0
}, authErrors = () => ({
  onError: (err) => (!err || !isReqResError(err) || (err.response && err.response.body && err.response.body.statusCode) === 401 && (err.message = `${err.message}. You may need to login again with ${chalk__default.default.cyan(
    "sanity login"
  )}.
For more information, see ${generateHelpUrl("cli-errors")}.`), err)
});
function isReqResError(err) {
  return err.hasOwnProperty("response");
}
function getCliToken() {
  const envAuthToken = process.env.SANITY_AUTH_TOKEN, userConfig = getUserConfig();
  return envAuthToken || userConfig.get("authToken");
}
function getClientWrapper(cliApiConfig, configPath) {
  const requester = client$1.requester.clone();
  return requester.use(authErrors()), function(opts) {
    const sanityEnv2 = process.env.SANITY_INTERNAL_ENV || "production", { requireUser, requireProject, api } = { ...defaults$1, ...opts }, token2 = getCliToken(), apiHost = apiHosts[sanityEnv2], apiConfig = {
      ...cliApiConfig,
      ...api
    };
    if (apiHost && (apiConfig.apiHost = apiHost), requireUser && !token2)
      throw new Error('You must login first - run "sanity login"');
    if (requireProject && !apiConfig.projectId) {
      const relativeConfigPath = path__default.default.relative(process.cwd(), configPath);
      throw new Error(
        `${relativeConfigPath} does not contain a project identifier ("api.projectId"), which is required for the Sanity CLI to communicate with the Sanity API`
      );
    }
    return client$1.createClient({
      ...apiConfig,
      apiVersion: "1",
      dataset: apiConfig.dataset || "~dummy-placeholder-dataset-",
      token: requireUser ? token2 : void 0,
      useProjectHostname: requireProject,
      requester,
      useCdn: !1
    });
  };
}
const printVersionResultCommand = async (args, context) => {
  const versions = await findSanityModuleVersions(context, { target: "latest" });
  printResult(versions, context.output.print);
};
function printResult(versions, print) {
  const { versionLength, formatName } = getFormatters(versions);
  versions.forEach((mod) => {
    const version2 = lodashExports.padStart(mod.installed || "<missing>", versionLength), latest = mod.installed === mod.latest ? chalk__default.default.green("(up to date)") : `(latest: ${chalk__default.default.yellow(mod.latest)})`;
    print(`${formatName(getDisplayName(mod))} ${version2} ${latest}`);
  });
}
function getFormatters(versions) {
  const nameLength = versions.reduce((max2, mod) => Math.max(max2, getDisplayName(mod).length), 0), versionLength = versions.reduce(
    (max2, mod) => Math.max(max2, (mod.installed || "<missing>").length),
    0
  );
  return { nameLength, versionLength, formatName: (name) => lodashExports.padEnd(name, nameLength + 1).replace(/^@sanity\/(.*?)(\s|$)/, `${chalk__default.default.yellow("@sanity/")}${chalk__default.default.cyan("$1")}$2`).replace(/^sanity(\s|$)/, `${chalk__default.default.yellow("sanity")}$1`) };
}
function getDisplayName(mod) {
  return mod.isGlobal ? `${mod.name} (global)` : mod.name;
}
const printDebugInfo = async (args, context) => {
  const flags = args.extOptions, { user, globalConfig, projectConfig, project, versions } = await gatherInfo(context), { chalk: chalk2 } = context;
  context.output.print(`
User:`), user instanceof Error ? context.output.print(`  ${chalk2.red(user.message)}
`) : printKeyValue(
    {
      ID: user.id,
      Name: user.name,
      Email: user.email,
      Roles: project ? project.userRoles : void 0
    },
    context
  ), project && (context.output.print("Project:"), printKeyValue(
    {
      ID: project.id,
      "Display name": project.displayName,
      "Studio URL": project.studioHostname
    },
    context
  ));
  const authToken = process.env.SANITY_AUTH_TOKEN || globalConfig.authToken;
  authToken && (context.output.print("Authentication:"), printKeyValue(
    {
      "User type": globalConfig.authType || "normal",
      "Auth token": flags.secrets ? authToken : "<redacted>"
    },
    context
  ), flags.secrets || context.output.print(`  (run with --secrets to reveal token)
`)), context.output.print(`Global config (${chalk2.yellow(getGlobalConfigLocation())}):`);
  const globalCfg = lodashExports.omit(globalConfig, ["authType", "authToken"]);
  if (context.output.print(`  ${formatObject(globalCfg).replace(/\n/g, `
  `)}
`), projectConfig) {
    const configLocation = context.cliConfigPath ? ` (${chalk2.yellow(path__default.default.relative(process.cwd(), context.cliConfigPath))})` : "";
    context.output.print(`Project config${configLocation}:`), context.output.print(`  ${formatObject(projectConfig).replace(/\n/g, `
  `)}`);
  }
  versions && (context.output.print(`
Package versions:`), printResult(versions, (line3) => context.output.print(`  ${line3}`)), context.output.print(""));
};
function formatObject(obj) {
  return util__default.default.inspect(obj, { colors: !0, depth: 1 / 0 });
}
function printKeyValue(obj, context) {
  let printedLines = 0;
  Object.keys(obj).forEach((key2) => {
    typeof obj[key2] < "u" && (context.output.print(`  ${key2}: ${formatObject(obj[key2])}`), printedLines++);
  }), printedLines > 0 && context.output.print("");
}
async function gatherInfo(context) {
  const baseInfo = await promiseProps({
    globalConfig: gatherGlobalConfigInfo(),
    projectConfig: gatherProjectConfigInfo(context)
  }), withUser = {
    ...baseInfo,
    user: await gatherUserInfo(context, {
      projectBased: !!(baseInfo.projectConfig && baseInfo.projectConfig.api)
    })
  };
  return promiseProps({
    project: gatherProjectInfo(context, withUser),
    versions: findSanityModuleVersions(context, { target: "latest" }),
    ...withUser
  });
}
function getGlobalConfigLocation() {
  const user = (os__default.default.userInfo().username || "user").replace(/\\/g, ""), configDir = xdgBasedir.config || path__default.default.join(os__default.default.tmpdir(), user, ".config");
  return path__default.default.join(configDir, "sanity", "config.json");
}
function gatherGlobalConfigInfo() {
  return getUserConfig().all;
}
function gatherProjectConfigInfo(context) {
  const { cliConfig } = context;
  return cliConfig?.api?.projectId ? cliConfig : {
    error: 'Missing required "api.projectId" key'
  };
}
async function gatherProjectInfo(context, baseInfo) {
  const projectId = context.apiClient({ requireUser: !1, requireProject: !1 }).config().projectId, hasToken = !!getCliToken();
  if (!projectId || !hasToken)
    return null;
  const projectInfo = await context.apiClient({ requireUser: !0, requireProject: !1 }).withConfig({ apiVersion: "2023-06-06" }).request({ url: `/projects/${projectId}` });
  if (!projectInfo)
    return new Error(`Project specified in configuration (${projectId}) does not exist in API`);
  const userId = baseInfo.user instanceof Error ? null : baseInfo.user.id, host = projectInfo.studioHost, member = (projectInfo.members || []).find((user) => user.id === userId), hostname = host && `https://${host}.sanity.studio/`;
  return {
    id: projectId,
    displayName: projectInfo.displayName,
    studioHostname: hostname,
    userRoles: member ? member.roles.map((role) => role.name) : ["<none>"]
  };
}
async function gatherUserInfo(context, options2) {
  if (!getCliToken())
    return new Error("Not logged in");
  const userInfo = await context.apiClient({ requireUser: !0, requireProject: options2.projectBased }).users.getById("me");
  return userInfo ? lodashExports.pick(userInfo, ["id", "name", "email"]) : new Error("Token expired or invalid");
}
const help$2 = `
Used to find information about the Sanity environment, and to debug Sanity-related issues.

Options
  --secrets Include API keys in output

Examples
  # Show information about the user, project, and local/global Sanity environment
  sanity debug

  # Include API keys in the output
  sanity debug --secrets
`, debugCommand = {
  name: "debug",
  signature: "[--secrets]",
  description: "Provides diagnostic info for Sanity Studio troubleshooting",
  helpText: help$2,
  action: printDebugInfo
};
var isWsl = { exports: {} }, isDocker_1, hasRequiredIsDocker;
function requireIsDocker() {
  if (hasRequiredIsDocker) return isDocker_1;
  hasRequiredIsDocker = 1;
  const fs2 = require$$0__default.default;
  let isDocker;
  function hasDockerEnv() {
    try {
      return fs2.statSync("/.dockerenv"), !0;
    } catch {
      return !1;
    }
  }
  function hasDockerCGroup() {
    try {
      return fs2.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
    } catch {
      return !1;
    }
  }
  return isDocker_1 = () => (isDocker === void 0 && (isDocker = hasDockerEnv() || hasDockerCGroup()), isDocker), isDocker_1;
}
var hasRequiredIsWsl;
function requireIsWsl() {
  if (hasRequiredIsWsl) return isWsl.exports;
  hasRequiredIsWsl = 1;
  const os2 = require$$0__default$2.default, fs2 = require$$0__default.default, isDocker = requireIsDocker(), isWsl$1 = () => {
    if (process.platform !== "linux")
      return !1;
    if (os2.release().toLowerCase().includes("microsoft"))
      return !isDocker();
    try {
      return fs2.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : !1;
    } catch {
      return !1;
    }
  };
  return process.env.__IS_WSL_TEST__ ? isWsl.exports = isWsl$1 : isWsl.exports = isWsl$1(), isWsl.exports;
}
var defineLazyProp, hasRequiredDefineLazyProp;
function requireDefineLazyProp() {
  return hasRequiredDefineLazyProp || (hasRequiredDefineLazyProp = 1, defineLazyProp = (object, propertyName, fn) => {
    const define = (value) => Object.defineProperty(object, propertyName, { value, enumerable: !0, writable: !0 });
    return Object.defineProperty(object, propertyName, {
      configurable: !0,
      enumerable: !0,
      get() {
        const result = fn();
        return define(result), result;
      },
      set(value) {
        define(value);
      }
    }), object;
  }), defineLazyProp;
}
var open_1, hasRequiredOpen;
function requireOpen() {
  if (hasRequiredOpen) return open_1;
  hasRequiredOpen = 1;
  const path2 = require$$0__default$1.default, childProcess2 = require$$1__default$2.default, { promises: fs2, constants: fsConstants } = require$$0__default.default, isWsl2 = requireIsWsl(), isDocker = requireIsDocker(), defineLazyProperty = requireDefineLazyProp(), localXdgOpenPath = path2.join(__dirname, "xdg-open"), { platform: platform2, arch } = process, hasContainerEnv = () => {
    try {
      return fs2.statSync("/run/.containerenv"), !0;
    } catch {
      return !1;
    }
  };
  let cachedResult;
  function isInsideContainer() {
    return cachedResult === void 0 && (cachedResult = hasContainerEnv() || isDocker()), cachedResult;
  }
  const getWslDrivesMountPoint = /* @__PURE__ */ (() => {
    const defaultMountPoint = "/mnt/";
    let mountPoint;
    return async function() {
      if (mountPoint)
        return mountPoint;
      const configFilePath = "/etc/wsl.conf";
      let isConfigFileExists = !1;
      try {
        await fs2.access(configFilePath, fsConstants.F_OK), isConfigFileExists = !0;
      } catch {
      }
      if (!isConfigFileExists)
        return defaultMountPoint;
      const configContent = await fs2.readFile(configFilePath, { encoding: "utf8" }), configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
      return configMountPoint ? (mountPoint = configMountPoint.groups.mountPoint.trim(), mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`, mountPoint) : defaultMountPoint;
    };
  })(), pTryEach = async (array, mapper) => {
    let latestError;
    for (const item of array)
      try {
        return await mapper(item);
      } catch (error2) {
        latestError = error2;
      }
    throw latestError;
  }, baseOpen = async (options2) => {
    if (options2 = {
      wait: !1,
      background: !1,
      newInstance: !1,
      allowNonzeroExitCode: !1,
      ...options2
    }, Array.isArray(options2.app))
      return pTryEach(options2.app, (singleApp) => baseOpen({
        ...options2,
        app: singleApp
      }));
    let { name: app, arguments: appArguments = [] } = options2.app || {};
    if (appArguments = [...appArguments], Array.isArray(app))
      return pTryEach(app, (appName) => baseOpen({
        ...options2,
        app: {
          name: appName,
          arguments: appArguments
        }
      }));
    let command2;
    const cliArguments = [], childProcessOptions = {};
    if (platform2 === "darwin")
      command2 = "open", options2.wait && cliArguments.push("--wait-apps"), options2.background && cliArguments.push("--background"), options2.newInstance && cliArguments.push("--new"), app && cliArguments.push("-a", app);
    else if (platform2 === "win32" || isWsl2 && !isInsideContainer() && !app) {
      const mountPoint = await getWslDrivesMountPoint();
      command2 = isWsl2 ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`, cliArguments.push(
        "-NoProfile",
        "-NonInteractive",
        "\u2013ExecutionPolicy",
        "Bypass",
        "-EncodedCommand"
      ), isWsl2 || (childProcessOptions.windowsVerbatimArguments = !0);
      const encodedArguments = ["Start"];
      options2.wait && encodedArguments.push("-Wait"), app ? (encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList"), options2.target && appArguments.unshift(options2.target)) : options2.target && encodedArguments.push(`"${options2.target}"`), appArguments.length > 0 && (appArguments = appArguments.map((arg) => `"\`"${arg}\`""`), encodedArguments.push(appArguments.join(","))), options2.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
    } else {
      if (app)
        command2 = app;
      else {
        const isBundled = !__dirname || __dirname === "/";
        let exeLocalXdgOpen = !1;
        try {
          await fs2.access(localXdgOpenPath, fsConstants.X_OK), exeLocalXdgOpen = !0;
        } catch {
        }
        command2 = process.versions.electron || platform2 === "android" || isBundled || !exeLocalXdgOpen ? "xdg-open" : localXdgOpenPath;
      }
      appArguments.length > 0 && cliArguments.push(...appArguments), options2.wait || (childProcessOptions.stdio = "ignore", childProcessOptions.detached = !0);
    }
    options2.target && cliArguments.push(options2.target), platform2 === "darwin" && appArguments.length > 0 && cliArguments.push("--args", ...appArguments);
    const subprocess = childProcess2.spawn(command2, cliArguments, childProcessOptions);
    return options2.wait ? new Promise((resolve, reject) => {
      subprocess.once("error", reject), subprocess.once("close", (exitCode) => {
        if (!options2.allowNonzeroExitCode && exitCode > 0) {
          reject(new Error(`Exited with code ${exitCode}`));
          return;
        }
        resolve(subprocess);
      });
    }) : (subprocess.unref(), subprocess);
  }, open2 = (target, options2) => {
    if (typeof target != "string")
      throw new TypeError("Expected a `target`");
    return baseOpen({
      ...options2,
      target
    });
  }, openApp = (name, options2) => {
    if (typeof name != "string")
      throw new TypeError("Expected a `name`");
    const { arguments: appArguments = [] } = options2 || {};
    if (appArguments != null && !Array.isArray(appArguments))
      throw new TypeError("Expected `appArguments` as Array type");
    return baseOpen({
      ...options2,
      app: {
        name,
        arguments: appArguments
      }
    });
  };
  function detectArchBinary(binary2) {
    if (typeof binary2 == "string" || Array.isArray(binary2))
      return binary2;
    const { [arch]: archBinary } = binary2;
    if (!archBinary)
      throw new Error(`${arch} is not supported`);
    return archBinary;
  }
  function detectPlatformBinary({ [platform2]: platformBinary }, { wsl }) {
    if (wsl && isWsl2)
      return detectArchBinary(wsl);
    if (!platformBinary)
      throw new Error(`${platform2} is not supported`);
    return detectArchBinary(platformBinary);
  }
  const apps = {};
  return defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
    darwin: "google chrome",
    win32: "chrome",
    linux: ["google-chrome", "google-chrome-stable", "chromium"]
  }, {
    wsl: {
      ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
      x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
    }
  })), defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
    darwin: "firefox",
    win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
    linux: "firefox"
  }, {
    wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
  })), defineLazyProperty(apps, "edge", () => detectPlatformBinary({
    darwin: "microsoft edge",
    win32: "msedge",
    linux: ["microsoft-edge", "microsoft-edge-dev"]
  }, {
    wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
  })), open2.apps = apps, open2.openApp = openApp, open_1 = open2, open_1;
}
var openExports = requireOpen(), open = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(openExports);
const docsCommand = {
  name: "docs",
  helpText: "",
  signature: "docs",
  description: "Opens Sanity Studio documentation in your web browser",
  async action(args, context) {
    const { output } = context, { print } = output, url = "https://www.sanity.io/docs";
    print(`Opening ${url}`), await open(url);
  }
}, helpText$d = `
Options
  --port <port> Port to start emulator on
  --open Open dev server in a new browser tab

Examples
  # Start dev server on default port
  sanity functions dev

  # Start dev server on specific port
  sanity functions dev --port 3333

  # Start dev server and open a new browser tab
  sanity functions dev --open
`, defaultFlags$3 = {
  open: !1,
  port: 8080
}, devFunctionsCommand = {
  name: "dev",
  group: "functions",
  helpText: helpText$d,
  signature: "[--port <port> --open]",
  description: "Start the Sanity Function emulator",
  async action(args, context) {
    const { apiClient, output } = context, flags = { ...defaultFlags$3, ...args.extOptions }, { open: shouldOpen } = flags, client2 = apiClient({ requireUser: !0, requireProject: !1 }), { token: token2 } = client2.config();
    if (!token2) throw new Error("No API token found. Please run `sanity login`.");
    const { initBlueprintConfig } = await import("@sanity/runtime-cli/cores"), { functionDevCore } = await import("@sanity/runtime-cli/cores/functions"), cmdConfig = await initBlueprintConfig({
      bin: "sanity",
      log: (message) => output.print(message),
      token: token2
    });
    if (!cmdConfig.ok) throw new Error(cmdConfig.error);
    const { success, error: error2 } = await functionDevCore({
      ...cmdConfig.value,
      flags: {
        port: flags.port
      }
    });
    if (!success) throw new Error(error2);
    shouldOpen && open(`http://localhost:${flags.port}`);
  }
}, helpText$c = `
Commands
  add    Add or update an environment variable
  list   List the environment variables
  remove Remove an environment variable

Arguments
  <name> The name of the function
  <key> The name of the environment variable
  <value> The value of the environment variable

Examples
  # Add or update an environment variable
  sanity functions env add echo API_URL https://api.example.com/

  # Remove an environment variable
  sanity functions env remove echo API_URL

  # List environment variables
  sanity functions env list echo
`, envFunctionsCommand = {
  name: "env",
  group: "functions",
  helpText: helpText$c,
  signature: "<add|list|remove> <name> [key] [value]",
  description: "Add or remove an environment variable or list environment variables for a Sanity function",
  async action(args, context) {
    const { apiClient, output } = context, [subCommand, name, key2, value] = args.argsWithoutOptions;
    if (!subCommand || !["add", "list", "remove"].includes(subCommand))
      throw new Error("You must specify if you want to list, add or remove");
    if (subCommand === "add" && (!key2 || !value))
      throw new Error("You must specify the name, key and value arguments");
    if (subCommand === "remove" && !key2)
      throw new Error("You must specify the name and key arguments");
    const client2 = apiClient({
      requireUser: !0,
      requireProject: !1
    });
    if (!name)
      throw new Error("You must provide a function name as the first argument");
    const token2 = client2.config().token;
    if (!token2) throw new Error("No API token found. Please run `sanity login`.");
    const { initDeployedBlueprintConfig } = await import("@sanity/runtime-cli/cores"), { functionEnvAddCore, functionEnvListCore, functionEnvRemoveCore } = await import("@sanity/runtime-cli/cores/functions"), cmdConfig = await initDeployedBlueprintConfig({
      bin: "sanity",
      log: (message) => output.print(message),
      token: token2
    });
    if (!cmdConfig.ok) throw new Error(cmdConfig.error);
    let response;
    switch (subCommand) {
      case "add":
        response = await functionEnvAddCore({
          ...cmdConfig.value,
          args: { name, key: key2, value }
        });
        break;
      case "list":
        response = await functionEnvListCore({
          ...cmdConfig.value,
          args: { name }
        });
        break;
      case "remove":
        response = await functionEnvRemoveCore({
          ...cmdConfig.value,
          args: { name, key: key2 }
        });
        break;
      default:
        throw new Error(`Unknown subcommand: ${subCommand}`);
    }
    const { success, error: error2 } = response;
    if (!success) throw new Error(error2);
  }
}, functionsGroup = {
  name: "functions",
  signature: "[COMMAND]",
  isGroupRoot: !0,
  description: "Manage, test, and observe Sanity Functions"
}, helpText$b = `
Arguments
  <name> The name of the Function to retrieve logs for

Options
  --limit <limit> The number of log entries to retrieve [default 50]
  --json          If set return json
  --utc           Use UTC dates in logs
  --delete        Delete all logs for the Function
  --force         Force delete all logs for the Function
  --watch         Watch for new logs (streaming mode)

Examples
  # Retrieve logs for Sanity Function
  sanity functions logs echo

  # Retrieve the last two log entries for Sanity Function
  sanity functions logs echo --limit 2

  # Retrieve logs for Sanity Function in json format
  sanity functions logs echo --json

  # Delete all logs for Sanity Function
  sanity functions logs echo --delete

  # Watch for new logs (streaming mode)
  sanity functions logs echo --watch
`, defaultFlags$2 = {
  limit: 50,
  json: !1,
  utc: !1,
  delete: !1,
  force: !1,
  watch: !1
}, logsFunctionsCommand = {
  name: "logs",
  group: "functions",
  helpText: helpText$b,
  signature: "<name> [--limit <number>] [--json] [--utc] [--delete [--force]] [--watch]",
  description: "Retrieve or delete logs for a Sanity Function",
  async action(args, context) {
    const { apiClient, output } = context, [name] = args.argsWithoutOptions, flags = { ...defaultFlags$2, ...args.extOptions }, client2 = apiClient({
      requireUser: !0,
      requireProject: !1
    });
    if (!name)
      throw new Error("You must provide a function name as the first argument");
    const token2 = client2.config().token;
    if (!token2) throw new Error("No API token found. Please run `sanity login`.");
    const { initDeployedBlueprintConfig } = await import("@sanity/runtime-cli/cores"), { functionLogsCore } = await import("@sanity/runtime-cli/cores/functions"), cmdConfig = await initDeployedBlueprintConfig({
      bin: "sanity",
      log: (message) => output.print(message),
      token: token2
    });
    if (!cmdConfig.ok) throw new Error(cmdConfig.error);
    const { success, error: error2 } = await functionLogsCore({
      ...cmdConfig.value,
      args: { name },
      flags
    });
    if (!success) throw new Error(error2);
  }
}, helpText$a = `
Arguments
  <name> The name of the Sanity Function

Options
  --data <data> Data to send to the function
  --file <file> Read data from file and send to the function
  --document-id <id> Document to fetch and send to function
  --timeout <timeout> Execution timeout value in seconds
  --api <version> Sanity API Version to use
  --dataset <dataset> The Sanity dataset to use
  --project-id <id> Sanity Project ID to use
  --with-user-token Prime access token from CLI config into getCliClient()


Examples
  # Test function passing event data on command line
  sanity functions test echo --data '{ "id": 1 }'

  # Test function passing event data via a file
  sanity functions test echo --file 'payload.json'

  # Test function passing event data on command line and cap execution time to 60 seconds
  sanity functions test echo --data '{ "id": 1 }' --timeout 60
`, defaultFlags$1 = {
  timeout: 10,
  // seconds
  "with-user-token": !1
}, testFunctionsCommand = {
  name: "test",
  group: "functions",
  helpText: helpText$a,
  signature: "<name> [--data <json>] [--file <filename>] [--document-id <id>] [--timeout <seconds>] [--api <version>] [--dataset <name>] [--project-id] <id>] [--with-user-token]",
  description: "Invoke a local Sanity Function",
  async action(args, context) {
    const { apiClient, output, chalk: chalk2 } = context, [name] = args.argsWithoutOptions, flags = { ...defaultFlags$1, ...args.extOptions }, client2 = apiClient({
      requireUser: !0,
      requireProject: !1
    }), { dataset, projectId, token: token2 } = client2.config(), actualDataset = dataset === "~dummy-placeholder-dataset-" ? void 0 : dataset;
    if (!token2) throw new Error("No API token found. Please run `sanity login`.");
    if (!name)
      throw new Error("You must provide a function name as the first argument");
    const { initBlueprintConfig } = await import("@sanity/runtime-cli/cores"), { functionTestCore } = await import("@sanity/runtime-cli/cores/functions"), { blueprint } = await import("@sanity/runtime-cli/actions/blueprints"), { projectId: bpProjectId } = await blueprint.readLocalBlueprint();
    projectId && projectId !== bpProjectId && (output.print(
      chalk2.yellow("WARNING"),
      `Project ID ${chalk2.cyan(projectId)} in ${chalk2.green("sanity.cli.ts")} does not match Project ID ${chalk2.cyan(bpProjectId)} in ${chalk2.green("./sanity/blueprint.config.json")}.`
    ), output.print(
      `Defaulting to Project ID ${chalk2.cyan(bpProjectId)}. To override use the ${chalk2.green("--project-id")} flag.
`
    ));
    const cmdConfig = await initBlueprintConfig({
      bin: "sanity",
      log: (message) => output.print(message),
      token: token2
    });
    if (!cmdConfig.ok) throw new Error(cmdConfig.error);
    const { success, error: error2 } = await functionTestCore({
      ...cmdConfig.value,
      args: { name },
      flags: {
        data: flags.data,
        file: flags.file,
        "document-id": flags["document-id"],
        timeout: flags.timeout,
        api: flags.api,
        dataset: flags.dataset || actualDataset,
        "project-id": flags["project-id"] || bpProjectId,
        "with-user-token": flags["with-user-token"]
      }
    });
    if (!success) throw new Error(error2);
  }
};
var leven$1 = { exports: {} }, hasRequiredLeven;
function requireLeven() {
  if (hasRequiredLeven) return leven$1.exports;
  hasRequiredLeven = 1;
  const array = [], charCodeCache = [], leven2 = (left, right) => {
    if (left === right)
      return 0;
    const swap = left;
    left.length > right.length && (left = right, right = swap);
    let leftLength = left.length, rightLength = right.length;
    for (; leftLength > 0 && left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength); )
      leftLength--, rightLength--;
    let start = 0;
    for (; start < leftLength && left.charCodeAt(start) === right.charCodeAt(start); )
      start++;
    if (leftLength -= start, rightLength -= start, leftLength === 0)
      return rightLength;
    let bCharCode, result, temp, temp2, i = 0, j = 0;
    for (; i < leftLength; )
      charCodeCache[i] = left.charCodeAt(start + i), array[i] = ++i;
    for (; j < rightLength; )
      for (bCharCode = right.charCodeAt(start + j), temp = j++, result = j, i = 0; i < leftLength; i++)
        temp2 = bCharCode === charCodeCache[i] ? temp : temp + 1, temp = array[i], result = array[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
    return result;
  };
  return leven$1.exports = leven2, leven$1.exports.default = leven2, leven$1.exports;
}
var levenExports = requireLeven(), leven = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(levenExports);
const commonMistakes = { get: "list" }, levenThreshold = 3, coreCommands = [
  "build",
  "check",
  "configcheck",
  "cors",
  "dataset",
  "deploy",
  "dev",
  "documents",
  "exec",
  "graphql",
  "hook",
  "migration",
  "manifest",
  "preview",
  "schema",
  "start",
  "undeploy",
  "uninstall",
  "users"
], discouragedCommands = ["upgrade", "check", "configcheck", "uninstall"], helpText$9 = `
Run the command again within a Sanity project directory, where "sanity"
is installed as a dependency.`;
function getNoSuchCommandText(cmdName, parentGroupName, groups) {
  return parentGroupName && groups && groups[parentGroupName] ? suggestCommand(cmdName, groups[parentGroupName], parentGroupName) : coreCommands.includes(cmdName) ? `Command "${cmdName}" is not available outside of a Sanity project context.${helpText$9}` : suggestCommand(cmdName, groups ? groups.default : []);
}
function suggestCommand(cmdName, group, parentGroupName = null) {
  const closest = group.filter((command2) => !discouragedCommands.includes(command2.name)).map((command2) => leven(command2.name, cmdName)).reduce(
    (current, distance, index) => distance < current.distance ? { index, distance } : current,
    { index: 0, distance: 1 / 0 }
  );
  let suggestCmd = "";
  closest.distance <= levenThreshold && (suggestCmd = group[closest.index].name);
  const alternative = commonMistakes[cmdName];
  !suggestCmd && alternative && (suggestCmd = alternative);
  const input2 = chalk__default.default.cyan(`"${cmdName}"`), suggest = chalk__default.default.green(`"${suggestCmd}"`), help2 = chalk__default.default.cyan('"sanity --help"'), didYouMean = suggestCmd ? `Did you mean ${suggest}? ` : " ";
  return parentGroupName ? `${input2} is not a subcommand of "sanity ${parentGroupName}". ${didYouMean}See ${help2}` : `${input2} is not a sanity command. ${didYouMean}See ${help2}`;
}
function generateCommandsDocumentation(commandGroups, group = "default") {
  const commandGroup = commandGroups[group], commands = commandGroup && commandGroup.filter((cmd) => !cmd.hideFromHelp);
  if (!commands || commands.length === 0)
    throw new Error(getNoSuchCommandText(group));
  const cmdLength = commands.reduce((max2, cmd) => Math.max(cmd.name.length, max2), 0), prefix = group === "default" ? "" : ` ${group}`;
  return [
    `usage: npx sanity${prefix} [--default] [-v|--version] [-d|--debug] [-h|--help] <command> [<args>]`,
    "",
    "Commands:"
  ].concat(commands.map((cmd) => `   ${lodashExports.padEnd(cmd.name, cmdLength + 1)} ${cmd.description}`)).concat([
    "",
    `See 'npx sanity help${prefix} <command>' for specific information on a subcommand.`
  ]).join(`
`);
}
function generateCommandDocumentation(command2, group, subCommand) {
  if (!command2)
    throw new Error(
      subCommand ? `"${subCommand}" is not a subcommand of "${group}". See 'npx sanity help ${group}'` : getNoSuchCommandText(group || command2)
    );
  return [
    `usage: npx sanity ${[group || command2.name, subCommand].filter(Boolean).join(" ")} ${command2.signature}`,
    "",
    `   ${command2.description}`,
    "",
    (command2.helpText || "").trim()
  ].join(`
`);
}
function isCommandGroup(cmdOrGroup) {
  return "isGroupRoot" in cmdOrGroup;
}
const showHelpAction = async (args, context) => {
  const [commandName, subCommandName] = args.argsWithoutOptions, { commandGroups } = context.commandRunner;
  if (!commandName) {
    loadEnv.debug('No command given to "help", showing generate Sanity CLI help'), context.output.print(generateCommandsDocumentation(commandGroups));
    return;
  }
  const defaultCommand = commandGroups.default.find((cmd) => cmd.name === commandName);
  if (defaultCommand && !isCommandGroup(defaultCommand)) {
    loadEnv.debug(`Found command in default group with name "${commandName}"`), context.output.print(generateCommandDocumentation(defaultCommand));
    return;
  }
  const group = commandGroups[commandName];
  if (!subCommandName && !group)
    throw loadEnv.debug(`No subcommand given, and we couldn't find a group with name "${group}"`), new Error(getNoSuchCommandText(commandName, null, commandGroups));
  if (!subCommandName && group) {
    loadEnv.debug(`No subcommand given, but found group with name "${commandName}"`), context.output.print(generateCommandsDocumentation(commandGroups, commandName));
    return;
  }
  if (subCommandName && !group)
    throw loadEnv.debug(`Subcommand given, but couldn't find group with name "${commandName}"`), new Error(getNoSuchCommandText(subCommandName, commandName, commandGroups));
  const subCommand = context.commandRunner.resolveSubcommand(group, subCommandName, commandName);
  if (!subCommand)
    throw loadEnv.debug(`Subcommand given, but not found in group "${commandName}"`), new Error(getNoSuchCommandText(subCommandName, commandName, commandGroups));
  loadEnv.debug('Subcommand "%s" for group "%s" found, showing help', subCommandName, commandName), isCommandGroup(subCommand.command) || context.output.print(
    generateCommandDocumentation(subCommand.command, commandName, subCommandName)
  );
}, help$1 = `
With no options and no COMMAND given, the synopsis of the sanity command and a
list of the most commonly used commands are printed on the standard output.

If a command is given, the help page for that command is printed to standard
output. This will usually be more in-depth than the brief description shown in
the command list.
`, command$1 = {
  name: "help",
  signature: "[COMMAND]",
  description: "Displays help information about Sanity CLI commands",
  action: showHelpAction,
  helpText: help$1
};
var frameworks = {}, readConfigFile = {}, jsYaml$4 = {}, loader$2 = {}, common$3 = {}, hasRequiredCommon$3;
function requireCommon$3() {
  if (hasRequiredCommon$3) return common$3;
  hasRequiredCommon$3 = 1;
  function isNothing(subject) {
    return typeof subject > "u" || subject === null;
  }
  function isObject2(subject) {
    return typeof subject == "object" && subject !== null;
  }
  function toArray2(sequence) {
    return Array.isArray(sequence) ? sequence : isNothing(sequence) ? [] : [sequence];
  }
  function extend(target, source2) {
    var index, length, key2, sourceKeys;
    if (source2)
      for (sourceKeys = Object.keys(source2), index = 0, length = sourceKeys.length; index < length; index += 1)
        key2 = sourceKeys[index], target[key2] = source2[key2];
    return target;
  }
  function repeat2(string, count2) {
    var result = "", cycle;
    for (cycle = 0; cycle < count2; cycle += 1)
      result += string;
    return result;
  }
  function isNegativeZero(number2) {
    return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
  }
  return common$3.isNothing = isNothing, common$3.isObject = isObject2, common$3.toArray = toArray2, common$3.repeat = repeat2, common$3.isNegativeZero = isNegativeZero, common$3.extend = extend, common$3;
}
var exception$2, hasRequiredException$2;
function requireException$2() {
  if (hasRequiredException$2) return exception$2;
  hasRequiredException$2 = 1;
  function YAMLException(reason, mark2) {
    Error.call(this), this.name = "YAMLException", this.reason = reason, this.mark = mark2, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
  }
  return YAMLException.prototype = Object.create(Error.prototype), YAMLException.prototype.constructor = YAMLException, YAMLException.prototype.toString = function(compact) {
    var result = this.name + ": ";
    return result += this.reason || "(unknown reason)", !compact && this.mark && (result += " " + this.mark.toString()), result;
  }, exception$2 = YAMLException, exception$2;
}
var mark$1, hasRequiredMark$1;
function requireMark$1() {
  if (hasRequiredMark$1) return mark$1;
  hasRequiredMark$1 = 1;
  var common2 = requireCommon$3();
  function Mark(name, buffer2, position, line3, column2) {
    this.name = name, this.buffer = buffer2, this.position = position, this.line = line3, this.column = column2;
  }
  return Mark.prototype.getSnippet = function(indent, maxLength) {
    var head, start, tail, end, snippet2;
    if (!this.buffer) return null;
    for (indent = indent || 4, maxLength = maxLength || 75, head = "", start = this.position; start > 0 && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(start - 1)) === -1; )
      if (start -= 1, this.position - start > maxLength / 2 - 1) {
        head = " ... ", start += 5;
        break;
      }
    for (tail = "", end = this.position; end < this.buffer.length && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(end)) === -1; )
      if (end += 1, end - this.position > maxLength / 2 - 1) {
        tail = " ... ", end -= 5;
        break;
      }
    return snippet2 = this.buffer.slice(start, end), common2.repeat(" ", indent) + head + snippet2 + tail + `
` + common2.repeat(" ", indent + this.position - start + head.length) + "^";
  }, Mark.prototype.toString = function(compact) {
    var snippet2, where = "";
    return this.name && (where += 'in "' + this.name + '" '), where += "at line " + (this.line + 1) + ", column " + (this.column + 1), compact || (snippet2 = this.getSnippet(), snippet2 && (where += `:
` + snippet2)), where;
  }, mark$1 = Mark, mark$1;
}
var type$2, hasRequiredType$2;
function requireType$2() {
  if (hasRequiredType$2) return type$2;
  hasRequiredType$2 = 1;
  var YAMLException = requireException$2(), TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "defaultStyle",
    "styleAliases"
  ], YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map2) {
    var result = {};
    return map2 !== null && Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    }), result;
  }
  function Type(tag, options2) {
    if (options2 = options2 || {}, Object.keys(options2).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1)
        throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }), this.tag = tag, this.kind = options2.kind || null, this.resolve = options2.resolve || function() {
      return !0;
    }, this.construct = options2.construct || function(data) {
      return data;
    }, this.instanceOf = options2.instanceOf || null, this.predicate = options2.predicate || null, this.represent = options2.represent || null, this.defaultStyle = options2.defaultStyle || null, this.styleAliases = compileStyleAliases(options2.styleAliases || null), YAML_NODE_KINDS.indexOf(this.kind) === -1)
      throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
  return type$2 = Type, type$2;
}
var schema$2, hasRequiredSchema$2;
function requireSchema$2() {
  if (hasRequiredSchema$2) return schema$2;
  hasRequiredSchema$2 = 1;
  var common2 = requireCommon$3(), YAMLException = requireException$2(), Type = requireType$2();
  function compileList(schema2, name, result) {
    var exclude = [];
    return schema2.include.forEach(function(includedSchema) {
      result = compileList(includedSchema, name, result);
    }), schema2[name].forEach(function(currentType) {
      result.forEach(function(previousType, previousIndex) {
        previousType.tag === currentType.tag && previousType.kind === currentType.kind && exclude.push(previousIndex);
      }), result.push(currentType);
    }), result.filter(function(type2, index) {
      return exclude.indexOf(index) === -1;
    });
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {}
    }, index, length;
    function collectType(type2) {
      result[type2.kind][type2.tag] = result.fallback[type2.tag] = type2;
    }
    for (index = 0, length = arguments.length; index < length; index += 1)
      arguments[index].forEach(collectType);
    return result;
  }
  function Schema(definition) {
    this.include = definition.include || [], this.implicit = definition.implicit || [], this.explicit = definition.explicit || [], this.implicit.forEach(function(type2) {
      if (type2.loadKind && type2.loadKind !== "scalar")
        throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }), this.compiledImplicit = compileList(this, "implicit", []), this.compiledExplicit = compileList(this, "explicit", []), this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
  }
  return Schema.DEFAULT = null, Schema.create = function() {
    var schemas, types2;
    switch (arguments.length) {
      case 1:
        schemas = Schema.DEFAULT, types2 = arguments[0];
        break;
      case 2:
        schemas = arguments[0], types2 = arguments[1];
        break;
      default:
        throw new YAMLException("Wrong number of arguments for Schema.create function");
    }
    if (schemas = common2.toArray(schemas), types2 = common2.toArray(types2), !schemas.every(function(schema2) {
      return schema2 instanceof Schema;
    }))
      throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
    if (!types2.every(function(type2) {
      return type2 instanceof Type;
    }))
      throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    return new Schema({
      include: schemas,
      explicit: types2
    });
  }, schema$2 = Schema, schema$2;
}
var str$2, hasRequiredStr$2;
function requireStr$2() {
  if (hasRequiredStr$2) return str$2;
  hasRequiredStr$2 = 1;
  var Type = requireType$2();
  return str$2 = new Type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  }), str$2;
}
var seq$2, hasRequiredSeq$2;
function requireSeq$2() {
  if (hasRequiredSeq$2) return seq$2;
  hasRequiredSeq$2 = 1;
  var Type = requireType$2();
  return seq$2 = new Type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  }), seq$2;
}
var map$3, hasRequiredMap$2;
function requireMap$2() {
  if (hasRequiredMap$2) return map$3;
  hasRequiredMap$2 = 1;
  var Type = requireType$2();
  return map$3 = new Type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  }), map$3;
}
var failsafe$2, hasRequiredFailsafe$2;
function requireFailsafe$2() {
  if (hasRequiredFailsafe$2) return failsafe$2;
  hasRequiredFailsafe$2 = 1;
  var Schema = requireSchema$2();
  return failsafe$2 = new Schema({
    explicit: [
      requireStr$2(),
      requireSeq$2(),
      requireMap$2()
    ]
  }), failsafe$2;
}
var _null$2, hasRequired_null$2;
function require_null$2() {
  if (hasRequired_null$2) return _null$2;
  hasRequired_null$2 = 1;
  var Type = requireType$2();
  function resolveYamlNull(data) {
    if (data === null) return !0;
    var max2 = data.length;
    return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  return _null$2 = new Type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      }
    },
    defaultStyle: "lowercase"
  }), _null$2;
}
var bool$2, hasRequiredBool$2;
function requireBool$2() {
  if (hasRequiredBool$2) return bool$2;
  hasRequiredBool$2 = 1;
  var Type = requireType$2();
  function resolveYamlBoolean(data) {
    if (data === null) return !1;
    var max2 = data.length;
    return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  return bool$2 = new Type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  }), bool$2;
}
var int$2, hasRequiredInt$2;
function requireInt$2() {
  if (hasRequiredInt$2) return int$2;
  hasRequiredInt$2 = 1;
  var common2 = requireCommon$3(), Type = requireType$2();
  function isHexCode(c2) {
    return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
  }
  function isOctCode(c2) {
    return 48 <= c2 && c2 <= 55;
  }
  function isDecCode(c2) {
    return 48 <= c2 && c2 <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null) return !1;
    var max2 = data.length, index = 0, hasDigits = !1, ch;
    if (!max2) return !1;
    if (ch = data[index], (ch === "-" || ch === "+") && (ch = data[++index]), ch === "0") {
      if (index + 1 === max2) return !0;
      if (ch = data[++index], ch === "b") {
        for (index++; index < max2; index++)
          if (ch = data[index], ch !== "_") {
            if (ch !== "0" && ch !== "1") return !1;
            hasDigits = !0;
          }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        for (index++; index < max2; index++)
          if (ch = data[index], ch !== "_") {
            if (!isHexCode(data.charCodeAt(index))) return !1;
            hasDigits = !0;
          }
        return hasDigits && ch !== "_";
      }
      for (; index < max2; index++)
        if (ch = data[index], ch !== "_") {
          if (!isOctCode(data.charCodeAt(index))) return !1;
          hasDigits = !0;
        }
      return hasDigits && ch !== "_";
    }
    if (ch === "_") return !1;
    for (; index < max2; index++)
      if (ch = data[index], ch !== "_") {
        if (ch === ":") break;
        if (!isDecCode(data.charCodeAt(index)))
          return !1;
        hasDigits = !0;
      }
    return !hasDigits || ch === "_" ? !1 : ch !== ":" ? !0 : /^(:[0-5]?[0-9])+$/.test(data.slice(index));
  }
  function constructYamlInteger(data) {
    var value = data, sign2 = 1, ch, base2, digits = [];
    return value.indexOf("_") !== -1 && (value = value.replace(/_/g, "")), ch = value[0], (ch === "-" || ch === "+") && (ch === "-" && (sign2 = -1), value = value.slice(1), ch = value[0]), value === "0" ? 0 : ch === "0" ? value[1] === "b" ? sign2 * parseInt(value.slice(2), 2) : value[1] === "x" ? sign2 * parseInt(value, 16) : sign2 * parseInt(value, 8) : value.indexOf(":") !== -1 ? (value.split(":").forEach(function(v) {
      digits.unshift(parseInt(v, 10));
    }), value = 0, base2 = 1, digits.forEach(function(d) {
      value += d * base2, base2 *= 60;
    }), sign2 * value) : sign2 * parseInt(value, 10);
  }
  function isInteger2(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common2.isNegativeZero(object);
  }
  return int$2 = new Type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger2,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  }), int$2;
}
var float$2, hasRequiredFloat$2;
function requireFloat$2() {
  if (hasRequiredFloat$2) return float$2;
  hasRequiredFloat$2 = 1;
  var common2 = requireCommon$3(), Type = requireType$2(), YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function resolveYamlFloat(data) {
    return !(data === null || !YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_");
  }
  function constructYamlFloat(data) {
    var value, sign2, base2, digits;
    return value = data.replace(/_/g, "").toLowerCase(), sign2 = value[0] === "-" ? -1 : 1, digits = [], "+-".indexOf(value[0]) >= 0 && (value = value.slice(1)), value === ".inf" ? sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : value === ".nan" ? NaN : value.indexOf(":") >= 0 ? (value.split(":").forEach(function(v) {
      digits.unshift(parseFloat(v, 10));
    }), value = 0, base2 = 1, digits.forEach(function(d) {
      value += d * base2, base2 *= 60;
    }), sign2 * value) : sign2 * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object))
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    else if (Number.POSITIVE_INFINITY === object)
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    else if (Number.NEGATIVE_INFINITY === object)
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    else if (common2.isNegativeZero(object))
      return "-0.0";
    return res = object.toString(10), SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat2(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common2.isNegativeZero(object));
  }
  return float$2 = new Type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat2,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  }), float$2;
}
var json$2, hasRequiredJson$2;
function requireJson$2() {
  if (hasRequiredJson$2) return json$2;
  hasRequiredJson$2 = 1;
  var Schema = requireSchema$2();
  return json$2 = new Schema({
    include: [
      requireFailsafe$2()
    ],
    implicit: [
      require_null$2(),
      requireBool$2(),
      requireInt$2(),
      requireFloat$2()
    ]
  }), json$2;
}
var core$5, hasRequiredCore$5;
function requireCore$5() {
  if (hasRequiredCore$5) return core$5;
  hasRequiredCore$5 = 1;
  var Schema = requireSchema$2();
  return core$5 = new Schema({
    include: [
      requireJson$2()
    ]
  }), core$5;
}
var timestamp$3, hasRequiredTimestamp$2;
function requireTimestamp$2() {
  if (hasRequiredTimestamp$2) return timestamp$3;
  hasRequiredTimestamp$2 = 1;
  var Type = requireType$2(), YAML_DATE_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  ), YAML_TIMESTAMP_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function resolveYamlTimestamp(data) {
    return data === null ? !1 : YAML_DATE_REGEXP.exec(data) !== null || YAML_TIMESTAMP_REGEXP.exec(data) !== null;
  }
  function constructYamlTimestamp(data) {
    var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    if (match2 = YAML_DATE_REGEXP.exec(data), match2 === null && (match2 = YAML_TIMESTAMP_REGEXP.exec(data)), match2 === null) throw new Error("Date resolve error");
    if (year = +match2[1], month = +match2[2] - 1, day = +match2[3], !match2[4])
      return new Date(Date.UTC(year, month, day));
    if (hour = +match2[4], minute = +match2[5], second = +match2[6], match2[7]) {
      for (fraction = match2[7].slice(0, 3); fraction.length < 3; )
        fraction += "0";
      fraction = +fraction;
    }
    return match2[9] && (tz_hour = +match2[10], tz_minute = +(match2[11] || 0), delta = (tz_hour * 60 + tz_minute) * 6e4, match2[9] === "-" && (delta = -delta)), date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction)), delta && date.setTime(date.getTime() - delta), date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  return timestamp$3 = new Type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  }), timestamp$3;
}
var merge$4, hasRequiredMerge$2;
function requireMerge$2() {
  if (hasRequiredMerge$2) return merge$4;
  hasRequiredMerge$2 = 1;
  var Type = requireType$2();
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  return merge$4 = new Type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  }), merge$4;
}
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var binary$3, hasRequiredBinary$2;
function requireBinary$2() {
  if (hasRequiredBinary$2) return binary$3;
  hasRequiredBinary$2 = 1;
  var NodeBuffer;
  try {
    var _require = commonjsRequire;
    NodeBuffer = _require("buffer").Buffer;
  } catch {
  }
  var Type = requireType$2(), BASE64_MAP = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function resolveYamlBinary(data) {
    if (data === null) return !1;
    var code, idx, bitlen = 0, max2 = data.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++)
      if (code = map2.indexOf(data.charAt(idx)), !(code > 64)) {
        if (code < 0) return !1;
        bitlen += 6;
      }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input2 = data.replace(/[\r\n=]/g, ""), max2 = input2.length, map2 = BASE64_MAP, bits = 0, result = [];
    for (idx = 0; idx < max2; idx++)
      idx % 4 === 0 && idx && (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)), bits = bits << 6 | map2.indexOf(input2.charAt(idx));
    return tailbits = max2 % 4 * 6, tailbits === 0 ? (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)) : tailbits === 18 ? (result.push(bits >> 10 & 255), result.push(bits >> 2 & 255)) : tailbits === 12 && result.push(bits >> 4 & 255), NodeBuffer ? NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result) : result;
  }
  function representYamlBinary(object) {
    var result = "", bits = 0, idx, tail, max2 = object.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++)
      idx % 3 === 0 && idx && (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]), bits = (bits << 8) + object[idx];
    return tail = max2 % 3, tail === 0 ? (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]) : tail === 2 ? (result += map2[bits >> 10 & 63], result += map2[bits >> 4 & 63], result += map2[bits << 2 & 63], result += map2[64]) : tail === 1 && (result += map2[bits >> 2 & 63], result += map2[bits << 4 & 63], result += map2[64], result += map2[64]), result;
  }
  function isBinary(object) {
    return NodeBuffer && NodeBuffer.isBuffer(object);
  }
  return binary$3 = new Type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  }), binary$3;
}
var omap$2, hasRequiredOmap$2;
function requireOmap$2() {
  if (hasRequiredOmap$2) return omap$2;
  hasRequiredOmap$2 = 1;
  var Type = requireType$2(), _hasOwnProperty = Object.prototype.hasOwnProperty, _toString = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null) return !0;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for (index = 0, length = object.length; index < length; index += 1) {
      if (pair = object[index], pairHasKey = !1, _toString.call(pair) !== "[object Object]") return !1;
      for (pairKey in pair)
        if (_hasOwnProperty.call(pair, pairKey))
          if (!pairHasKey) pairHasKey = !0;
          else return !1;
      if (!pairHasKey) return !1;
      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return !1;
    }
    return !0;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  return omap$2 = new Type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  }), omap$2;
}
var pairs$3, hasRequiredPairs$2;
function requirePairs$2() {
  if (hasRequiredPairs$2) return pairs$3;
  hasRequiredPairs$2 = 1;
  var Type = requireType$2(), _toString = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null) return !0;
    var index, length, pair, keys, result, object = data;
    for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1) {
      if (pair = object[index], _toString.call(pair) !== "[object Object]" || (keys = Object.keys(pair), keys.length !== 1)) return !1;
      result[index] = [keys[0], pair[keys[0]]];
    }
    return !0;
  }
  function constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair, keys, result, object = data;
    for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1)
      pair = object[index], keys = Object.keys(pair), result[index] = [keys[0], pair[keys[0]]];
    return result;
  }
  return pairs$3 = new Type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  }), pairs$3;
}
var set$2, hasRequiredSet$2;
function requireSet$2() {
  if (hasRequiredSet$2) return set$2;
  hasRequiredSet$2 = 1;
  var Type = requireType$2(), _hasOwnProperty = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null) return !0;
    var key2, object = data;
    for (key2 in object)
      if (_hasOwnProperty.call(object, key2) && object[key2] !== null)
        return !1;
    return !0;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  return set$2 = new Type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  }), set$2;
}
var default_safe$1, hasRequiredDefault_safe$1;
function requireDefault_safe$1() {
  if (hasRequiredDefault_safe$1) return default_safe$1;
  hasRequiredDefault_safe$1 = 1;
  var Schema = requireSchema$2();
  return default_safe$1 = new Schema({
    include: [
      requireCore$5()
    ],
    implicit: [
      requireTimestamp$2(),
      requireMerge$2()
    ],
    explicit: [
      requireBinary$2(),
      requireOmap$2(),
      requirePairs$2(),
      requireSet$2()
    ]
  }), default_safe$1;
}
var _undefined$1, hasRequired_undefined$1;
function require_undefined$1() {
  if (hasRequired_undefined$1) return _undefined$1;
  hasRequired_undefined$1 = 1;
  var Type = requireType$2();
  function resolveJavascriptUndefined() {
    return !0;
  }
  function constructJavascriptUndefined() {
  }
  function representJavascriptUndefined() {
    return "";
  }
  function isUndefined(object) {
    return typeof object > "u";
  }
  return _undefined$1 = new Type("tag:yaml.org,2002:js/undefined", {
    kind: "scalar",
    resolve: resolveJavascriptUndefined,
    construct: constructJavascriptUndefined,
    predicate: isUndefined,
    represent: representJavascriptUndefined
  }), _undefined$1;
}
var regexp$1, hasRequiredRegexp$1;
function requireRegexp$1() {
  if (hasRequiredRegexp$1) return regexp$1;
  hasRequiredRegexp$1 = 1;
  var Type = requireType$2();
  function resolveJavascriptRegExp(data) {
    if (data === null || data.length === 0) return !1;
    var regexp2 = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    return !(regexp2[0] === "/" && (tail && (modifiers = tail[1]), modifiers.length > 3 || regexp2[regexp2.length - modifiers.length - 1] !== "/"));
  }
  function constructJavascriptRegExp(data) {
    var regexp2 = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    return regexp2[0] === "/" && (tail && (modifiers = tail[1]), regexp2 = regexp2.slice(1, regexp2.length - modifiers.length - 1)), new RegExp(regexp2, modifiers);
  }
  function representJavascriptRegExp(object) {
    var result = "/" + object.source + "/";
    return object.global && (result += "g"), object.multiline && (result += "m"), object.ignoreCase && (result += "i"), result;
  }
  function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
  }
  return regexp$1 = new Type("tag:yaml.org,2002:js/regexp", {
    kind: "scalar",
    resolve: resolveJavascriptRegExp,
    construct: constructJavascriptRegExp,
    predicate: isRegExp,
    represent: representJavascriptRegExp
  }), regexp$1;
}
var _function$1, hasRequired_function$1;
function require_function$1() {
  if (hasRequired_function$1) return _function$1;
  hasRequired_function$1 = 1;
  var esprima2;
  try {
    var _require = commonjsRequire;
    esprima2 = _require("esprima");
  } catch {
    typeof window < "u" && (esprima2 = window.esprima);
  }
  var Type = requireType$2();
  function resolveJavascriptFunction(data) {
    if (data === null) return !1;
    try {
      var source2 = "(" + data + ")", ast = esprima2.parse(source2, { range: !0 });
      return !(ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression");
    } catch {
      return !1;
    }
  }
  function constructJavascriptFunction(data) {
    var source2 = "(" + data + ")", ast = esprima2.parse(source2, { range: !0 }), params = [], body;
    if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression")
      throw new Error("Failed to resolve function");
    return ast.body[0].expression.params.forEach(function(param) {
      params.push(param.name);
    }), body = ast.body[0].expression.body.range, ast.body[0].expression.body.type === "BlockStatement" ? new Function(params, source2.slice(body[0] + 1, body[1] - 1)) : new Function(params, "return " + source2.slice(body[0], body[1]));
  }
  function representJavascriptFunction(object) {
    return object.toString();
  }
  function isFunction2(object) {
    return Object.prototype.toString.call(object) === "[object Function]";
  }
  return _function$1 = new Type("tag:yaml.org,2002:js/function", {
    kind: "scalar",
    resolve: resolveJavascriptFunction,
    construct: constructJavascriptFunction,
    predicate: isFunction2,
    represent: representJavascriptFunction
  }), _function$1;
}
var default_full$1, hasRequiredDefault_full$1;
function requireDefault_full$1() {
  if (hasRequiredDefault_full$1) return default_full$1;
  hasRequiredDefault_full$1 = 1;
  var Schema = requireSchema$2();
  return default_full$1 = Schema.DEFAULT = new Schema({
    include: [
      requireDefault_safe$1()
    ],
    explicit: [
      require_undefined$1(),
      requireRegexp$1(),
      require_function$1()
    ]
  }), default_full$1;
}
var hasRequiredLoader$2;
function requireLoader$2() {
  if (hasRequiredLoader$2) return loader$2;
  hasRequiredLoader$2 = 1;
  var common2 = requireCommon$3(), YAMLException = requireException$2(), Mark = requireMark$1(), DEFAULT_SAFE_SCHEMA = requireDefault_safe$1(), DEFAULT_FULL_SCHEMA = requireDefault_full$1(), _hasOwnProperty = Object.prototype.hasOwnProperty, CONTEXT_FLOW_IN = 1, CONTEXT_FLOW_OUT = 2, CONTEXT_BLOCK_IN = 3, CONTEXT_BLOCK_OUT = 4, CHOMPING_CLIP = 1, CHOMPING_STRIP = 2, CHOMPING_KEEP = 3, PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/, PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/, PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i, PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c2) {
    return c2 === 10 || c2 === 13;
  }
  function is_WHITE_SPACE(c2) {
    return c2 === 9 || c2 === 32;
  }
  function is_WS_OR_EOL(c2) {
    return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
  }
  function is_FLOW_INDICATOR(c2) {
    return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
  }
  function fromHexCode(c2) {
    var lc;
    return 48 <= c2 && c2 <= 57 ? c2 - 48 : (lc = c2 | 32, 97 <= lc && lc <= 102 ? lc - 97 + 10 : -1);
  }
  function escapedHexLen(c2) {
    return c2 === 120 ? 2 : c2 === 117 ? 4 : c2 === 85 ? 8 : 0;
  }
  function fromDecimalCode(c2) {
    return 48 <= c2 && c2 <= 57 ? c2 - 48 : -1;
  }
  function simpleEscapeSequence(c2) {
    return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 || c2 === 9 ? "	" : c2 === 110 ? `
` : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c2) {
    return c2 <= 65535 ? String.fromCharCode(c2) : String.fromCharCode(
      (c2 - 65536 >> 10) + 55296,
      (c2 - 65536 & 1023) + 56320
    );
  }
  for (var simpleEscapeCheck = new Array(256), simpleEscapeMap = new Array(256), i = 0; i < 256; i++)
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0, simpleEscapeMap[i] = simpleEscapeSequence(i);
  function State(input2, options2) {
    this.input = input2, this.filename = options2.filename || null, this.schema = options2.schema || DEFAULT_FULL_SCHEMA, this.onWarning = options2.onWarning || null, this.legacy = options2.legacy || !1, this.json = options2.json || !1, this.listener = options2.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = input2.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
  }
  function generateError(state, message) {
    return new YAMLException(
      message,
      new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart)
    );
  }
  function throwError2(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    state.onWarning && state.onWarning.call(null, generateError(state, message));
  }
  var directiveHandlers = {
    YAML: function(state, name, args) {
      var match2, major2, minor2;
      state.version !== null && throwError2(state, "duplication of %YAML directive"), args.length !== 1 && throwError2(state, "YAML directive accepts exactly one argument"), match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]), match2 === null && throwError2(state, "ill-formed argument of the YAML directive"), major2 = parseInt(match2[1], 10), minor2 = parseInt(match2[2], 10), major2 !== 1 && throwError2(state, "unacceptable YAML version of the document"), state.version = args[0], state.checkLineBreaks = minor2 < 2, minor2 !== 1 && minor2 !== 2 && throwWarning(state, "unsupported YAML version of the document");
    },
    TAG: function(state, name, args) {
      var handle, prefix;
      args.length !== 2 && throwError2(state, "TAG directive accepts exactly two arguments"), handle = args[0], prefix = args[1], PATTERN_TAG_HANDLE.test(handle) || throwError2(state, "ill-formed tag handle (first argument) of the TAG directive"), _hasOwnProperty.call(state.tagMap, handle) && throwError2(state, 'there is a previously declared suffix for "' + handle + '" tag handle'), PATTERN_TAG_URI.test(prefix) || throwError2(state, "ill-formed tag prefix (second argument) of the TAG directive"), state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      if (_result = state.input.slice(start, end), checkJson)
        for (_position = 0, _length = _result.length; _position < _length; _position += 1)
          _character = _result.charCodeAt(_position), _character === 9 || 32 <= _character && _character <= 1114111 || throwError2(state, "expected valid JSON character");
      else PATTERN_NON_PRINTABLE.test(_result) && throwError2(state, "the stream contains non-printable characters");
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source2, overridableKeys) {
    var sourceKeys, key2, index, quantity;
    for (common2.isObject(source2) || throwError2(state, "cannot merge mappings; the provided source object is unacceptable"), sourceKeys = Object.keys(source2), index = 0, quantity = sourceKeys.length; index < quantity; index += 1)
      key2 = sourceKeys[index], _hasOwnProperty.call(destination, key2) || (destination[key2] = source2[key2], overridableKeys[key2] = !0);
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode))
      for (keyNode = Array.prototype.slice.call(keyNode), index = 0, quantity = keyNode.length; index < quantity; index += 1)
        Array.isArray(keyNode[index]) && throwError2(state, "nested arrays are not supported inside keys"), typeof keyNode == "object" && _class(keyNode[index]) === "[object Object]" && (keyNode[index] = "[object Object]");
    if (typeof keyNode == "object" && _class(keyNode) === "[object Object]" && (keyNode = "[object Object]"), keyNode = String(keyNode), _result === null && (_result = {}), keyTag === "tag:yaml.org,2002:merge")
      if (Array.isArray(valueNode))
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1)
          mergeMappings(state, _result, valueNode[index], overridableKeys);
      else
        mergeMappings(state, _result, valueNode, overridableKeys);
    else
      !state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode) && (state.line = startLine || state.line, state.position = startPos || state.position, throwError2(state, "duplicated mapping key")), _result[keyNode] = valueNode, delete overridableKeys[keyNode];
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position), ch === 10 ? state.position++ : ch === 13 ? (state.position++, state.input.charCodeAt(state.position) === 10 && state.position++) : throwError2(state, "a line break is expected"), state.line += 1, state.lineStart = state.position;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    for (var lineBreaks = 0, ch = state.input.charCodeAt(state.position); ch !== 0; ) {
      for (; is_WHITE_SPACE(ch); )
        ch = state.input.charCodeAt(++state.position);
      if (allowComments && ch === 35)
        do
          ch = state.input.charCodeAt(++state.position);
        while (ch !== 10 && ch !== 13 && ch !== 0);
      if (is_EOL(ch))
        for (readLineBreak(state), ch = state.input.charCodeAt(state.position), lineBreaks++, state.lineIndent = 0; ch === 32; )
          state.lineIndent++, ch = state.input.charCodeAt(++state.position);
      else
        break;
    }
    return checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent && throwWarning(state, "deficient indentation"), lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch;
    return ch = state.input.charCodeAt(_position), !!((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2) && (_position += 3, ch = state.input.charCodeAt(_position), ch === 0 || is_WS_OR_EOL(ch)));
  }
  function writeFoldedLines(state, count2) {
    count2 === 1 ? state.result += " " : count2 > 1 && (state.result += common2.repeat(`
`, count2 - 1));
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    if (ch = state.input.charCodeAt(state.position), is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96 || (ch === 63 || ch === 45) && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)))
      return !1;
    for (state.kind = "scalar", state.result = "", captureStart = captureEnd = state.position, hasPendingContent = !1; ch !== 0; ) {
      if (ch === 58) {
        if (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following))
          break;
      } else if (ch === 35) {
        if (preceding = state.input.charCodeAt(state.position - 1), is_WS_OR_EOL(preceding))
          break;
      } else {
        if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch))
          break;
        if (is_EOL(ch))
          if (_line = state.line, _lineStart = state.lineStart, _lineIndent = state.lineIndent, skipSeparationSpace(state, !1, -1), state.lineIndent >= nodeIndent) {
            hasPendingContent = !0, ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd, state.line = _line, state.lineStart = _lineStart, state.lineIndent = _lineIndent;
            break;
          }
      }
      hasPendingContent && (captureSegment(state, captureStart, captureEnd, !1), writeFoldedLines(state, state.line - _line), captureStart = captureEnd = state.position, hasPendingContent = !1), is_WHITE_SPACE(ch) || (captureEnd = state.position + 1), ch = state.input.charCodeAt(++state.position);
    }
    return captureSegment(state, captureStart, captureEnd, !1), state.result ? !0 : (state.kind = _kind, state.result = _result, !1);
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    if (ch = state.input.charCodeAt(state.position), ch !== 39)
      return !1;
    for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; )
      if (ch === 39)
        if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), ch === 39)
          captureStart = state.position, state.position++, captureEnd = state.position;
        else
          return !0;
      else is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError2(state, "unexpected end of the document within a single quoted scalar") : (state.position++, captureEnd = state.position);
    throwError2(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp2, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 34)
      return !1;
    for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; ) {
      if (ch === 34)
        return captureSegment(state, captureStart, state.position, !0), state.position++, !0;
      if (ch === 92) {
        if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), is_EOL(ch))
          skipSeparationSpace(state, !1, nodeIndent);
        else if (ch < 256 && simpleEscapeCheck[ch])
          state.result += simpleEscapeMap[ch], state.position++;
        else if ((tmp2 = escapedHexLen(ch)) > 0) {
          for (hexLength = tmp2, hexResult = 0; hexLength > 0; hexLength--)
            ch = state.input.charCodeAt(++state.position), (tmp2 = fromHexCode(ch)) >= 0 ? hexResult = (hexResult << 4) + tmp2 : throwError2(state, "expected hexadecimal character");
          state.result += charFromCodepoint(hexResult), state.position++;
        } else
          throwError2(state, "unknown escape sequence");
        captureStart = captureEnd = state.position;
      } else is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError2(state, "unexpected end of the document within a double quoted scalar") : (state.position++, captureEnd = state.position);
    }
    throwError2(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = !0, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
    if (ch = state.input.charCodeAt(state.position), ch === 91)
      terminator = 93, isMapping = !1, _result = [];
    else if (ch === 123)
      terminator = 125, isMapping = !0, _result = {};
    else
      return !1;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(++state.position); ch !== 0; ) {
      if (skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === terminator)
        return state.position++, state.tag = _tag, state.anchor = _anchor, state.kind = isMapping ? "mapping" : "sequence", state.result = _result, !0;
      readNext || throwError2(state, "missed comma between flow collection entries"), keyTag = keyNode = valueNode = null, isPair = isExplicitPair = !1, ch === 63 && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) && (isPair = isExplicitPair = !0, state.position++, skipSeparationSpace(state, !0, nodeIndent))), _line = state.line, composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), keyTag = state.tag, keyNode = state.result, skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), (isExplicitPair || state.line === _line) && ch === 58 && (isPair = !0, ch = state.input.charCodeAt(++state.position), skipSeparationSpace(state, !0, nodeIndent), composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), valueNode = state.result), isMapping ? storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode) : isPair ? _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode)) : _result.push(keyNode), skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === 44 ? (readNext = !0, ch = state.input.charCodeAt(++state.position)) : readNext = !1;
    }
    throwError2(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = !1, detectedIndent = !1, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = !1, tmp2, ch;
    if (ch = state.input.charCodeAt(state.position), ch === 124)
      folding = !1;
    else if (ch === 62)
      folding = !0;
    else
      return !1;
    for (state.kind = "scalar", state.result = ""; ch !== 0; )
      if (ch = state.input.charCodeAt(++state.position), ch === 43 || ch === 45)
        CHOMPING_CLIP === chomping ? chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP : throwError2(state, "repeat of a chomping mode identifier");
      else if ((tmp2 = fromDecimalCode(ch)) >= 0)
        tmp2 === 0 ? throwError2(state, "bad explicit indentation width of a block scalar; it cannot be less than one") : detectedIndent ? throwError2(state, "repeat of an indentation width identifier") : (textIndent = nodeIndent + tmp2 - 1, detectedIndent = !0);
      else
        break;
    if (is_WHITE_SPACE(ch)) {
      do
        ch = state.input.charCodeAt(++state.position);
      while (is_WHITE_SPACE(ch));
      if (ch === 35)
        do
          ch = state.input.charCodeAt(++state.position);
        while (!is_EOL(ch) && ch !== 0);
    }
    for (; ch !== 0; ) {
      for (readLineBreak(state), state.lineIndent = 0, ch = state.input.charCodeAt(state.position); (!detectedIndent || state.lineIndent < textIndent) && ch === 32; )
        state.lineIndent++, ch = state.input.charCodeAt(++state.position);
      if (!detectedIndent && state.lineIndent > textIndent && (textIndent = state.lineIndent), is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        chomping === CHOMPING_KEEP ? state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines) : chomping === CHOMPING_CLIP && didReadContent && (state.result += `
`);
        break;
      }
      for (folding ? is_WHITE_SPACE(ch) ? (atMoreIndented = !0, state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines)) : atMoreIndented ? (atMoreIndented = !1, state.result += common2.repeat(`
`, emptyLines + 1)) : emptyLines === 0 ? didReadContent && (state.result += " ") : state.result += common2.repeat(`
`, emptyLines) : state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines), didReadContent = !0, detectedIndent = !0, emptyLines = 0, captureStart = state.position; !is_EOL(ch) && ch !== 0; )
        ch = state.input.charCodeAt(++state.position);
      captureSegment(state, captureStart, state.position, !1);
    }
    return !0;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = !1, ch;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0 && !(ch !== 45 || (following = state.input.charCodeAt(state.position + 1), !is_WS_OR_EOL(following))); ) {
      if (detected = !0, state.position++, skipSeparationSpace(state, !0, -1) && state.lineIndent <= nodeIndent) {
        _result.push(null), ch = state.input.charCodeAt(state.position);
        continue;
      }
      if (_line = state.line, composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, !1, !0), _result.push(state.result), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), (state.line === _line || state.lineIndent > nodeIndent) && ch !== 0)
        throwError2(state, "bad indentation of a sequence entry");
      else if (state.lineIndent < nodeIndent)
        break;
    }
    return detected ? (state.tag = _tag, state.anchor = _anchor, state.kind = "sequence", state.result = _result, !0) : !1;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = !1, detected = !1, ch;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0; ) {
      if (following = state.input.charCodeAt(state.position + 1), _line = state.line, _pos = state.position, (ch === 63 || ch === 58) && is_WS_OR_EOL(following))
        ch === 63 ? (atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !0, allowCompact = !0) : atExplicitKey ? (atExplicitKey = !1, allowCompact = !0) : throwError2(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), state.position += 1, ch = following;
      else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, !1, !0))
        if (state.line === _line) {
          for (ch = state.input.charCodeAt(state.position); is_WHITE_SPACE(ch); )
            ch = state.input.charCodeAt(++state.position);
          if (ch === 58)
            ch = state.input.charCodeAt(++state.position), is_WS_OR_EOL(ch) || throwError2(state, "a whitespace character is expected after the key-value separator within a block mapping"), atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !1, allowCompact = !1, keyTag = state.tag, keyNode = state.result;
          else if (detected)
            throwError2(state, "can not read an implicit mapping pair; a colon is missed");
          else
            return state.tag = _tag, state.anchor = _anchor, !0;
        } else if (detected)
          throwError2(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        else
          return state.tag = _tag, state.anchor = _anchor, !0;
      else
        break;
      if ((state.line === _line || state.lineIndent > nodeIndent) && (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, !0, allowCompact) && (atExplicitKey ? keyNode = state.result : valueNode = state.result), atExplicitKey || (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos), keyTag = keyNode = valueNode = null), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position)), state.lineIndent > nodeIndent && ch !== 0)
        throwError2(state, "bad indentation of a mapping entry");
      else if (state.lineIndent < nodeIndent)
        break;
    }
    return atExplicitKey && storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), detected && (state.tag = _tag, state.anchor = _anchor, state.kind = "mapping", state.result = _result), detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = !1, isNamed = !1, tagHandle, tagName, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 33) return !1;
    if (state.tag !== null && throwError2(state, "duplication of a tag property"), ch = state.input.charCodeAt(++state.position), ch === 60 ? (isVerbatim = !0, ch = state.input.charCodeAt(++state.position)) : ch === 33 ? (isNamed = !0, tagHandle = "!!", ch = state.input.charCodeAt(++state.position)) : tagHandle = "!", _position = state.position, isVerbatim) {
      do
        ch = state.input.charCodeAt(++state.position);
      while (ch !== 0 && ch !== 62);
      state.position < state.length ? (tagName = state.input.slice(_position, state.position), ch = state.input.charCodeAt(++state.position)) : throwError2(state, "unexpected end of the stream within a verbatim tag");
    } else {
      for (; ch !== 0 && !is_WS_OR_EOL(ch); )
        ch === 33 && (isNamed ? throwError2(state, "tag suffix cannot contain exclamation marks") : (tagHandle = state.input.slice(_position - 1, state.position + 1), PATTERN_TAG_HANDLE.test(tagHandle) || throwError2(state, "named tag handle cannot contain such characters"), isNamed = !0, _position = state.position + 1)), ch = state.input.charCodeAt(++state.position);
      tagName = state.input.slice(_position, state.position), PATTERN_FLOW_INDICATORS.test(tagName) && throwError2(state, "tag suffix cannot contain flow indicator characters");
    }
    return tagName && !PATTERN_TAG_URI.test(tagName) && throwError2(state, "tag name cannot contain such characters: " + tagName), isVerbatim ? state.tag = tagName : _hasOwnProperty.call(state.tagMap, tagHandle) ? state.tag = state.tagMap[tagHandle] + tagName : tagHandle === "!" ? state.tag = "!" + tagName : tagHandle === "!!" ? state.tag = "tag:yaml.org,2002:" + tagName : throwError2(state, 'undeclared tag handle "' + tagHandle + '"'), !0;
  }
  function readAnchorProperty(state) {
    var _position, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 38) return !1;
    for (state.anchor !== null && throwError2(state, "duplication of an anchor property"), ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
      ch = state.input.charCodeAt(++state.position);
    return state.position === _position && throwError2(state, "name of an anchor node must contain at least one character"), state.anchor = state.input.slice(_position, state.position), !0;
  }
  function readAlias(state) {
    var _position, alias, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 42) return !1;
    for (ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
      ch = state.input.charCodeAt(++state.position);
    return state.position === _position && throwError2(state, "name of an alias node must contain at least one character"), alias = state.input.slice(_position, state.position), state.anchorMap.hasOwnProperty(alias) || throwError2(state, 'unidentified alias "' + alias + '"'), state.result = state.anchorMap[alias], skipSeparationSpace(state, !0, -1), !0;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = !1, hasContent = !1, typeIndex, typeQuantity, type2, flowIndent, blockIndent;
    if (state.listener !== null && state.listener("open", state), state.tag = null, state.anchor = null, state.kind = null, state.result = null, allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext, allowToSeek && skipSeparationSpace(state, !0, -1) && (atNewLine = !0, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)), indentStatus === 1)
      for (; readTagProperty(state) || readAnchorProperty(state); )
        skipSeparationSpace(state, !0, -1) ? (atNewLine = !0, allowBlockCollections = allowBlockStyles, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)) : allowBlockCollections = !1;
    if (allowBlockCollections && (allowBlockCollections = atNewLine || allowCompact), (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) && (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext ? flowIndent = parentIndent : flowIndent = parentIndent + 1, blockIndent = state.position - state.lineStart, indentStatus === 1 ? allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent) ? hasContent = !0 : (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent) ? hasContent = !0 : readAlias(state) ? (hasContent = !0, (state.tag !== null || state.anchor !== null) && throwError2(state, "alias node should not have any properties")) : readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext) && (hasContent = !0, state.tag === null && (state.tag = "?")), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : indentStatus === 0 && (hasContent = allowBlockCollections && readBlockSequence(state, blockIndent))), state.tag !== null && state.tag !== "!")
      if (state.tag === "?") {
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1)
          if (type2 = state.implicitTypes[typeIndex], type2.resolve(state.result)) {
            state.result = type2.construct(state.result), state.tag = type2.tag, state.anchor !== null && (state.anchorMap[state.anchor] = state.result);
            break;
          }
      } else _hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag) ? (type2 = state.typeMap[state.kind || "fallback"][state.tag], state.result !== null && type2.kind !== state.kind && throwError2(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"'), type2.resolve(state.result) ? (state.result = type2.construct(state.result), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : throwError2(state, "cannot resolve a node with !<" + state.tag + "> explicit tag")) : throwError2(state, "unknown tag !<" + state.tag + ">");
    return state.listener !== null && state.listener("close", state), state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = !1, ch;
    for (state.version = null, state.checkLineBreaks = state.legacy, state.tagMap = {}, state.anchorMap = {}; (ch = state.input.charCodeAt(state.position)) !== 0 && (skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), !(state.lineIndent > 0 || ch !== 37)); ) {
      for (hasDirectives = !0, ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
        ch = state.input.charCodeAt(++state.position);
      for (directiveName = state.input.slice(_position, state.position), directiveArgs = [], directiveName.length < 1 && throwError2(state, "directive name must not be less than one character in length"); ch !== 0; ) {
        for (; is_WHITE_SPACE(ch); )
          ch = state.input.charCodeAt(++state.position);
        if (ch === 35) {
          do
            ch = state.input.charCodeAt(++state.position);
          while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch)) break;
        for (_position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
          ch = state.input.charCodeAt(++state.position);
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      ch !== 0 && readLineBreak(state), _hasOwnProperty.call(directiveHandlers, directiveName) ? directiveHandlers[directiveName](state, directiveName, directiveArgs) : throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
    if (skipSeparationSpace(state, !0, -1), state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45 ? (state.position += 3, skipSeparationSpace(state, !0, -1)) : hasDirectives && throwError2(state, "directives end mark is expected"), composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, !1, !0), skipSeparationSpace(state, !0, -1), state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position)) && throwWarning(state, "non-ASCII line breaks are interpreted as content"), state.documents.push(state.result), state.position === state.lineStart && testDocumentSeparator(state)) {
      state.input.charCodeAt(state.position) === 46 && (state.position += 3, skipSeparationSpace(state, !0, -1));
      return;
    }
    if (state.position < state.length - 1)
      throwError2(state, "end of the stream or a document separator is expected");
    else
      return;
  }
  function loadDocuments(input2, options2) {
    input2 = String(input2), options2 = options2 || {}, input2.length !== 0 && (input2.charCodeAt(input2.length - 1) !== 10 && input2.charCodeAt(input2.length - 1) !== 13 && (input2 += `
`), input2.charCodeAt(0) === 65279 && (input2 = input2.slice(1)));
    var state = new State(input2, options2);
    for (state.input += "\0"; state.input.charCodeAt(state.position) === 32; )
      state.lineIndent += 1, state.position += 1;
    for (; state.position < state.length - 1; )
      readDocument(state);
    return state.documents;
  }
  function loadAll(input2, iterator2, options2) {
    var documents = loadDocuments(input2, options2), index, length;
    if (typeof iterator2 != "function")
      return documents;
    for (index = 0, length = documents.length; index < length; index += 1)
      iterator2(documents[index]);
  }
  function load(input2, options2) {
    var documents = loadDocuments(input2, options2);
    if (documents.length !== 0) {
      if (documents.length === 1)
        return documents[0];
      throw new YAMLException("expected a single document in the stream, but found more");
    }
  }
  function safeLoadAll(input2, output, options2) {
    if (typeof output == "function")
      loadAll(input2, output, common2.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
    else
      return loadAll(input2, common2.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  function safeLoad(input2, options2) {
    return load(input2, common2.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  return loader$2.loadAll = loadAll, loader$2.load = load, loader$2.safeLoadAll = safeLoadAll, loader$2.safeLoad = safeLoad, loader$2;
}
var dumper$2 = {}, hasRequiredDumper$2;
function requireDumper$2() {
  if (hasRequiredDumper$2) return dumper$2;
  hasRequiredDumper$2 = 1;
  var common2 = requireCommon$3(), YAMLException = requireException$2(), DEFAULT_FULL_SCHEMA = requireDefault_full$1(), DEFAULT_SAFE_SCHEMA = requireDefault_safe$1(), _toString = Object.prototype.toString, _hasOwnProperty = Object.prototype.hasOwnProperty, CHAR_TAB = 9, CHAR_LINE_FEED = 10, CHAR_SPACE = 32, CHAR_EXCLAMATION = 33, CHAR_DOUBLE_QUOTE = 34, CHAR_SHARP = 35, CHAR_PERCENT = 37, CHAR_AMPERSAND = 38, CHAR_SINGLE_QUOTE = 39, CHAR_ASTERISK = 42, CHAR_COMMA2 = 44, CHAR_MINUS = 45, CHAR_COLON2 = 58, CHAR_GREATER_THAN = 62, CHAR_QUESTION = 63, CHAR_COMMERCIAL_AT = 64, CHAR_LEFT_SQUARE_BRACKET = 91, CHAR_RIGHT_SQUARE_BRACKET = 93, CHAR_GRAVE_ACCENT = 96, CHAR_LEFT_CURLY_BRACKET = 123, CHAR_VERTICAL_LINE = 124, CHAR_RIGHT_CURLY_BRACKET = 125, ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0", ESCAPE_SEQUENCES[7] = "\\a", ESCAPE_SEQUENCES[8] = "\\b", ESCAPE_SEQUENCES[9] = "\\t", ESCAPE_SEQUENCES[10] = "\\n", ESCAPE_SEQUENCES[11] = "\\v", ESCAPE_SEQUENCES[12] = "\\f", ESCAPE_SEQUENCES[13] = "\\r", ESCAPE_SEQUENCES[27] = "\\e", ESCAPE_SEQUENCES[34] = '\\"', ESCAPE_SEQUENCES[92] = "\\\\", ESCAPE_SEQUENCES[133] = "\\N", ESCAPE_SEQUENCES[160] = "\\_", ESCAPE_SEQUENCES[8232] = "\\L", ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  function compileStyleMap(schema2, map2) {
    var result, keys, index, length, tag, style, type2;
    if (map2 === null) return {};
    for (result = {}, keys = Object.keys(map2), index = 0, length = keys.length; index < length; index += 1)
      tag = keys[index], style = String(map2[tag]), tag.slice(0, 2) === "!!" && (tag = "tag:yaml.org,2002:" + tag.slice(2)), type2 = schema2.compiledTypeMap.fallback[tag], type2 && _hasOwnProperty.call(type2.styleAliases, style) && (style = type2.styleAliases[style]), result[tag] = style;
    return result;
  }
  function encodeHex(character) {
    var string, handle, length;
    if (string = character.toString(16).toUpperCase(), character <= 255)
      handle = "x", length = 2;
    else if (character <= 65535)
      handle = "u", length = 4;
    else if (character <= 4294967295)
      handle = "U", length = 8;
    else
      throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + handle + common2.repeat("0", length - string.length) + string;
  }
  function State(options2) {
    this.schema = options2.schema || DEFAULT_FULL_SCHEMA, this.indent = Math.max(1, options2.indent || 2), this.noArrayIndent = options2.noArrayIndent || !1, this.skipInvalid = options2.skipInvalid || !1, this.flowLevel = common2.isNothing(options2.flowLevel) ? -1 : options2.flowLevel, this.styleMap = compileStyleMap(this.schema, options2.styles || null), this.sortKeys = options2.sortKeys || !1, this.lineWidth = options2.lineWidth || 80, this.noRefs = options2.noRefs || !1, this.noCompatMode = options2.noCompatMode || !1, this.condenseFlow = options2.condenseFlow || !1, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
  }
  function indentString2(string, spaces) {
    for (var ind = common2.repeat(" ", spaces), position = 0, next = -1, result = "", line3, length = string.length; position < length; )
      next = string.indexOf(`
`, position), next === -1 ? (line3 = string.slice(position), position = length) : (line3 = string.slice(position, next + 1), position = next + 1), line3.length && line3 !== `
` && (result += ind), result += line3;
    return result;
  }
  function generateNextLine(state, level) {
    return `
` + common2.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str2) {
    var index, length, type2;
    for (index = 0, length = state.implicitTypes.length; index < length; index += 1)
      if (type2 = state.implicitTypes[index], type2.resolve(str2))
        return !0;
    return !1;
  }
  function isWhitespace(c2) {
    return c2 === CHAR_SPACE || c2 === CHAR_TAB;
  }
  function isPrintable(c2) {
    return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== 65279 || 65536 <= c2 && c2 <= 1114111;
  }
  function isPlainSafe(c2) {
    return isPrintable(c2) && c2 !== 65279 && c2 !== CHAR_COMMA2 && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_COLON2 && c2 !== CHAR_SHARP;
  }
  function isPlainSafeFirst(c2) {
    return isPrintable(c2) && c2 !== 65279 && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON2 && c2 !== CHAR_COMMA2 && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
  }
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }
  var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
    var i, char, hasLineBreak = !1, hasFoldableLine = !1, shouldTrackWidth = lineWidth !== -1, previousLineBreak = -1, plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
    if (singleLineOnly)
      for (i = 0; i < string.length; i++) {
        if (char = string.charCodeAt(i), !isPrintable(char))
          return STYLE_DOUBLE;
        plain = plain && isPlainSafe(char);
      }
    else {
      for (i = 0; i < string.length; i++) {
        if (char = string.charCodeAt(i), char === CHAR_LINE_FEED)
          hasLineBreak = !0, shouldTrackWidth && (hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ", previousLineBreak = i);
        else if (!isPrintable(char))
          return STYLE_DOUBLE;
        plain = plain && isPlainSafe(char);
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
    }
    return !hasLineBreak && !hasFoldableLine ? plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE : indentPerLevel > 9 && needIndentIndicator(string) ? STYLE_DOUBLE : hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  function writeScalar(state, string, level, iskey) {
    state.dump = function() {
      if (string.length === 0)
        return "''";
      if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1)
        return "'" + string + "'";
      var indent = state.indent * Math.max(1, level), lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent), singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state, string2);
      }
      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString2(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString2(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';
        default:
          throw new YAMLException("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "", clip = string[string.length - 1] === `
`, keep = clip && (string[string.length - 2] === `
` || string === `
`), chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + `
`;
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === `
` ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    for (var lineRe = /(\n+)([^\n]*)/g, result = function() {
      var nextLF = string.indexOf(`
`);
      return nextLF = nextLF !== -1 ? nextLF : string.length, lineRe.lastIndex = nextLF, foldLine(string.slice(0, nextLF), width);
    }(), prevMoreIndented = string[0] === `
` || string[0] === " ", moreIndented, match2; match2 = lineRe.exec(string); ) {
      var prefix = match2[1], line3 = match2[2];
      moreIndented = line3[0] === " ", result += prefix + (!prevMoreIndented && !moreIndented && line3 !== "" ? `
` : "") + foldLine(line3, width), prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line3, width) {
    if (line3 === "" || line3[0] === " ") return line3;
    for (var breakRe = / [^ ]/g, match2, start = 0, end, curr = 0, next = 0, result = ""; match2 = breakRe.exec(line3); )
      next = match2.index, next - start > width && (end = curr > start ? curr : next, result += `
` + line3.slice(start, end), start = end + 1), curr = next;
    return result += `
`, line3.length - start > width && curr > start ? result += line3.slice(start, curr) + `
` + line3.slice(curr + 1) : result += line3.slice(start), result.slice(1);
  }
  function escapeString(string) {
    for (var result = "", char, nextChar, escapeSeq, i = 0; i < string.length; i++) {
      if (char = string.charCodeAt(i), char >= 55296 && char <= 56319 && (nextChar = string.charCodeAt(i + 1), nextChar >= 56320 && nextChar <= 57343)) {
        result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536), i++;
        continue;
      }
      escapeSeq = ESCAPE_SEQUENCES[char], result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
    }
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length;
    for (index = 0, length = object.length; index < length; index += 1)
      writeNode(state, level, object[index], !1, !1) && (index !== 0 && (_result += "," + (state.condenseFlow ? "" : " ")), _result += state.dump);
    state.tag = _tag, state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length;
    for (index = 0, length = object.length; index < length; index += 1)
      writeNode(state, level + 1, object[index], !0, !0) && ((!compact || index !== 0) && (_result += generateNextLine(state, level)), state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? _result += "-" : _result += "- ", _result += state.dump);
    state.tag = _tag, state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length; index < length; index += 1)
      pairBuffer = state.condenseFlow ? '"' : "", index !== 0 && (pairBuffer += ", "), objectKey = objectKeyList[index], objectValue = object[objectKey], writeNode(state, level, objectKey, !1, !1) && (state.dump.length > 1024 && (pairBuffer += "? "), pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " "), writeNode(state, level, objectValue, !1, !1) && (pairBuffer += state.dump, _result += pairBuffer));
    state.tag = _tag, state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === !0)
      objectKeyList.sort();
    else if (typeof state.sortKeys == "function")
      objectKeyList.sort(state.sortKeys);
    else if (state.sortKeys)
      throw new YAMLException("sortKeys must be a boolean or a function");
    for (index = 0, length = objectKeyList.length; index < length; index += 1)
      pairBuffer = "", (!compact || index !== 0) && (pairBuffer += generateNextLine(state, level)), objectKey = objectKeyList[index], objectValue = object[objectKey], writeNode(state, level + 1, objectKey, !0, !0, !0) && (explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024, explicitPair && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += "?" : pairBuffer += "? "), pairBuffer += state.dump, explicitPair && (pairBuffer += generateNextLine(state, level)), writeNode(state, level + 1, objectValue, !0, explicitPair) && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += ":" : pairBuffer += ": ", pairBuffer += state.dump, _result += pairBuffer));
    state.tag = _tag, state.dump = _result || "{}";
  }
  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type2, style;
    for (typeList = explicit ? state.explicitTypes : state.implicitTypes, index = 0, length = typeList.length; index < length; index += 1)
      if (type2 = typeList[index], (type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object == "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
        if (state.tag = explicit ? type2.tag : "?", type2.represent) {
          if (style = state.styleMap[type2.tag] || type2.defaultStyle, _toString.call(type2.represent) === "[object Function]")
            _result = type2.represent(object, style);
          else if (_hasOwnProperty.call(type2.represent, style))
            _result = type2.represent[style](object, style);
          else
            throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
          state.dump = _result;
        }
        return !0;
      }
    return !1;
  }
  function writeNode(state, level, object, block, compact, iskey) {
    state.tag = null, state.dump = object, detectType(state, object, !1) || detectType(state, object, !0);
    var type2 = _toString.call(state.dump);
    block && (block = state.flowLevel < 0 || state.flowLevel > level);
    var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray && (duplicateIndex = state.duplicates.indexOf(object), duplicate = duplicateIndex !== -1), (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) && (compact = !1), duplicate && state.usedDuplicates[duplicateIndex])
      state.dump = "*ref_" + duplicateIndex;
    else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex] && (state.usedDuplicates[duplicateIndex] = !0), type2 === "[object Object]")
        block && Object.keys(state.dump).length !== 0 ? (writeBlockMapping(state, level, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowMapping(state, level, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
      else if (type2 === "[object Array]") {
        var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
        block && state.dump.length !== 0 ? (writeBlockSequence(state, arrayLevel, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowSequence(state, arrayLevel, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
      } else if (type2 === "[object String]")
        state.tag !== "?" && writeScalar(state, state.dump, level, iskey);
      else {
        if (state.skipInvalid) return !1;
        throw new YAMLException("unacceptable kind of an object to dump " + type2);
      }
      state.tag !== null && state.tag !== "?" && (state.dump = "!<" + state.tag + "> " + state.dump);
    }
    return !0;
  }
  function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    for (inspectNode(object, objects, duplicatesIndexes), index = 0, length = duplicatesIndexes.length; index < length; index += 1)
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object == "object")
      if (index = objects.indexOf(object), index !== -1)
        duplicatesIndexes.indexOf(index) === -1 && duplicatesIndexes.push(index);
      else if (objects.push(object), Array.isArray(object))
        for (index = 0, length = object.length; index < length; index += 1)
          inspectNode(object[index], objects, duplicatesIndexes);
      else
        for (objectKeyList = Object.keys(object), index = 0, length = objectKeyList.length; index < length; index += 1)
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
  }
  function dump(input2, options2) {
    options2 = options2 || {};
    var state = new State(options2);
    return state.noRefs || getDuplicateReferences(input2, state), writeNode(state, 0, input2, !0, !0) ? state.dump + `
` : "";
  }
  function safeDump(input2, options2) {
    return dump(input2, common2.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  return dumper$2.dump = dump, dumper$2.safeDump = safeDump, dumper$2;
}
var hasRequiredJsYaml$4;
function requireJsYaml$4() {
  if (hasRequiredJsYaml$4) return jsYaml$4;
  hasRequiredJsYaml$4 = 1;
  var loader2 = requireLoader$2(), dumper2 = requireDumper$2();
  function deprecated(name) {
    return function() {
      throw new Error("Function " + name + " is deprecated and cannot be used.");
    };
  }
  return jsYaml$4.Type = requireType$2(), jsYaml$4.Schema = requireSchema$2(), jsYaml$4.FAILSAFE_SCHEMA = requireFailsafe$2(), jsYaml$4.JSON_SCHEMA = requireJson$2(), jsYaml$4.CORE_SCHEMA = requireCore$5(), jsYaml$4.DEFAULT_SAFE_SCHEMA = requireDefault_safe$1(), jsYaml$4.DEFAULT_FULL_SCHEMA = requireDefault_full$1(), jsYaml$4.load = loader2.load, jsYaml$4.loadAll = loader2.loadAll, jsYaml$4.safeLoad = loader2.safeLoad, jsYaml$4.safeLoadAll = loader2.safeLoadAll, jsYaml$4.dump = dumper2.dump, jsYaml$4.safeDump = dumper2.safeDump, jsYaml$4.YAMLException = requireException$2(), jsYaml$4.MINIMAL_SCHEMA = requireFailsafe$2(), jsYaml$4.SAFE_SCHEMA = requireDefault_safe$1(), jsYaml$4.DEFAULT_SCHEMA = requireDefault_full$1(), jsYaml$4.scan = deprecated("scan"), jsYaml$4.parse = deprecated("parse"), jsYaml$4.compose = deprecated("compose"), jsYaml$4.addConstructor = deprecated("addConstructor"), jsYaml$4;
}
var jsYaml$3, hasRequiredJsYaml$3;
function requireJsYaml$3() {
  if (hasRequiredJsYaml$3) return jsYaml$3;
  hasRequiredJsYaml$3 = 1;
  var yaml = requireJsYaml$4();
  return jsYaml$3 = yaml, jsYaml$3;
}
var toml = {}, parse$2 = { exports: {} }, tomlParser = { exports: {} }, parser$2, hasRequiredParser$1;
function requireParser$1() {
  if (hasRequiredParser$1) return parser$2;
  hasRequiredParser$1 = 1;
  const ParserEND = 1114112;
  class ParserError extends Error {
    /* istanbul ignore next */
    constructor(msg, filename, linenumber) {
      super("[ParserError] " + msg, filename, linenumber), this.name = "ParserError", this.code = "ParserError", Error.captureStackTrace && Error.captureStackTrace(this, ParserError);
    }
  }
  class State {
    constructor(parser2) {
      this.parser = parser2, this.buf = "", this.returned = null, this.result = null, this.resultTable = null, this.resultArr = null;
    }
  }
  class Parser {
    constructor() {
      this.pos = 0, this.col = 0, this.line = 0, this.obj = {}, this.ctx = this.obj, this.stack = [], this._buf = "", this.char = null, this.ii = 0, this.state = new State(this.parseStart);
    }
    parse(str2) {
      if (str2.length === 0 || str2.length == null) return;
      this._buf = String(str2), this.ii = -1, this.char = -1;
      let getNext;
      for (; getNext === !1 || this.nextChar(); )
        getNext = this.runOne();
      this._buf = null;
    }
    nextChar() {
      return this.char === 10 && (++this.line, this.col = -1), ++this.ii, this.char = this._buf.codePointAt(this.ii), ++this.pos, ++this.col, this.haveBuffer();
    }
    haveBuffer() {
      return this.ii < this._buf.length;
    }
    runOne() {
      return this.state.parser.call(this, this.state.returned);
    }
    finish() {
      this.char = ParserEND;
      let last2;
      do
        last2 = this.state.parser, this.runOne();
      while (this.state.parser !== last2);
      return this.ctx = null, this.state = null, this._buf = null, this.obj;
    }
    next(fn) {
      if (typeof fn != "function") throw new ParserError("Tried to set state to non-existent state: " + JSON.stringify(fn));
      this.state.parser = fn;
    }
    goto(fn) {
      return this.next(fn), this.runOne();
    }
    call(fn, returnWith) {
      returnWith && this.next(returnWith), this.stack.push(this.state), this.state = new State(fn);
    }
    callNow(fn, returnWith) {
      return this.call(fn, returnWith), this.runOne();
    }
    return(value) {
      if (this.stack.length === 0) throw this.error(new ParserError("Stack underflow"));
      value === void 0 && (value = this.state.buf), this.state = this.stack.pop(), this.state.returned = value;
    }
    returnNow(value) {
      return this.return(value), this.runOne();
    }
    consume() {
      if (this.char === ParserEND) throw this.error(new ParserError("Unexpected end-of-buffer"));
      this.state.buf += this._buf[this.ii];
    }
    error(err) {
      return err.line = this.line, err.col = this.col, err.pos = this.pos, err;
    }
    /* istanbul ignore next */
    parseStart() {
      throw new ParserError("Must declare a parseStart method");
    }
  }
  return Parser.END = ParserEND, Parser.Error = ParserError, parser$2 = Parser, parser$2;
}
var createDatetime, hasRequiredCreateDatetime;
function requireCreateDatetime() {
  return hasRequiredCreateDatetime || (hasRequiredCreateDatetime = 1, createDatetime = (value) => {
    const date = new Date(value);
    if (isNaN(date))
      throw new TypeError("Invalid Datetime");
    return date;
  }), createDatetime;
}
var formatNum, hasRequiredFormatNum;
function requireFormatNum() {
  return hasRequiredFormatNum || (hasRequiredFormatNum = 1, formatNum = (d, num) => {
    for (num = String(num); num.length < d; ) num = "0" + num;
    return num;
  }), formatNum;
}
var createDatetimeFloat, hasRequiredCreateDatetimeFloat;
function requireCreateDatetimeFloat() {
  if (hasRequiredCreateDatetimeFloat) return createDatetimeFloat;
  hasRequiredCreateDatetimeFloat = 1;
  const f = requireFormatNum();
  class FloatingDateTime extends Date {
    constructor(value) {
      super(value + "Z"), this.isFloating = !0;
    }
    toISOString() {
      const date = `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`, time = `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;
      return `${date}T${time}`;
    }
  }
  return createDatetimeFloat = (value) => {
    const date = new FloatingDateTime(value);
    if (isNaN(date))
      throw new TypeError("Invalid Datetime");
    return date;
  }, createDatetimeFloat;
}
var createDate, hasRequiredCreateDate;
function requireCreateDate() {
  if (hasRequiredCreateDate) return createDate;
  hasRequiredCreateDate = 1;
  const f = requireFormatNum(), DateTime = loadEnv.commonjsGlobal.Date;
  class Date2 extends DateTime {
    constructor(value) {
      super(value), this.isDate = !0;
    }
    toISOString() {
      return `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`;
    }
  }
  return createDate = (value) => {
    const date = new Date2(value);
    if (isNaN(date))
      throw new TypeError("Invalid Datetime");
    return date;
  }, createDate;
}
var createTime, hasRequiredCreateTime;
function requireCreateTime() {
  if (hasRequiredCreateTime) return createTime;
  hasRequiredCreateTime = 1;
  const f = requireFormatNum();
  class Time extends Date {
    constructor(value) {
      super(`0000-01-01T${value}Z`), this.isTime = !0;
    }
    toISOString() {
      return `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;
    }
  }
  return createTime = (value) => {
    const date = new Time(value);
    if (isNaN(date))
      throw new TypeError("Invalid Datetime");
    return date;
  }, createTime;
}
var hasRequiredTomlParser;
function requireTomlParser() {
  if (hasRequiredTomlParser) return tomlParser.exports;
  hasRequiredTomlParser = 1, tomlParser.exports = makeParserClass(requireParser$1()), tomlParser.exports.makeParserClass = makeParserClass;
  class TomlError extends Error {
    constructor(msg) {
      super(msg), this.name = "TomlError", Error.captureStackTrace && Error.captureStackTrace(this, TomlError), this.fromTOML = !0, this.wrapped = null;
    }
  }
  TomlError.wrap = (err) => {
    const terr = new TomlError(err.message);
    return terr.code = err.code, terr.wrapped = err, terr;
  }, tomlParser.exports.TomlError = TomlError;
  const createDateTime = requireCreateDatetime(), createDateTimeFloat = requireCreateDatetimeFloat(), createDate = requireCreateDate(), createTime = requireCreateTime(), CTRL_I = 9, CTRL_J = 10, CTRL_M = 13, CTRL_CHAR_BOUNDARY = 31, CHAR_SP = 32, CHAR_QUOT = 34, CHAR_NUM = 35, CHAR_APOS = 39, CHAR_PLUS = 43, CHAR_COMMA = 44, CHAR_HYPHEN = 45, CHAR_PERIOD = 46, CHAR_0 = 48, CHAR_1 = 49, CHAR_7 = 55, CHAR_9 = 57, CHAR_COLON = 58, CHAR_EQUALS = 61, CHAR_A = 65, CHAR_E = 69, CHAR_F = 70, CHAR_T = 84, CHAR_U = 85, CHAR_Z = 90, CHAR_LOWBAR = 95, CHAR_a = 97, CHAR_b = 98, CHAR_e = 101, CHAR_f = 102, CHAR_i = 105, CHAR_l = 108, CHAR_n = 110, CHAR_o = 111, CHAR_r = 114, CHAR_s = 115, CHAR_t = 116, CHAR_u = 117, CHAR_x = 120, CHAR_z = 122, CHAR_LCUB = 123, CHAR_RCUB = 125, CHAR_LSQB = 91, CHAR_BSOL = 92, CHAR_RSQB = 93, CHAR_DEL = 127, SURROGATE_FIRST = 55296, SURROGATE_LAST = 57343, escapes = {
    [CHAR_b]: "\b",
    [CHAR_t]: "	",
    [CHAR_n]: `
`,
    [CHAR_f]: "\f",
    [CHAR_r]: "\r",
    [CHAR_QUOT]: '"',
    [CHAR_BSOL]: "\\"
  };
  function isDigit(cp) {
    return cp >= CHAR_0 && cp <= CHAR_9;
  }
  function isHexit(cp) {
    return cp >= CHAR_A && cp <= CHAR_F || cp >= CHAR_a && cp <= CHAR_f || cp >= CHAR_0 && cp <= CHAR_9;
  }
  function isBit(cp) {
    return cp === CHAR_1 || cp === CHAR_0;
  }
  function isOctit(cp) {
    return cp >= CHAR_0 && cp <= CHAR_7;
  }
  function isAlphaNumQuoteHyphen(cp) {
    return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_APOS || cp === CHAR_QUOT || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
  }
  function isAlphaNumHyphen(cp) {
    return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
  }
  const _type = Symbol("type"), _declared = Symbol("declared"), hasOwnProperty = Object.prototype.hasOwnProperty, defineProperty = Object.defineProperty, descriptor = { configurable: !0, enumerable: !0, writable: !0, value: void 0 };
  function hasKey(obj, key2) {
    return hasOwnProperty.call(obj, key2) ? !0 : (key2 === "__proto__" && defineProperty(obj, "__proto__", descriptor), !1);
  }
  const INLINE_TABLE = Symbol("inline-table");
  function InlineTable() {
    return Object.defineProperties({}, {
      [_type]: { value: INLINE_TABLE }
    });
  }
  function isInlineTable(obj) {
    return obj === null || typeof obj != "object" ? !1 : obj[_type] === INLINE_TABLE;
  }
  const TABLE = Symbol("table");
  function Table() {
    return Object.defineProperties({}, {
      [_type]: { value: TABLE },
      [_declared]: { value: !1, writable: !0 }
    });
  }
  function isTable(obj) {
    return obj === null || typeof obj != "object" ? !1 : obj[_type] === TABLE;
  }
  const _contentType = Symbol("content-type"), INLINE_LIST = Symbol("inline-list");
  function InlineList(type2) {
    return Object.defineProperties([], {
      [_type]: { value: INLINE_LIST },
      [_contentType]: { value: type2 }
    });
  }
  function isInlineList(obj) {
    return obj === null || typeof obj != "object" ? !1 : obj[_type] === INLINE_LIST;
  }
  const LIST = Symbol("list");
  function List() {
    return Object.defineProperties([], {
      [_type]: { value: LIST }
    });
  }
  function isList(obj) {
    return obj === null || typeof obj != "object" ? !1 : obj[_type] === LIST;
  }
  let _custom;
  try {
    const utilInspect = eval("require('util').inspect");
    _custom = utilInspect.custom;
  } catch (_) {
  }
  const _inspect = _custom || "inspect";
  class BoxedBigInt {
    constructor(value) {
      try {
        this.value = loadEnv.commonjsGlobal.BigInt.asIntN(64, value);
      } catch {
        this.value = null;
      }
      Object.defineProperty(this, _type, { value: INTEGER });
    }
    isNaN() {
      return this.value === null;
    }
    /* istanbul ignore next */
    toString() {
      return String(this.value);
    }
    /* istanbul ignore next */
    [_inspect]() {
      return `[BigInt: ${this.toString()}]}`;
    }
    valueOf() {
      return this.value;
    }
  }
  const INTEGER = Symbol("integer");
  function Integer(value) {
    let num = Number(value);
    return Object.is(num, -0) && (num = 0), loadEnv.commonjsGlobal.BigInt && !Number.isSafeInteger(num) ? new BoxedBigInt(value) : Object.defineProperties(new Number(num), {
      isNaN: { value: function() {
        return isNaN(this);
      } },
      [_type]: { value: INTEGER },
      [_inspect]: { value: () => `[Integer: ${value}]` }
    });
  }
  function isInteger(obj) {
    return obj === null || typeof obj != "object" ? !1 : obj[_type] === INTEGER;
  }
  const FLOAT = Symbol("float");
  function Float(value) {
    return Object.defineProperties(new Number(value), {
      [_type]: { value: FLOAT },
      [_inspect]: { value: () => `[Float: ${value}]` }
    });
  }
  function isFloat(obj) {
    return obj === null || typeof obj != "object" ? !1 : obj[_type] === FLOAT;
  }
  function tomlType(value) {
    const type2 = typeof value;
    if (type2 === "object") {
      if (value === null) return "null";
      if (value instanceof Date) return "datetime";
      if (_type in value)
        switch (value[_type]) {
          case INLINE_TABLE:
            return "inline-table";
          case INLINE_LIST:
            return "inline-list";
          /* istanbul ignore next */
          case TABLE:
            return "table";
          /* istanbul ignore next */
          case LIST:
            return "list";
          case FLOAT:
            return "float";
          case INTEGER:
            return "integer";
        }
    }
    return type2;
  }
  function makeParserClass(Parser) {
    class TOMLParser extends Parser {
      constructor() {
        super(), this.ctx = this.obj = Table();
      }
      /* MATCH HELPER */
      atEndOfWord() {
        return this.char === CHAR_NUM || this.char === CTRL_I || this.char === CHAR_SP || this.atEndOfLine();
      }
      atEndOfLine() {
        return this.char === Parser.END || this.char === CTRL_J || this.char === CTRL_M;
      }
      parseStart() {
        if (this.char === Parser.END)
          return null;
        if (this.char === CHAR_LSQB)
          return this.call(this.parseTableOrList);
        if (this.char === CHAR_NUM)
          return this.call(this.parseComment);
        if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M)
          return null;
        if (isAlphaNumQuoteHyphen(this.char))
          return this.callNow(this.parseAssignStatement);
        throw this.error(new TomlError(`Unknown character "${this.char}"`));
      }
      // HELPER, this strips any whitespace and comments to the end of the line
      // then RETURNS. Last state in a production.
      parseWhitespaceToEOL() {
        if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M)
          return null;
        if (this.char === CHAR_NUM)
          return this.goto(this.parseComment);
        if (this.char === Parser.END || this.char === CTRL_J)
          return this.return();
        throw this.error(new TomlError("Unexpected character, expected only whitespace or comments till end of line"));
      }
      /* ASSIGNMENT: key = value */
      parseAssignStatement() {
        return this.callNow(this.parseAssign, this.recordAssignStatement);
      }
      recordAssignStatement(kv) {
        let target = this.ctx, finalKey = kv.key.pop();
        for (let kw of kv.key) {
          if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared]))
            throw this.error(new TomlError("Can't redefine existing key"));
          target = target[kw] = target[kw] || Table();
        }
        if (hasKey(target, finalKey))
          throw this.error(new TomlError("Can't redefine existing key"));
        return isInteger(kv.value) || isFloat(kv.value) ? target[finalKey] = kv.value.valueOf() : target[finalKey] = kv.value, this.goto(this.parseWhitespaceToEOL);
      }
      /* ASSSIGNMENT expression, key = value possibly inside an inline table */
      parseAssign() {
        return this.callNow(this.parseKeyword, this.recordAssignKeyword);
      }
      recordAssignKeyword(key2) {
        return this.state.resultTable ? this.state.resultTable.push(key2) : this.state.resultTable = [key2], this.goto(this.parseAssignKeywordPreDot);
      }
      parseAssignKeywordPreDot() {
        if (this.char === CHAR_PERIOD)
          return this.next(this.parseAssignKeywordPostDot);
        if (this.char !== CHAR_SP && this.char !== CTRL_I)
          return this.goto(this.parseAssignEqual);
      }
      parseAssignKeywordPostDot() {
        if (this.char !== CHAR_SP && this.char !== CTRL_I)
          return this.callNow(this.parseKeyword, this.recordAssignKeyword);
      }
      parseAssignEqual() {
        if (this.char === CHAR_EQUALS)
          return this.next(this.parseAssignPreValue);
        throw this.error(new TomlError('Invalid character, expected "="'));
      }
      parseAssignPreValue() {
        return this.char === CHAR_SP || this.char === CTRL_I ? null : this.callNow(this.parseValue, this.recordAssignValue);
      }
      recordAssignValue(value) {
        return this.returnNow({ key: this.state.resultTable, value });
      }
      /* COMMENTS: #...eol */
      parseComment() {
        do
          if (this.char === Parser.END || this.char === CTRL_J)
            return this.return();
        while (this.nextChar());
      }
      /* TABLES AND LISTS, [foo] and [[foo]] */
      parseTableOrList() {
        if (this.char === CHAR_LSQB)
          this.next(this.parseList);
        else
          return this.goto(this.parseTable);
      }
      /* TABLE [foo.bar.baz] */
      parseTable() {
        return this.ctx = this.obj, this.goto(this.parseTableNext);
      }
      parseTableNext() {
        return this.char === CHAR_SP || this.char === CTRL_I ? null : this.callNow(this.parseKeyword, this.parseTableMore);
      }
      parseTableMore(keyword) {
        if (this.char === CHAR_SP || this.char === CTRL_I)
          return null;
        if (this.char === CHAR_RSQB) {
          if (hasKey(this.ctx, keyword) && (!isTable(this.ctx[keyword]) || this.ctx[keyword][_declared]))
            throw this.error(new TomlError("Can't redefine existing key"));
          return this.ctx = this.ctx[keyword] = this.ctx[keyword] || Table(), this.ctx[_declared] = !0, this.next(this.parseWhitespaceToEOL);
        } else if (this.char === CHAR_PERIOD) {
          if (!hasKey(this.ctx, keyword))
            this.ctx = this.ctx[keyword] = Table();
          else if (isTable(this.ctx[keyword]))
            this.ctx = this.ctx[keyword];
          else if (isList(this.ctx[keyword]))
            this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
          else
            throw this.error(new TomlError("Can't redefine existing key"));
          return this.next(this.parseTableNext);
        } else
          throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
      }
      /* LIST [[a.b.c]] */
      parseList() {
        return this.ctx = this.obj, this.goto(this.parseListNext);
      }
      parseListNext() {
        return this.char === CHAR_SP || this.char === CTRL_I ? null : this.callNow(this.parseKeyword, this.parseListMore);
      }
      parseListMore(keyword) {
        if (this.char === CHAR_SP || this.char === CTRL_I)
          return null;
        if (this.char === CHAR_RSQB) {
          if (hasKey(this.ctx, keyword) || (this.ctx[keyword] = List()), isInlineList(this.ctx[keyword]))
            throw this.error(new TomlError("Can't extend an inline array"));
          if (isList(this.ctx[keyword])) {
            const next = Table();
            this.ctx[keyword].push(next), this.ctx = next;
          } else
            throw this.error(new TomlError("Can't redefine an existing key"));
          return this.next(this.parseListEnd);
        } else if (this.char === CHAR_PERIOD) {
          if (!hasKey(this.ctx, keyword))
            this.ctx = this.ctx[keyword] = Table();
          else {
            if (isInlineList(this.ctx[keyword]))
              throw this.error(new TomlError("Can't extend an inline array"));
            if (isInlineTable(this.ctx[keyword]))
              throw this.error(new TomlError("Can't extend an inline table"));
            if (isList(this.ctx[keyword]))
              this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
            else if (isTable(this.ctx[keyword]))
              this.ctx = this.ctx[keyword];
            else
              throw this.error(new TomlError("Can't redefine an existing key"));
          }
          return this.next(this.parseListNext);
        } else
          throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
      }
      parseListEnd(keyword) {
        if (this.char === CHAR_RSQB)
          return this.next(this.parseWhitespaceToEOL);
        throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
      }
      /* VALUE string, number, boolean, inline list, inline object */
      parseValue() {
        if (this.char === Parser.END)
          throw this.error(new TomlError("Key without value"));
        if (this.char === CHAR_QUOT)
          return this.next(this.parseDoubleString);
        if (this.char === CHAR_APOS)
          return this.next(this.parseSingleString);
        if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS)
          return this.goto(this.parseNumberSign);
        if (this.char === CHAR_i)
          return this.next(this.parseInf);
        if (this.char === CHAR_n)
          return this.next(this.parseNan);
        if (isDigit(this.char))
          return this.goto(this.parseNumberOrDateTime);
        if (this.char === CHAR_t || this.char === CHAR_f)
          return this.goto(this.parseBoolean);
        if (this.char === CHAR_LSQB)
          return this.call(this.parseInlineList, this.recordValue);
        if (this.char === CHAR_LCUB)
          return this.call(this.parseInlineTable, this.recordValue);
        throw this.error(new TomlError("Unexpected character, expecting string, number, datetime, boolean, inline array or inline table"));
      }
      recordValue(value) {
        return this.returnNow(value);
      }
      parseInf() {
        if (this.char === CHAR_n)
          return this.next(this.parseInf2);
        throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
      }
      parseInf2() {
        if (this.char === CHAR_f)
          return this.state.buf === "-" ? this.return(-1 / 0) : this.return(1 / 0);
        throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
      }
      parseNan() {
        if (this.char === CHAR_a)
          return this.next(this.parseNan2);
        throw this.error(new TomlError('Unexpected character, expected "nan"'));
      }
      parseNan2() {
        if (this.char === CHAR_n)
          return this.return(NaN);
        throw this.error(new TomlError('Unexpected character, expected "nan"'));
      }
      /* KEYS, barewords or basic, literal, or dotted */
      parseKeyword() {
        return this.char === CHAR_QUOT ? this.next(this.parseBasicString) : this.char === CHAR_APOS ? this.next(this.parseLiteralString) : this.goto(this.parseBareKey);
      }
      /* KEYS: barewords */
      parseBareKey() {
        do {
          if (this.char === Parser.END)
            throw this.error(new TomlError("Key ended without value"));
          if (isAlphaNumHyphen(this.char))
            this.consume();
          else {
            if (this.state.buf.length === 0)
              throw this.error(new TomlError("Empty bare keys are not allowed"));
            return this.returnNow();
          }
        } while (this.nextChar());
      }
      /* STRINGS, single quoted (literal) */
      parseSingleString() {
        return this.char === CHAR_APOS ? this.next(this.parseLiteralMultiStringMaybe) : this.goto(this.parseLiteralString);
      }
      parseLiteralString() {
        do {
          if (this.char === CHAR_APOS)
            return this.return();
          if (this.atEndOfLine())
            throw this.error(new TomlError("Unterminated string"));
          if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I)
            throw this.errorControlCharInString();
          this.consume();
        } while (this.nextChar());
      }
      parseLiteralMultiStringMaybe() {
        return this.char === CHAR_APOS ? this.next(this.parseLiteralMultiString) : this.returnNow();
      }
      parseLiteralMultiString() {
        return this.char === CTRL_M ? null : this.char === CTRL_J ? this.next(this.parseLiteralMultiStringContent) : this.goto(this.parseLiteralMultiStringContent);
      }
      parseLiteralMultiStringContent() {
        do {
          if (this.char === CHAR_APOS)
            return this.next(this.parseLiteralMultiEnd);
          if (this.char === Parser.END)
            throw this.error(new TomlError("Unterminated multi-line string"));
          if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M)
            throw this.errorControlCharInString();
          this.consume();
        } while (this.nextChar());
      }
      parseLiteralMultiEnd() {
        return this.char === CHAR_APOS ? this.next(this.parseLiteralMultiEnd2) : (this.state.buf += "'", this.goto(this.parseLiteralMultiStringContent));
      }
      parseLiteralMultiEnd2() {
        return this.char === CHAR_APOS ? this.return() : (this.state.buf += "''", this.goto(this.parseLiteralMultiStringContent));
      }
      /* STRINGS double quoted */
      parseDoubleString() {
        return this.char === CHAR_QUOT ? this.next(this.parseMultiStringMaybe) : this.goto(this.parseBasicString);
      }
      parseBasicString() {
        do {
          if (this.char === CHAR_BSOL)
            return this.call(this.parseEscape, this.recordEscapeReplacement);
          if (this.char === CHAR_QUOT)
            return this.return();
          if (this.atEndOfLine())
            throw this.error(new TomlError("Unterminated string"));
          if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I)
            throw this.errorControlCharInString();
          this.consume();
        } while (this.nextChar());
      }
      recordEscapeReplacement(replacement) {
        return this.state.buf += replacement, this.goto(this.parseBasicString);
      }
      parseMultiStringMaybe() {
        return this.char === CHAR_QUOT ? this.next(this.parseMultiString) : this.returnNow();
      }
      parseMultiString() {
        return this.char === CTRL_M ? null : this.char === CTRL_J ? this.next(this.parseMultiStringContent) : this.goto(this.parseMultiStringContent);
      }
      parseMultiStringContent() {
        do {
          if (this.char === CHAR_BSOL)
            return this.call(this.parseMultiEscape, this.recordMultiEscapeReplacement);
          if (this.char === CHAR_QUOT)
            return this.next(this.parseMultiEnd);
          if (this.char === Parser.END)
            throw this.error(new TomlError("Unterminated multi-line string"));
          if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M)
            throw this.errorControlCharInString();
          this.consume();
        } while (this.nextChar());
      }
      errorControlCharInString() {
        let displayCode = "\\u00";
        return this.char < 16 && (displayCode += "0"), displayCode += this.char.toString(16), this.error(new TomlError(`Control characters (codes < 0x1f and 0x7f) are not allowed in strings, use ${displayCode} instead`));
      }
      recordMultiEscapeReplacement(replacement) {
        return this.state.buf += replacement, this.goto(this.parseMultiStringContent);
      }
      parseMultiEnd() {
        return this.char === CHAR_QUOT ? this.next(this.parseMultiEnd2) : (this.state.buf += '"', this.goto(this.parseMultiStringContent));
      }
      parseMultiEnd2() {
        return this.char === CHAR_QUOT ? this.return() : (this.state.buf += '""', this.goto(this.parseMultiStringContent));
      }
      parseMultiEscape() {
        return this.char === CTRL_M || this.char === CTRL_J ? this.next(this.parseMultiTrim) : this.char === CHAR_SP || this.char === CTRL_I ? this.next(this.parsePreMultiTrim) : this.goto(this.parseEscape);
      }
      parsePreMultiTrim() {
        if (this.char === CHAR_SP || this.char === CTRL_I)
          return null;
        if (this.char === CTRL_M || this.char === CTRL_J)
          return this.next(this.parseMultiTrim);
        throw this.error(new TomlError("Can't escape whitespace"));
      }
      parseMultiTrim() {
        return this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M ? null : this.returnNow();
      }
      parseEscape() {
        if (this.char in escapes)
          return this.return(escapes[this.char]);
        if (this.char === CHAR_u)
          return this.call(this.parseSmallUnicode, this.parseUnicodeReturn);
        if (this.char === CHAR_U)
          return this.call(this.parseLargeUnicode, this.parseUnicodeReturn);
        throw this.error(new TomlError("Unknown escape character: " + this.char));
      }
      parseUnicodeReturn(char) {
        try {
          const codePoint = parseInt(char, 16);
          if (codePoint >= SURROGATE_FIRST && codePoint <= SURROGATE_LAST)
            throw this.error(new TomlError("Invalid unicode, character in range 0xD800 - 0xDFFF is reserved"));
          return this.returnNow(String.fromCodePoint(codePoint));
        } catch (err) {
          throw this.error(TomlError.wrap(err));
        }
      }
      parseSmallUnicode() {
        if (isHexit(this.char)) {
          if (this.consume(), this.state.buf.length >= 4) return this.return();
        } else
          throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
      }
      parseLargeUnicode() {
        if (isHexit(this.char)) {
          if (this.consume(), this.state.buf.length >= 8) return this.return();
        } else
          throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
      }
      /* NUMBERS */
      parseNumberSign() {
        return this.consume(), this.next(this.parseMaybeSignedInfOrNan);
      }
      parseMaybeSignedInfOrNan() {
        return this.char === CHAR_i ? this.next(this.parseInf) : this.char === CHAR_n ? this.next(this.parseNan) : this.callNow(this.parseNoUnder, this.parseNumberIntegerStart);
      }
      parseNumberIntegerStart() {
        return this.char === CHAR_0 ? (this.consume(), this.next(this.parseNumberIntegerExponentOrDecimal)) : this.goto(this.parseNumberInteger);
      }
      parseNumberIntegerExponentOrDecimal() {
        return this.char === CHAR_PERIOD ? (this.consume(), this.call(this.parseNoUnder, this.parseNumberFloat)) : this.char === CHAR_E || this.char === CHAR_e ? (this.consume(), this.next(this.parseNumberExponentSign)) : this.returnNow(Integer(this.state.buf));
      }
      parseNumberInteger() {
        if (isDigit(this.char))
          this.consume();
        else {
          if (this.char === CHAR_LOWBAR)
            return this.call(this.parseNoUnder);
          if (this.char === CHAR_E || this.char === CHAR_e)
            return this.consume(), this.next(this.parseNumberExponentSign);
          if (this.char === CHAR_PERIOD)
            return this.consume(), this.call(this.parseNoUnder, this.parseNumberFloat);
          {
            const result = Integer(this.state.buf);
            if (result.isNaN())
              throw this.error(new TomlError("Invalid number"));
            return this.returnNow(result);
          }
        }
      }
      parseNoUnder() {
        if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD || this.char === CHAR_E || this.char === CHAR_e)
          throw this.error(new TomlError("Unexpected character, expected digit"));
        if (this.atEndOfWord())
          throw this.error(new TomlError("Incomplete number"));
        return this.returnNow();
      }
      parseNumberFloat() {
        if (this.char === CHAR_LOWBAR)
          return this.call(this.parseNoUnder, this.parseNumberFloat);
        if (isDigit(this.char))
          this.consume();
        else return this.char === CHAR_E || this.char === CHAR_e ? (this.consume(), this.next(this.parseNumberExponentSign)) : this.returnNow(Float(this.state.buf));
      }
      parseNumberExponentSign() {
        if (isDigit(this.char))
          return this.goto(this.parseNumberExponent);
        if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS)
          this.consume(), this.call(this.parseNoUnder, this.parseNumberExponent);
        else
          throw this.error(new TomlError("Unexpected character, expected -, + or digit"));
      }
      parseNumberExponent() {
        if (isDigit(this.char))
          this.consume();
        else return this.char === CHAR_LOWBAR ? this.call(this.parseNoUnder) : this.returnNow(Float(this.state.buf));
      }
      /* NUMBERS or DATETIMES  */
      parseNumberOrDateTime() {
        return this.char === CHAR_0 ? (this.consume(), this.next(this.parseNumberBaseOrDateTime)) : this.goto(this.parseNumberOrDateTimeOnly);
      }
      parseNumberOrDateTimeOnly() {
        if (this.char === CHAR_LOWBAR)
          return this.call(this.parseNoUnder, this.parseNumberInteger);
        if (isDigit(this.char))
          this.consume(), this.state.buf.length > 4 && this.next(this.parseNumberInteger);
        else return this.char === CHAR_E || this.char === CHAR_e ? (this.consume(), this.next(this.parseNumberExponentSign)) : this.char === CHAR_PERIOD ? (this.consume(), this.call(this.parseNoUnder, this.parseNumberFloat)) : this.char === CHAR_HYPHEN ? this.goto(this.parseDateTime) : this.char === CHAR_COLON ? this.goto(this.parseOnlyTimeHour) : this.returnNow(Integer(this.state.buf));
      }
      parseDateTimeOnly() {
        if (this.state.buf.length < 4) {
          if (isDigit(this.char))
            return this.consume();
          if (this.char === CHAR_COLON)
            return this.goto(this.parseOnlyTimeHour);
          throw this.error(new TomlError("Expected digit while parsing year part of a date"));
        } else {
          if (this.char === CHAR_HYPHEN)
            return this.goto(this.parseDateTime);
          throw this.error(new TomlError("Expected hyphen (-) while parsing year part of date"));
        }
      }
      parseNumberBaseOrDateTime() {
        return this.char === CHAR_b ? (this.consume(), this.call(this.parseNoUnder, this.parseIntegerBin)) : this.char === CHAR_o ? (this.consume(), this.call(this.parseNoUnder, this.parseIntegerOct)) : this.char === CHAR_x ? (this.consume(), this.call(this.parseNoUnder, this.parseIntegerHex)) : this.char === CHAR_PERIOD ? this.goto(this.parseNumberInteger) : isDigit(this.char) ? this.goto(this.parseDateTimeOnly) : this.returnNow(Integer(this.state.buf));
      }
      parseIntegerHex() {
        if (isHexit(this.char))
          this.consume();
        else {
          if (this.char === CHAR_LOWBAR)
            return this.call(this.parseNoUnder);
          {
            const result = Integer(this.state.buf);
            if (result.isNaN())
              throw this.error(new TomlError("Invalid number"));
            return this.returnNow(result);
          }
        }
      }
      parseIntegerOct() {
        if (isOctit(this.char))
          this.consume();
        else {
          if (this.char === CHAR_LOWBAR)
            return this.call(this.parseNoUnder);
          {
            const result = Integer(this.state.buf);
            if (result.isNaN())
              throw this.error(new TomlError("Invalid number"));
            return this.returnNow(result);
          }
        }
      }
      parseIntegerBin() {
        if (isBit(this.char))
          this.consume();
        else {
          if (this.char === CHAR_LOWBAR)
            return this.call(this.parseNoUnder);
          {
            const result = Integer(this.state.buf);
            if (result.isNaN())
              throw this.error(new TomlError("Invalid number"));
            return this.returnNow(result);
          }
        }
      }
      /* DATETIME */
      parseDateTime() {
        if (this.state.buf.length < 4)
          throw this.error(new TomlError("Years less than 1000 must be zero padded to four characters"));
        return this.state.result = this.state.buf, this.state.buf = "", this.next(this.parseDateMonth);
      }
      parseDateMonth() {
        if (this.char === CHAR_HYPHEN) {
          if (this.state.buf.length < 2)
            throw this.error(new TomlError("Months less than 10 must be zero padded to two characters"));
          return this.state.result += "-" + this.state.buf, this.state.buf = "", this.next(this.parseDateDay);
        } else if (isDigit(this.char))
          this.consume();
        else
          throw this.error(new TomlError("Incomplete datetime"));
      }
      parseDateDay() {
        if (this.char === CHAR_T || this.char === CHAR_SP) {
          if (this.state.buf.length < 2)
            throw this.error(new TomlError("Days less than 10 must be zero padded to two characters"));
          return this.state.result += "-" + this.state.buf, this.state.buf = "", this.next(this.parseStartTimeHour);
        } else {
          if (this.atEndOfWord())
            return this.return(createDate(this.state.result + "-" + this.state.buf));
          if (isDigit(this.char))
            this.consume();
          else
            throw this.error(new TomlError("Incomplete datetime"));
        }
      }
      parseStartTimeHour() {
        return this.atEndOfWord() ? this.returnNow(createDate(this.state.result)) : this.goto(this.parseTimeHour);
      }
      parseTimeHour() {
        if (this.char === CHAR_COLON) {
          if (this.state.buf.length < 2)
            throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
          return this.state.result += "T" + this.state.buf, this.state.buf = "", this.next(this.parseTimeMin);
        } else if (isDigit(this.char))
          this.consume();
        else
          throw this.error(new TomlError("Incomplete datetime"));
      }
      parseTimeMin() {
        if (this.state.buf.length < 2 && isDigit(this.char))
          this.consume();
        else {
          if (this.state.buf.length === 2 && this.char === CHAR_COLON)
            return this.state.result += ":" + this.state.buf, this.state.buf = "", this.next(this.parseTimeSec);
          throw this.error(new TomlError("Incomplete datetime"));
        }
      }
      parseTimeSec() {
        if (isDigit(this.char)) {
          if (this.consume(), this.state.buf.length === 2)
            return this.state.result += ":" + this.state.buf, this.state.buf = "", this.next(this.parseTimeZoneOrFraction);
        } else
          throw this.error(new TomlError("Incomplete datetime"));
      }
      parseOnlyTimeHour() {
        if (this.char === CHAR_COLON) {
          if (this.state.buf.length < 2)
            throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
          return this.state.result = this.state.buf, this.state.buf = "", this.next(this.parseOnlyTimeMin);
        } else
          throw this.error(new TomlError("Incomplete time"));
      }
      parseOnlyTimeMin() {
        if (this.state.buf.length < 2 && isDigit(this.char))
          this.consume();
        else {
          if (this.state.buf.length === 2 && this.char === CHAR_COLON)
            return this.state.result += ":" + this.state.buf, this.state.buf = "", this.next(this.parseOnlyTimeSec);
          throw this.error(new TomlError("Incomplete time"));
        }
      }
      parseOnlyTimeSec() {
        if (isDigit(this.char)) {
          if (this.consume(), this.state.buf.length === 2)
            return this.next(this.parseOnlyTimeFractionMaybe);
        } else
          throw this.error(new TomlError("Incomplete time"));
      }
      parseOnlyTimeFractionMaybe() {
        if (this.state.result += ":" + this.state.buf, this.char === CHAR_PERIOD)
          this.state.buf = "", this.next(this.parseOnlyTimeFraction);
        else
          return this.return(createTime(this.state.result));
      }
      parseOnlyTimeFraction() {
        if (isDigit(this.char))
          this.consume();
        else if (this.atEndOfWord()) {
          if (this.state.buf.length === 0) throw this.error(new TomlError("Expected digit in milliseconds"));
          return this.returnNow(createTime(this.state.result + "." + this.state.buf));
        } else
          throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
      }
      parseTimeZoneOrFraction() {
        if (this.char === CHAR_PERIOD)
          this.consume(), this.next(this.parseDateTimeFraction);
        else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS)
          this.consume(), this.next(this.parseTimeZoneHour);
        else {
          if (this.char === CHAR_Z)
            return this.consume(), this.return(createDateTime(this.state.result + this.state.buf));
          if (this.atEndOfWord())
            return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
          throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
        }
      }
      parseDateTimeFraction() {
        if (isDigit(this.char))
          this.consume();
        else {
          if (this.state.buf.length === 1)
            throw this.error(new TomlError("Expected digit in milliseconds"));
          if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS)
            this.consume(), this.next(this.parseTimeZoneHour);
          else {
            if (this.char === CHAR_Z)
              return this.consume(), this.return(createDateTime(this.state.result + this.state.buf));
            if (this.atEndOfWord())
              return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
            throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
          }
        }
      }
      parseTimeZoneHour() {
        if (isDigit(this.char)) {
          if (this.consume(), /\d\d$/.test(this.state.buf)) return this.next(this.parseTimeZoneSep);
        } else
          throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
      }
      parseTimeZoneSep() {
        if (this.char === CHAR_COLON)
          this.consume(), this.next(this.parseTimeZoneMin);
        else
          throw this.error(new TomlError("Unexpected character in datetime, expected colon"));
      }
      parseTimeZoneMin() {
        if (isDigit(this.char)) {
          if (this.consume(), /\d\d$/.test(this.state.buf)) return this.return(createDateTime(this.state.result + this.state.buf));
        } else
          throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
      }
      /* BOOLEAN */
      parseBoolean() {
        if (this.char === CHAR_t)
          return this.consume(), this.next(this.parseTrue_r);
        if (this.char === CHAR_f)
          return this.consume(), this.next(this.parseFalse_a);
      }
      parseTrue_r() {
        if (this.char === CHAR_r)
          return this.consume(), this.next(this.parseTrue_u);
        throw this.error(new TomlError("Invalid boolean, expected true or false"));
      }
      parseTrue_u() {
        if (this.char === CHAR_u)
          return this.consume(), this.next(this.parseTrue_e);
        throw this.error(new TomlError("Invalid boolean, expected true or false"));
      }
      parseTrue_e() {
        if (this.char === CHAR_e)
          return this.return(!0);
        throw this.error(new TomlError("Invalid boolean, expected true or false"));
      }
      parseFalse_a() {
        if (this.char === CHAR_a)
          return this.consume(), this.next(this.parseFalse_l);
        throw this.error(new TomlError("Invalid boolean, expected true or false"));
      }
      parseFalse_l() {
        if (this.char === CHAR_l)
          return this.consume(), this.next(this.parseFalse_s);
        throw this.error(new TomlError("Invalid boolean, expected true or false"));
      }
      parseFalse_s() {
        if (this.char === CHAR_s)
          return this.consume(), this.next(this.parseFalse_e);
        throw this.error(new TomlError("Invalid boolean, expected true or false"));
      }
      parseFalse_e() {
        if (this.char === CHAR_e)
          return this.return(!1);
        throw this.error(new TomlError("Invalid boolean, expected true or false"));
      }
      /* INLINE LISTS */
      parseInlineList() {
        if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J)
          return null;
        if (this.char === Parser.END)
          throw this.error(new TomlError("Unterminated inline array"));
        return this.char === CHAR_NUM ? this.call(this.parseComment) : this.char === CHAR_RSQB ? this.return(this.state.resultArr || InlineList()) : this.callNow(this.parseValue, this.recordInlineListValue);
      }
      recordInlineListValue(value) {
        if (this.state.resultArr) {
          const listType = this.state.resultArr[_contentType], valueType = tomlType(value);
          if (listType !== valueType)
            throw this.error(new TomlError(`Inline lists must be a single type, not a mix of ${listType} and ${valueType}`));
        } else
          this.state.resultArr = InlineList(tomlType(value));
        return isFloat(value) || isInteger(value) ? this.state.resultArr.push(value.valueOf()) : this.state.resultArr.push(value), this.goto(this.parseInlineListNext);
      }
      parseInlineListNext() {
        if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J)
          return null;
        if (this.char === CHAR_NUM)
          return this.call(this.parseComment);
        if (this.char === CHAR_COMMA)
          return this.next(this.parseInlineList);
        if (this.char === CHAR_RSQB)
          return this.goto(this.parseInlineList);
        throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
      }
      /* INLINE TABLE */
      parseInlineTable() {
        if (this.char === CHAR_SP || this.char === CTRL_I)
          return null;
        if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M)
          throw this.error(new TomlError("Unterminated inline array"));
        return this.char === CHAR_RCUB ? this.return(this.state.resultTable || InlineTable()) : (this.state.resultTable || (this.state.resultTable = InlineTable()), this.callNow(this.parseAssign, this.recordInlineTableValue));
      }
      recordInlineTableValue(kv) {
        let target = this.state.resultTable, finalKey = kv.key.pop();
        for (let kw of kv.key) {
          if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared]))
            throw this.error(new TomlError("Can't redefine existing key"));
          target = target[kw] = target[kw] || Table();
        }
        if (hasKey(target, finalKey))
          throw this.error(new TomlError("Can't redefine existing key"));
        return isInteger(kv.value) || isFloat(kv.value) ? target[finalKey] = kv.value.valueOf() : target[finalKey] = kv.value, this.goto(this.parseInlineTableNext);
      }
      parseInlineTableNext() {
        if (this.char === CHAR_SP || this.char === CTRL_I)
          return null;
        if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M)
          throw this.error(new TomlError("Unterminated inline array"));
        if (this.char === CHAR_COMMA)
          return this.next(this.parseInlineTable);
        if (this.char === CHAR_RCUB)
          return this.goto(this.parseInlineTable);
        throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
      }
    }
    return TOMLParser;
  }
  return tomlParser.exports;
}
var parsePrettyError, hasRequiredParsePrettyError;
function requireParsePrettyError() {
  if (hasRequiredParsePrettyError) return parsePrettyError;
  hasRequiredParsePrettyError = 1, parsePrettyError = prettyError;
  function prettyError(err, buf) {
    if (err.pos == null || err.line == null) return err;
    let msg = err.message;
    if (msg += ` at row ${err.line + 1}, col ${err.col + 1}, pos ${err.pos}:
`, buf && buf.split) {
      const lines2 = buf.split(/\n/), lineNumWidth = String(Math.min(lines2.length, err.line + 3)).length;
      let linePadding = " ";
      for (; linePadding.length < lineNumWidth; ) linePadding += " ";
      for (let ii = Math.max(0, err.line - 1); ii < Math.min(lines2.length, err.line + 2); ++ii) {
        let lineNum = String(ii + 1);
        if (lineNum.length < lineNumWidth && (lineNum = " " + lineNum), err.line === ii) {
          msg += lineNum + "> " + lines2[ii] + `
`, msg += linePadding + "  ";
          for (let hh = 0; hh < err.col; ++hh)
            msg += " ";
          msg += `^
`;
        } else
          msg += lineNum + ": " + lines2[ii] + `
`;
      }
    }
    return err.message = msg + `
`, err;
  }
  return parsePrettyError;
}
var parseString_1, hasRequiredParseString;
function requireParseString() {
  if (hasRequiredParseString) return parseString_1;
  hasRequiredParseString = 1, parseString_1 = parseString;
  const TOMLParser = requireTomlParser(), prettyError = requireParsePrettyError();
  function parseString(str2) {
    loadEnv.commonjsGlobal.Buffer && loadEnv.commonjsGlobal.Buffer.isBuffer(str2) && (str2 = str2.toString("utf8"));
    const parser2 = new TOMLParser();
    try {
      return parser2.parse(str2), parser2.finish();
    } catch (err) {
      throw prettyError(err, str2);
    }
  }
  return parseString_1;
}
var parseAsync_1, hasRequiredParseAsync;
function requireParseAsync() {
  if (hasRequiredParseAsync) return parseAsync_1;
  hasRequiredParseAsync = 1, parseAsync_1 = parseAsync;
  const TOMLParser = requireTomlParser(), prettyError = requireParsePrettyError();
  function parseAsync(str2, opts) {
    opts || (opts = {});
    const index = 0, blocksize = opts.blocksize || 40960, parser2 = new TOMLParser();
    return new Promise((resolve, reject) => {
      setImmediate(parseAsyncNext, index, blocksize, resolve, reject);
    });
    function parseAsyncNext(index2, blocksize2, resolve, reject) {
      if (index2 >= str2.length)
        try {
          return resolve(parser2.finish());
        } catch (err) {
          return reject(prettyError(err, str2));
        }
      try {
        parser2.parse(str2.slice(index2, index2 + blocksize2)), setImmediate(parseAsyncNext, index2 + blocksize2, blocksize2, resolve, reject);
      } catch (err) {
        reject(prettyError(err, str2));
      }
    }
  }
  return parseAsync_1;
}
var parseStream_1, hasRequiredParseStream;
function requireParseStream() {
  if (hasRequiredParseStream) return parseStream_1;
  hasRequiredParseStream = 1, parseStream_1 = parseStream;
  const stream2 = require$$0__default$4.default, TOMLParser = requireTomlParser();
  function parseStream(stm) {
    return stm ? parseReadable(stm) : parseTransform();
  }
  function parseReadable(stm) {
    const parser2 = new TOMLParser();
    return stm.setEncoding("utf8"), new Promise((resolve, reject) => {
      let readable, ended = !1, errored = !1;
      function finish() {
        if (ended = !0, !readable)
          try {
            resolve(parser2.finish());
          } catch (err) {
            reject(err);
          }
      }
      function error2(err) {
        errored = !0, reject(err);
      }
      stm.once("end", finish), stm.once("error", error2), readNext();
      function readNext() {
        readable = !0;
        let data;
        for (; (data = stm.read()) !== null; )
          try {
            parser2.parse(data);
          } catch (err) {
            return error2(err);
          }
        if (readable = !1, ended) return finish();
        errored || stm.once("readable", readNext);
      }
    });
  }
  function parseTransform() {
    const parser2 = new TOMLParser();
    return new stream2.Transform({
      objectMode: !0,
      transform(chunk, encoding, cb) {
        try {
          parser2.parse(chunk.toString(encoding));
        } catch (err) {
          this.emit("error", err);
        }
        cb();
      },
      flush(cb) {
        try {
          this.push(parser2.finish());
        } catch (err) {
          this.emit("error", err);
        }
        cb();
      }
    });
  }
  return parseStream_1;
}
var hasRequiredParse$4;
function requireParse$4() {
  return hasRequiredParse$4 || (hasRequiredParse$4 = 1, parse$2.exports = requireParseString(), parse$2.exports.async = requireParseAsync(), parse$2.exports.stream = requireParseStream(), parse$2.exports.prettyError = requireParsePrettyError()), parse$2.exports;
}
var stringify$2 = { exports: {} }, hasRequiredStringify$1;
function requireStringify$1() {
  if (hasRequiredStringify$1) return stringify$2.exports;
  hasRequiredStringify$1 = 1, stringify$2.exports = stringify3, stringify$2.exports.value = stringifyInline;
  function stringify3(obj) {
    if (obj === null) throw typeError("null");
    if (obj === void 0) throw typeError("undefined");
    if (typeof obj != "object") throw typeError(typeof obj);
    if (typeof obj.toJSON == "function" && (obj = obj.toJSON()), obj == null) return null;
    const type2 = tomlType2(obj);
    if (type2 !== "table") throw typeError(type2);
    return stringifyObject("", "", obj);
  }
  function typeError(type2) {
    return new Error("Can only stringify objects, not " + type2);
  }
  function arrayOneTypeError() {
    return new Error("Array values can't have mixed types");
  }
  function getInlineKeys(obj) {
    return Object.keys(obj).filter((key2) => isInline(obj[key2]));
  }
  function getComplexKeys(obj) {
    return Object.keys(obj).filter((key2) => !isInline(obj[key2]));
  }
  function toJSON(obj) {
    let nobj = Array.isArray(obj) ? [] : Object.prototype.hasOwnProperty.call(obj, "__proto__") ? { ["__proto__"]: void 0 } : {};
    for (let prop of Object.keys(obj))
      obj[prop] && typeof obj[prop].toJSON == "function" && !("toISOString" in obj[prop]) ? nobj[prop] = obj[prop].toJSON() : nobj[prop] = obj[prop];
    return nobj;
  }
  function stringifyObject(prefix, indent, obj) {
    obj = toJSON(obj);
    var inlineKeys, complexKeys;
    inlineKeys = getInlineKeys(obj), complexKeys = getComplexKeys(obj);
    var result = [], inlineIndent = indent || "";
    inlineKeys.forEach((key2) => {
      var type2 = tomlType2(obj[key2]);
      type2 !== "undefined" && type2 !== "null" && result.push(inlineIndent + stringifyKey(key2) + " = " + stringifyAnyInline(obj[key2], !0));
    }), result.length > 0 && result.push("");
    var complexIndent = prefix && inlineKeys.length > 0 ? indent + "  " : "";
    return complexKeys.forEach((key2) => {
      result.push(stringifyComplex(prefix, complexIndent, key2, obj[key2]));
    }), result.join(`
`);
  }
  function isInline(value) {
    switch (tomlType2(value)) {
      case "undefined":
      case "null":
      case "integer":
      case "nan":
      case "float":
      case "boolean":
      case "string":
      case "datetime":
        return !0;
      case "array":
        return value.length === 0 || tomlType2(value[0]) !== "table";
      case "table":
        return Object.keys(value).length === 0;
      /* istanbul ignore next */
      default:
        return !1;
    }
  }
  function tomlType2(value) {
    return value === void 0 ? "undefined" : value === null ? "null" : typeof value == "bigint" || Number.isInteger(value) && !Object.is(value, -0) ? "integer" : typeof value == "number" ? "float" : typeof value == "boolean" ? "boolean" : typeof value == "string" ? "string" : "toISOString" in value ? isNaN(value) ? "undefined" : "datetime" : Array.isArray(value) ? "array" : "table";
  }
  function stringifyKey(key2) {
    var keyStr = String(key2);
    return /^[-A-Za-z0-9_]+$/.test(keyStr) ? keyStr : stringifyBasicString(keyStr);
  }
  function stringifyBasicString(str2) {
    return '"' + escapeString(str2).replace(/"/g, '\\"') + '"';
  }
  function stringifyLiteralString(str2) {
    return "'" + str2 + "'";
  }
  function numpad(num, str2) {
    for (; str2.length < num; ) str2 = "0" + str2;
    return str2;
  }
  function escapeString(str2) {
    return str2.replace(/\\/g, "\\\\").replace(/[\b]/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/([\u0000-\u001f\u007f])/, (c2) => "\\u" + numpad(4, c2.codePointAt(0).toString(16)));
  }
  function stringifyMultilineString(str2) {
    let escaped = str2.split(/\n/).map((str3) => escapeString(str3).replace(/"(?="")/g, '\\"')).join(`
`);
    return escaped.slice(-1) === '"' && (escaped += `\\
`), `"""
` + escaped + '"""';
  }
  function stringifyAnyInline(value, multilineOk) {
    let type2 = tomlType2(value);
    return type2 === "string" && (multilineOk && /\n/.test(value) ? type2 = "string-multiline" : !/[\b\t\n\f\r']/.test(value) && /"/.test(value) && (type2 = "string-literal")), stringifyInline(value, type2);
  }
  function stringifyInline(value, type2) {
    switch (type2 || (type2 = tomlType2(value)), type2) {
      case "string-multiline":
        return stringifyMultilineString(value);
      case "string":
        return stringifyBasicString(value);
      case "string-literal":
        return stringifyLiteralString(value);
      case "integer":
        return stringifyInteger(value);
      case "float":
        return stringifyFloat(value);
      case "boolean":
        return stringifyBoolean(value);
      case "datetime":
        return stringifyDatetime(value);
      case "array":
        return stringifyInlineArray(value.filter((_) => tomlType2(_) !== "null" && tomlType2(_) !== "undefined" && tomlType2(_) !== "nan"));
      case "table":
        return stringifyInlineTable(value);
      /* istanbul ignore next */
      default:
        throw typeError(type2);
    }
  }
  function stringifyInteger(value) {
    return String(value).replace(/\B(?=(\d{3})+(?!\d))/g, "_");
  }
  function stringifyFloat(value) {
    if (value === 1 / 0)
      return "inf";
    if (value === -1 / 0)
      return "-inf";
    if (Object.is(value, NaN))
      return "nan";
    if (Object.is(value, -0))
      return "-0.0";
    var chunks = String(value).split("."), int2 = chunks[0], dec = chunks[1] || 0;
    return stringifyInteger(int2) + "." + dec;
  }
  function stringifyBoolean(value) {
    return String(value);
  }
  function stringifyDatetime(value) {
    return value.toISOString();
  }
  function isNumber2(type2) {
    return type2 === "float" || type2 === "integer";
  }
  function arrayType(values) {
    var contentType = tomlType2(values[0]);
    return values.every((_) => tomlType2(_) === contentType) ? contentType : values.every((_) => isNumber2(tomlType2(_))) ? "float" : "mixed";
  }
  function validateArray(values) {
    const type2 = arrayType(values);
    if (type2 === "mixed")
      throw arrayOneTypeError();
    return type2;
  }
  function stringifyInlineArray(values) {
    values = toJSON(values);
    const type2 = validateArray(values);
    var result = "[", stringified = values.map((_) => stringifyInline(_, type2));
    return stringified.join(", ").length > 60 || /\n/.test(stringified) ? result += `
  ` + stringified.join(`,
  `) + `
` : result += " " + stringified.join(", ") + (stringified.length > 0 ? " " : ""), result + "]";
  }
  function stringifyInlineTable(value) {
    value = toJSON(value);
    var result = [];
    return Object.keys(value).forEach((key2) => {
      result.push(stringifyKey(key2) + " = " + stringifyAnyInline(value[key2], !1));
    }), "{ " + result.join(", ") + (result.length > 0 ? " " : "") + "}";
  }
  function stringifyComplex(prefix, indent, key2, value) {
    var valueType = tomlType2(value);
    if (valueType === "array")
      return stringifyArrayOfTables(prefix, indent, key2, value);
    if (valueType === "table")
      return stringifyComplexTable(prefix, indent, key2, value);
    throw typeError(valueType);
  }
  function stringifyArrayOfTables(prefix, indent, key2, values) {
    values = toJSON(values), validateArray(values);
    var firstValueType = tomlType2(values[0]);
    if (firstValueType !== "table") throw typeError(firstValueType);
    var fullKey = prefix + stringifyKey(key2), result = "";
    return values.forEach((table) => {
      result.length > 0 && (result += `
`), result += indent + "[[" + fullKey + `]]
`, result += stringifyObject(fullKey + ".", indent, table);
    }), result;
  }
  function stringifyComplexTable(prefix, indent, key2, value) {
    var fullKey = prefix + stringifyKey(key2), result = "";
    return getInlineKeys(value).length > 0 && (result += indent + "[" + fullKey + `]
`), result + stringifyObject(fullKey + ".", indent, value);
  }
  return stringify$2.exports;
}
var hasRequiredToml;
function requireToml() {
  return hasRequiredToml || (hasRequiredToml = 1, toml.parse = requireParse$4(), toml.stringify = requireStringify$1()), toml;
}
var dist$2 = {}, hasRequiredDist$1;
function requireDist$1() {
  return hasRequiredDist$1 || (hasRequiredDist$1 = 1, function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.isSpawnError = exports2.normalizeError = exports2.errorToString = exports2.isErrorLike = exports2.isErrnoException = exports2.isError = exports2.isObject = void 0;
    const isObject2 = (obj) => typeof obj == "object" && obj !== null;
    exports2.isObject = isObject2;
    const isError = (error2) => {
      if (!(0, exports2.isObject)(error2))
        return !1;
      if (error2 instanceof Error)
        return !0;
      for (; error2; ) {
        if (Object.prototype.toString.call(error2) === "[object Error]")
          return !0;
        error2 = Object.getPrototypeOf(error2);
      }
      return !1;
    };
    exports2.isError = isError;
    const isErrnoException = (error2) => (0, exports2.isError)(error2) && "code" in error2;
    exports2.isErrnoException = isErrnoException;
    const isErrorLike = (error2) => (0, exports2.isObject)(error2) && "message" in error2;
    exports2.isErrorLike = isErrorLike;
    const errorToString = (error2, fallback) => (0, exports2.isError)(error2) || (0, exports2.isErrorLike)(error2) ? error2.message : typeof error2 == "string" ? error2 : fallback ?? "An unknown error has ocurred.";
    exports2.errorToString = errorToString;
    const normalizeError = (error2) => {
      if ((0, exports2.isError)(error2))
        return error2;
      const errorMessage = (0, exports2.errorToString)(error2);
      return (0, exports2.isErrorLike)(error2) ? Object.assign(new Error(errorMessage), error2) : new Error(errorMessage);
    };
    exports2.normalizeError = normalizeError;
    function isSpawnError(v) {
      return (0, exports2.isErrnoException)(v) && "spawnargs" in v;
    }
    exports2.isSpawnError = isSpawnError;
  }(dist$2)), dist$2;
}
var hasRequiredReadConfigFile;
function requireReadConfigFile() {
  if (hasRequiredReadConfigFile) return readConfigFile;
  hasRequiredReadConfigFile = 1;
  var __importDefault2 = readConfigFile && readConfigFile.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(readConfigFile, "__esModule", { value: !0 }), readConfigFile.readConfigFile = void 0;
  const js_yaml_1 = __importDefault2(requireJsYaml$3()), toml_1 = __importDefault2(requireToml()), fs_1 = require$$0__default.default, error_utils_1 = requireDist$1(), { readFile } = fs_1.promises;
  async function readFileOrNull(file) {
    try {
      return await readFile(file);
    } catch (error2) {
      if (!(0, error_utils_1.isErrnoException)(error2) || error2.code !== "ENOENT")
        throw error2;
    }
    return null;
  }
  async function readConfigFile$1(files) {
    files = Array.isArray(files) ? files : [files];
    for (const name of files) {
      const data = await readFileOrNull(name);
      if (data) {
        const str2 = data.toString("utf8");
        if (name.endsWith(".json"))
          return JSON.parse(str2);
        if (name.endsWith(".toml"))
          return toml_1.default.parse(str2);
        if (name.endsWith(".yaml") || name.endsWith(".yml"))
          return js_yaml_1.default.safeLoad(str2, { filename: name });
      }
    }
    return null;
  }
  return readConfigFile.readConfigFile = readConfigFile$1, readConfigFile;
}
var types$3 = {}, hasRequiredTypes$2;
function requireTypes$2() {
  return hasRequiredTypes$2 || (hasRequiredTypes$2 = 1, Object.defineProperty(types$3, "__esModule", { value: !0 })), types$3;
}
var hasRequiredFrameworks;
function requireFrameworks() {
  return hasRequiredFrameworks || (hasRequiredFrameworks = 1, function(exports2) {
    var __createBinding2 = frameworks && frameworks.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar2 = frameworks && frameworks.__exportStar || function(m, exports3) {
      for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p) && __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.frameworks = void 0;
    const path_1 = require$$0__default$1.default, fs_1 = require$$0__default.default, read_config_file_1 = requireReadConfigFile();
    __exportStar2(requireTypes$2(), exports2);
    const { readdir: readdir2, readFile, unlink: unlink2 } = fs_1.promises;
    exports2.frameworks = [
      {
        name: "Blitz.js (Legacy)",
        slug: "blitzjs",
        demo: "https://blitz-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/blitz.svg",
        tagline: "Blitz.js: The Fullstack React Framework",
        description: "A brand new Blitz.js app - the result of running `npx blitz@0.45.4 new`.",
        website: "https://blitzjs.com",
        envPrefix: "NEXT_PUBLIC_",
        useRuntime: { src: "package.json", use: "@vercel/next" },
        detectors: {
          some: [
            // Intentionally does not detect a package name
            // https://github.com/vercel/vercel/pull/8432
            {
              path: "blitz.config.js"
            },
            {
              path: "blitz.config.ts"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `blitz build`",
            value: "blitz build"
          },
          devCommand: {
            value: "blitz start"
          },
          outputDirectory: {
            placeholder: "Next.js default"
          }
        },
        getOutputDirName: async () => "public"
      },
      {
        name: "Next.js",
        slug: "nextjs",
        demo: "https://nextjs-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/next.svg",
        darkModeLogo: "https://api-frameworks.vercel.sh/framework-logos/next-dark.svg",
        screenshot: "https://assets.vercel.com/image/upload/v1673027027/front/import/nextjs.png",
        tagline: "Next.js makes you productive with React instantly \u2014 whether you want to build static or dynamic sites.",
        description: "A Next.js app and a Serverless Function API.",
        website: "https://nextjs.org",
        sort: 1,
        envPrefix: "NEXT_PUBLIC_",
        useRuntime: { src: "package.json", use: "@vercel/next" },
        detectors: {
          every: [
            {
              matchPackage: "next"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `next build`",
            value: "next build"
          },
          devCommand: {
            value: "next dev --port $PORT",
            placeholder: "next"
          },
          outputDirectory: {
            placeholder: "Next.js default"
          }
        },
        recommendedIntegrations: [
          {
            id: "oac_5lUsiANun1DEzgLg0NZx5Es3",
            dependencies: ["next-plugin-sentry", "next-sentry-source-maps"]
          }
        ],
        getOutputDirName: async () => "public",
        cachePattern: ".next/cache/**"
      },
      {
        name: "Gatsby.js",
        slug: "gatsby",
        demo: "https://gatsby.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/gatsby.svg",
        tagline: "Gatsby helps developers build blazing fast websites and apps with React.",
        description: "A Gatsby starter app with an API Route.",
        website: "https://gatsbyjs.org",
        sort: 5,
        envPrefix: "GATSBY_",
        detectors: {
          every: [
            {
              matchPackage: "gatsby"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `gatsby build`",
            value: "gatsby build"
          },
          devCommand: {
            value: "gatsby develop --port $PORT",
            placeholder: "gatsby develop"
          },
          outputDirectory: {
            value: "public"
          }
        },
        dependency: "gatsby",
        getOutputDirName: async () => "public",
        defaultRoutes: async (dirPrefix) => {
          try {
            const nowRoutesPath = (0, path_1.join)(dirPrefix, "public", "__now_routes_g4t5bY.json"), content = await readFile(nowRoutesPath, "utf8"), nowRoutes = JSON.parse(content);
            try {
              await unlink2(nowRoutesPath);
            } catch {
            }
            return nowRoutes;
          } catch {
            return [
              {
                src: "^/static/(.*)$",
                headers: { "cache-control": "public,max-age=31536000,immutable" },
                continue: !0
              },
              {
                src: "^/.*\\.(js|css)$",
                headers: { "cache-control": "public,max-age=31536000,immutable" },
                continue: !0
              },
              {
                src: "^/(sw\\.js|app-data\\.json|.*\\.html|page-data/.*)$",
                headers: { "cache-control": "public,max-age=0,must-revalidate" },
                continue: !0
              },
              {
                handle: "filesystem"
              },
              {
                src: ".*",
                status: 404,
                dest: "404.html"
              }
            ];
          }
        },
        cachePattern: "{.cache,public}/**"
      },
      {
        name: "Remix",
        slug: "remix",
        demo: "https://remix-run-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/remix-no-shadow.svg",
        tagline: "Build Better Websites",
        description: "A new Remix app \u2014 the result of running `npx create-remix`.",
        website: "https://remix.run",
        sort: 6,
        useRuntime: { src: "package.json", use: "@vercel/remix-builder" },
        ignoreRuntimes: ["@vercel/node"],
        detectors: {
          some: [
            {
              path: "remix.config.js"
            },
            {
              path: "remix.config.mjs"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            value: "remix build",
            placeholder: "`npm run build` or `remix build`"
          },
          devCommand: {
            value: "remix dev",
            placeholder: "remix dev"
          },
          outputDirectory: {
            value: "public"
          }
        },
        dependency: "remix",
        getOutputDirName: async () => "public"
      },
      {
        name: "Astro",
        slug: "astro",
        demo: "https://astro-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/astro.svg",
        darkModeLogo: "https://api-frameworks.vercel.sh/framework-logos/astro-dark.svg",
        tagline: "Astro is a new kind of static site builder for the modern web. Powerful developer experience meets lightweight output.",
        description: "An Astro site, using the basics starter kit.",
        website: "https://astro.build",
        envPrefix: "PUBLIC_",
        detectors: {
          every: [
            {
              matchPackage: "astro"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install` or `npm install`"
          },
          buildCommand: {
            value: "astro build",
            placeholder: "`npm run build` or `astro build`"
          },
          devCommand: {
            value: "astro dev --port $PORT",
            placeholder: "astro dev"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "astro",
        getOutputDirName: async () => "dist",
        defaultRoutes: [
          {
            src: "^/assets/(.*)$",
            headers: { "cache-control": "public, max-age=31536000, immutable" },
            continue: !0
          },
          {
            src: "^/_astro/(.*)$",
            headers: { "cache-control": "public, max-age=31536000, immutable" },
            continue: !0
          }
        ]
      },
      {
        name: "Hexo",
        slug: "hexo",
        demo: "https://hexo-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/hexo.svg",
        tagline: "Hexo is a fast, simple & powerful blog framework powered by Node.js.",
        description: "A Hexo site, created with the Hexo CLI.",
        website: "https://hexo.io",
        detectors: {
          every: [
            {
              matchPackage: "hexo"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `hexo generate`",
            value: "hexo generate"
          },
          devCommand: {
            value: "hexo server --port $PORT",
            placeholder: "hexo server"
          },
          outputDirectory: {
            value: "public"
          }
        },
        dependency: "hexo",
        getOutputDirName: async () => "public"
      },
      {
        name: "Eleventy",
        slug: "eleventy",
        demo: "https://eleventy-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/eleventy.svg",
        tagline: "11ty is a simpler static site generator written in JavaScript, created to be an alternative to Jekyll.",
        description: "An Eleventy site, created with npm init.",
        website: "https://www.11ty.dev",
        detectors: {
          every: [
            {
              matchPackage: "@11ty/eleventy"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `npx @11ty/eleventy`",
            value: "npx @11ty/eleventy"
          },
          devCommand: {
            value: "npx @11ty/eleventy --serve --watch --port $PORT",
            placeholder: "npx @11ty/eleventy --serve"
          },
          outputDirectory: {
            value: "_site"
          }
        },
        dependency: "@11ty/eleventy",
        getOutputDirName: async () => "_site",
        cachePattern: ".cache/**"
      },
      {
        name: "Docusaurus (v2)",
        slug: "docusaurus-2",
        demo: "https://docusaurus-2-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/docusaurus.svg",
        tagline: "Docusaurus makes it easy to maintain Open Source documentation websites.",
        description: "A static Docusaurus site that makes it easy to maintain OSS documentation.",
        website: "https://v2.docusaurus.io",
        detectors: {
          some: [
            {
              matchPackage: "@docusaurus/core"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `docusaurus build`",
            value: "docusaurus build"
          },
          devCommand: {
            value: "docusaurus start --port $PORT",
            placeholder: "docusaurus start"
          },
          outputDirectory: {
            value: "build"
          }
        },
        dependency: "@docusaurus/core",
        getOutputDirName: async (dirPrefix) => {
          const base2 = "build";
          try {
            const location = (0, path_1.join)(dirPrefix, base2), content = await readdir2(location, { withFileTypes: !0 });
            if (content.length === 1 && content[0].isDirectory())
              return (0, path_1.join)(base2, content[0].name);
          } catch (error2) {
            console.error("Error detecting output directory: ", error2);
          }
          return base2;
        },
        defaultRoutes: [
          {
            src: "^/[^./]+\\.[0-9a-f]{8}\\.(css|js)$",
            headers: { "cache-control": "max-age=31536000, immutable" },
            continue: !0
          },
          {
            src: "^/assets/images/[^/]+-[0-9a-f]{32}\\.(ico|svg|jpg|jpeg|png|gif|webp)$",
            headers: { "cache-control": "max-age=31536000, immutable" },
            continue: !0
          },
          {
            src: "^/assets/medias/[^/]+-[0-9a-f]{32}\\.(ogv|wav|mp3|m4a|aac|oga|flac)$",
            headers: { "cache-control": "max-age=31536000, immutable" },
            continue: !0
          },
          {
            src: "^/assets/files/[^/]+-[0-9a-f]{32}\\.(pdf|doc|docx|xls|xlsx|zip|rar)$",
            headers: { "cache-control": "max-age=31536000, immutable" },
            continue: !0
          },
          {
            src: "^/ideal-img/[^/]+\\.[0-9a-f]{7}\\.\\d+\\.(png|jpe?g|gif)$",
            headers: { "cache-control": "max-age=31536000, immutable" },
            continue: !0
          },
          {
            handle: "filesystem"
          },
          {
            src: ".*",
            status: 404,
            dest: "404.html"
          }
        ]
      },
      {
        name: "Docusaurus (v1)",
        slug: "docusaurus",
        demo: "https://docusaurus-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/docusaurus.svg",
        tagline: "Docusaurus makes it easy to maintain Open Source documentation websites.",
        description: "A static Docusaurus site that makes it easy to maintain OSS documentation.",
        website: "https://docusaurus.io/",
        detectors: {
          some: [
            {
              matchPackage: "docusaurus"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `docusaurus-build`",
            value: "docusaurus-build"
          },
          devCommand: {
            value: "docusaurus-start --port $PORT",
            placeholder: "docusaurus-start"
          },
          outputDirectory: {
            value: "build"
          }
        },
        dependency: "docusaurus",
        getOutputDirName: async (dirPrefix) => {
          const base2 = "build";
          try {
            const location = (0, path_1.join)(dirPrefix, base2), content = await readdir2(location, { withFileTypes: !0 });
            if (content.length === 1 && content[0].isDirectory())
              return (0, path_1.join)(base2, content[0].name);
          } catch (error2) {
            console.error("Error detecting output directory: ", error2);
          }
          return base2;
        }
      },
      {
        name: "Preact",
        slug: "preact",
        demo: "https://preact-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/preact.svg",
        tagline: "Preact is a fast 3kB alternative to React with the same modern API.",
        description: "A Preact app, created with the Preact CLI.",
        website: "https://preactjs.com",
        detectors: {
          every: [
            // Intentionally does not detect "preact" package because that can be
            // used to power other frameworks.
            {
              matchPackage: "preact-cli"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `preact build`",
            value: "preact build"
          },
          devCommand: {
            value: "preact watch --port $PORT",
            placeholder: "preact watch"
          },
          outputDirectory: {
            value: "build"
          }
        },
        dependency: "preact-cli",
        getOutputDirName: async () => "build",
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "SolidStart",
        slug: "solidstart",
        demo: "https://solid-start-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/solid.svg",
        tagline: "Simple and performant reactivity for building user interfaces.",
        description: "A Solid app, created with SolidStart.",
        website: "https://solidjs.com",
        envPrefix: "VITE_",
        detectors: {
          every: [
            {
              matchPackage: "solid-js"
            },
            {
              matchPackage: "solid-start"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `solid-start build`",
            value: "solid-start build"
          },
          devCommand: {
            value: "solid-start dev"
          },
          outputDirectory: {
            value: ".output"
          }
        },
        getOutputDirName: async () => ".output"
      },
      {
        name: "Dojo",
        slug: "dojo",
        demo: "https://dojo-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/dojo.png",
        tagline: "Dojo is a modern progressive, TypeScript first framework.",
        description: "A Dojo app, created with the Dojo CLI's cli-create-app command.",
        website: "https://dojo.io",
        detectors: {
          some: [
            {
              matchPackage: "@dojo/framework"
            },
            {
              path: ".dojorc"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `dojo build`",
            value: "dojo build"
          },
          devCommand: {
            value: "dojo build -m dev -w -s -p $PORT",
            placeholder: "dojo build -m dev -w -s"
          },
          outputDirectory: {
            value: "output/dist"
          }
        },
        dependency: "@dojo/cli",
        getOutputDirName: async () => (0, path_1.join)("output", "dist"),
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/service-worker.js",
            headers: { "cache-control": "s-maxage=0" },
            continue: !0
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ],
        defaulHeaders: [
          {
            source: "/service-worker.js",
            regex: "/service-worker.js",
            headers: { "cache-control": "s-maxage=0" },
            continue: !0
          }
        ]
      },
      {
        name: "Ember.js",
        slug: "ember",
        demo: "https://ember-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/ember.svg",
        tagline: "Ember.js helps webapp developers be more productive out of the box.",
        description: "An Ember app, created with the Ember CLI.",
        website: "https://emberjs.com/",
        detectors: {
          some: [
            {
              matchPackage: "ember-source"
            },
            {
              matchPackage: "ember-cli"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `ember build`",
            value: "ember build"
          },
          devCommand: {
            value: "ember serve --port $PORT",
            placeholder: "ember serve"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "ember-cli",
        getOutputDirName: async () => "dist",
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Vue.js",
        slug: "vue",
        demo: "https://vue-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/vue.svg",
        tagline: "Vue.js is a versatile JavaScript framework that is as approachable as it is performant.",
        description: "A Vue.js app, created with the Vue CLI.",
        website: "https://vuejs.org",
        envPrefix: "VUE_APP_",
        detectors: {
          every: [
            {
              matchPackage: "@vue/cli-service"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `vue-cli-service build`",
            value: "vue-cli-service build"
          },
          devCommand: {
            value: "vue-cli-service serve --port $PORT",
            placeholder: "vue-cli-service serve"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "@vue/cli-service",
        getOutputDirName: async () => "dist",
        defaultRoutes: [
          {
            src: "^/[^/]*\\.(js|txt|ico|json)",
            headers: { "cache-control": "max-age=300" },
            continue: !0
          },
          {
            src: "^/(img|js|css|fonts|media)/[^/]+\\.[0-9a-f]{8}\\.*",
            headers: { "cache-control": "max-age=31536000, immutable" },
            continue: !0
          },
          {
            handle: "filesystem"
          },
          {
            src: "^.*",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Scully",
        slug: "scully",
        demo: "https://scully-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/scullyio-logo.png",
        tagline: "Scully is a static site generator for Angular.",
        description: "The Static Site Generator for Angular apps.",
        website: "https://github.com/scullyio/scully",
        detectors: {
          every: [
            {
              matchPackage: "@scullyio/init"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `ng build && scully`",
            value: "ng build && scully"
          },
          devCommand: {
            value: "ng serve --port $PORT",
            placeholder: "ng serve"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "@scullyio/init",
        getOutputDirName: async () => "dist/static"
      },
      {
        name: "Ionic Angular",
        slug: "ionic-angular",
        demo: "https://ionic-angular-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/ionic.svg",
        tagline: "Ionic Angular allows you to build mobile PWAs with Angular and the Ionic Framework.",
        description: "An Ionic Angular site, created with the Ionic CLI.",
        website: "https://ionicframework.com",
        detectors: {
          every: [
            {
              matchPackage: "@ionic/angular"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `ng build`",
            value: "ng build"
          },
          devCommand: {
            value: "ng serve --port $PORT"
          },
          outputDirectory: {
            value: "www"
          }
        },
        dependency: "@ionic/angular",
        getOutputDirName: async () => "www",
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Angular",
        slug: "angular",
        demo: "https://angular-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/angular.svg",
        tagline: "Angular is a TypeScript-based cross-platform framework from Google.",
        description: "An Angular app, created with the Angular CLI.",
        website: "https://angular.io",
        detectors: {
          every: [
            {
              matchPackage: "@angular/cli"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `ng build`",
            value: "ng build"
          },
          devCommand: {
            value: "ng serve --port $PORT",
            placeholder: "ng serve"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "@angular/cli",
        getOutputDirName: async (dirPrefix) => {
          const base2 = "dist";
          try {
            const location = (0, path_1.join)(dirPrefix, base2), content = await readdir2(location, { withFileTypes: !0 });
            if (content.length === 1 && content[0].isDirectory())
              return (0, path_1.join)(base2, content[0].name);
          } catch (error2) {
            console.error("Error detecting output directory: ", error2);
          }
          return base2;
        },
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Polymer",
        slug: "polymer",
        demo: "https://polymer-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/polymer.svg",
        tagline: "Polymer is an open-source webapps library from Google, for building using Web Components.",
        description: "A Polymer app, created with the Polymer CLI.",
        website: "https://www.polymer-project.org/",
        detectors: {
          every: [
            {
              matchPackage: "polymer-cli"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `polymer build`",
            value: "polymer build"
          },
          devCommand: {
            value: "polymer serve --port $PORT",
            placeholder: "polymer serve"
          },
          outputDirectory: {
            value: "build"
          }
        },
        dependency: "polymer-cli",
        getOutputDirName: async (dirPrefix) => {
          const base2 = "build";
          try {
            const location = (0, path_1.join)(dirPrefix, base2), paths = (await readdir2(location)).filter((item) => !item.includes("."));
            return (0, path_1.join)(base2, paths[0]);
          } catch (error2) {
            console.error("Error detecting output directory: ", error2);
          }
          return base2;
        },
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Svelte",
        slug: "svelte",
        demo: "https://svelte.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/svelte.svg",
        tagline: "Svelte lets you write high performance reactive apps with significantly less boilerplate.",
        description: "A basic Svelte app using the default template.",
        website: "https://svelte.dev",
        sort: 3,
        detectors: {
          every: [
            {
              matchPackage: "svelte"
            },
            {
              matchPackage: "sirv-cli"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `rollup -c`",
            value: "rollup -c"
          },
          devCommand: {
            value: "rollup -c -w"
          },
          outputDirectory: {
            value: "public"
          }
        },
        dependency: "sirv-cli",
        getOutputDirName: async () => "public",
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        // TODO: fix detected as "sveltekit-1"
        name: "SvelteKit (v0)",
        slug: "sveltekit",
        demo: "https://sveltekit-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/svelte.svg",
        screenshot: "https://assets.vercel.com/image/upload/v1647366075/front/import/sveltekit.png",
        tagline: "SvelteKit is a framework for building web applications of all sizes.",
        description: "A SvelteKit legacy app optimized Edge-first.",
        website: "https://kit.svelte.dev",
        sort: 99,
        envPrefix: "VITE_",
        detectors: {
          every: [
            {
              path: "package.json",
              matchContent: '"(dev)?(d|D)ependencies":\\s*{[^}]*"@sveltejs\\/kit":\\s*"1\\.0\\.0-next\\.(\\d+)"[^}]*}'
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `svelte-kit build`",
            value: "svelte-kit build"
          },
          devCommand: {
            value: "svelte-kit dev --port $PORT",
            placeholder: "svelte-kit dev"
          },
          outputDirectory: {
            value: "public"
          }
        },
        getOutputDirName: async () => "public"
      },
      {
        name: "SvelteKit (v1)",
        slug: "sveltekit-1",
        demo: "https://sveltekit-1-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/svelte.svg",
        screenshot: "https://assets.vercel.com/image/upload/v1647366075/front/import/sveltekit.png",
        tagline: "SvelteKit is a framework for building web applications of all sizes.",
        description: "A SvelteKit app optimized Edge-first.",
        website: "https://kit.svelte.dev",
        detectors: {
          every: [
            {
              path: "package.json",
              matchContent: '"(dev)?(d|D)ependencies":\\s*{[^}]*"@sveltejs\\/kit":\\s*".+?"[^}]*}'
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "vite build",
            value: "vite build"
          },
          devCommand: {
            placeholder: "vite dev",
            value: "vite dev --port $PORT"
          },
          outputDirectory: {
            value: "public"
          }
        },
        getOutputDirName: async () => "public"
      },
      {
        name: "Ionic React",
        slug: "ionic-react",
        demo: "https://ionic-react-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/ionic.svg",
        tagline: "Ionic React allows you to build mobile PWAs with React and the Ionic Framework.",
        description: "An Ionic React site, created with the Ionic CLI.",
        website: "https://ionicframework.com",
        detectors: {
          every: [
            {
              matchPackage: "@ionic/react"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `react-scripts build`",
            value: "react-scripts build"
          },
          devCommand: {
            value: "react-scripts start"
          },
          outputDirectory: {
            value: "build"
          }
        },
        dependency: "@ionic/react",
        getOutputDirName: async () => "build",
        defaultRoutes: [
          {
            src: "/static/(.*)",
            headers: { "cache-control": "s-maxage=31536000, immutable" },
            continue: !0
          },
          {
            src: "/service-worker.js",
            headers: { "cache-control": "s-maxage=0" },
            continue: !0
          },
          {
            src: "/sockjs-node/(.*)",
            dest: "/sockjs-node/$1"
          },
          {
            handle: "filesystem"
          },
          { src: "/static/(.*)", status: 404, dest: "/404.html" },
          {
            src: "/(.*)",
            headers: { "cache-control": "s-maxage=0" },
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Create React App",
        slug: "create-react-app",
        demo: "https://create-react-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/react.svg",
        tagline: "Create React App allows you to get going with React in no time.",
        description: "A client-side React app created with create-react-app.",
        website: "https://create-react-app.dev",
        sort: 4,
        envPrefix: "REACT_APP_",
        detectors: {
          some: [
            {
              matchPackage: "react-scripts"
            },
            {
              matchPackage: "react-dev-utils"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `react-scripts build`",
            value: "react-scripts build"
          },
          devCommand: {
            value: "react-scripts start"
          },
          outputDirectory: {
            value: "build"
          }
        },
        dependency: "react-scripts",
        getOutputDirName: async () => "build",
        defaultRoutes: [
          {
            src: "/static/(.*)",
            headers: { "cache-control": "s-maxage=31536000, immutable" },
            continue: !0
          },
          {
            src: "/service-worker.js",
            headers: { "cache-control": "s-maxage=0" },
            continue: !0
          },
          {
            src: "/sockjs-node/(.*)",
            dest: "/sockjs-node/$1"
          },
          {
            handle: "filesystem"
          },
          { src: "/static/(.*)", status: 404, dest: "/404.html" },
          {
            src: "/(.*)",
            headers: { "cache-control": "s-maxage=0" },
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Gridsome",
        slug: "gridsome",
        demo: "https://gridsome-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/gridsome.svg",
        tagline: "Gridsome is a Vue.js-powered framework for building websites & apps that are fast by default.",
        description: "A Gridsome app, created with the Gridsome CLI.",
        website: "https://gridsome.org/",
        detectors: {
          every: [
            {
              matchPackage: "gridsome"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `gridsome build`",
            value: "gridsome build"
          },
          devCommand: {
            value: "gridsome develop -p $PORT",
            placeholder: "gridsome develop"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "gridsome",
        getOutputDirName: async () => "dist"
      },
      {
        name: "UmiJS",
        slug: "umijs",
        demo: "https://umijs-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/umi.svg",
        tagline: "UmiJS is an extensible enterprise-level React application framework.",
        description: "An UmiJS app, created using the Umi CLI.",
        website: "https://umijs.org",
        detectors: {
          every: [
            {
              matchPackage: "umi"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `umi build`",
            value: "umi build"
          },
          devCommand: {
            value: "umi dev --port $PORT",
            placeholder: "umi dev"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "umi",
        getOutputDirName: async () => "dist",
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Sapper",
        slug: "sapper",
        demo: "https://sapper-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/svelte.svg",
        tagline: "Sapper is a framework for building high-performance universal web apps with Svelte.",
        description: "A Sapper app, using the Sapper template.",
        website: "https://sapper.svelte.dev",
        detectors: {
          every: [
            {
              matchPackage: "sapper"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `sapper export`",
            value: "sapper export"
          },
          devCommand: {
            value: "sapper dev --port $PORT",
            placeholder: "sapper dev"
          },
          outputDirectory: {
            value: "__sapper__/export"
          }
        },
        dependency: "sapper",
        getOutputDirName: async () => "__sapper__/export"
      },
      {
        name: "Saber",
        slug: "saber",
        demo: "https://saber-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/saber.svg",
        tagline: "Saber is a framework for building static sites in Vue.js that supports data from any source.",
        description: "A Saber site, created with npm init.",
        website: "https://saber.egoist.dev",
        detectors: {
          every: [
            {
              matchPackage: "saber"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `saber build`",
            value: "saber build"
          },
          devCommand: {
            value: "saber --port $PORT",
            placeholder: "saber"
          },
          outputDirectory: {
            value: "public"
          }
        },
        dependency: "saber",
        getOutputDirName: async () => "public",
        defaultRoutes: [
          {
            src: "/_saber/.*",
            headers: { "cache-control": "max-age=31536000, immutable" }
          },
          {
            handle: "filesystem"
          },
          {
            src: ".*",
            status: 404,
            dest: "404.html"
          }
        ]
      },
      {
        name: "Stencil",
        slug: "stencil",
        demo: "https://stencil.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/stencil.svg",
        tagline: "Stencil is a powerful toolchain for building Progressive Web Apps and Design Systems.",
        description: "A Stencil site, created with the Stencil CLI.",
        website: "https://stenciljs.com/",
        detectors: {
          every: [
            {
              matchPackage: "@stencil/core"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `stencil build`",
            value: "stencil build"
          },
          devCommand: {
            value: "stencil build --dev --watch --serve --port $PORT",
            placeholder: "stencil build --dev --watch --serve"
          },
          outputDirectory: {
            value: "www"
          }
        },
        dependency: "@stencil/core",
        getOutputDirName: async () => "www",
        defaultRoutes: [
          {
            src: "/assets/(.*)",
            headers: { "cache-control": "max-age=2592000" },
            continue: !0
          },
          {
            src: "/build/p-.*",
            headers: { "cache-control": "max-age=31536000, immutable" },
            continue: !0
          },
          {
            src: "/sw.js",
            headers: { "cache-control": "no-cache" },
            continue: !0
          },
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Nuxt.js",
        slug: "nuxtjs",
        demo: "https://nuxtjs-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/nuxt.svg",
        screenshot: "https://assets.vercel.com/image/upload/v1647366075/front/import/nuxtjs.png",
        tagline: "Nuxt.js is the web comprehensive framework that lets you dream big with Vue.js.",
        description: "A Nuxt.js app, bootstrapped with create-nuxt-app.",
        website: "https://nuxtjs.org",
        sort: 2,
        envPrefix: "NUXT_ENV_",
        detectors: {
          some: [
            {
              matchPackage: "nuxt"
            },
            {
              matchPackage: "nuxt3"
            },
            {
              matchPackage: "nuxt-edge"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `nuxt generate`",
            value: "nuxt generate"
          },
          devCommand: {
            value: "nuxt"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "nuxt",
        getOutputDirName: async () => "dist",
        cachePattern: ".nuxt/**",
        defaultRoutes: [
          {
            src: "/sw.js",
            headers: { "cache-control": "no-cache" },
            continue: !0
          },
          {
            src: "/_nuxt/(.*)",
            headers: { "cache-control": "public,max-age=31536000,immutable" },
            continue: !0
          },
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/200.html"
          }
        ]
      },
      {
        name: "RedwoodJS",
        slug: "redwoodjs",
        demo: "https://redwood-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/redwoodjs.svg",
        tagline: "RedwoodJS is a full-stack framework for the Jamstack.",
        description: "A RedwoodJS app, bootstraped with create-redwood-app.",
        website: "https://redwoodjs.com",
        envPrefix: "REDWOOD_ENV_",
        useRuntime: { src: "package.json", use: "@vercel/redwood" },
        ignoreRuntimes: ["@vercel/node"],
        detectors: {
          every: [
            {
              matchPackage: "@redwoodjs/core"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            value: "yarn rw deploy vercel"
          },
          devCommand: {
            value: 'yarn rw dev --fwd="--port=$PORT --open=false"',
            placeholder: "yarn rw dev"
          },
          outputDirectory: {
            placeholder: "RedwoodJS default"
          }
        },
        getOutputDirName: async () => "public"
      },
      {
        name: "Hugo",
        slug: "hugo",
        demo: "https://hugo-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/hugo.svg",
        tagline: "Hugo is the world\u2019s fastest framework for building websites, written in Go.",
        description: "A Hugo site, created with the Hugo CLI.",
        website: "https://gohugo.io",
        detectors: {
          some: [
            {
              path: "config.yaml",
              matchContent: "baseURL"
            },
            {
              path: "config.toml",
              matchContent: "baseURL"
            },
            {
              path: "config.json",
              matchContent: "baseURL"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "None"
          },
          buildCommand: {
            placeholder: "`npm run build` or `hugo --gc`",
            value: "hugo --gc"
          },
          devCommand: {
            value: "hugo server -D -w -p $PORT",
            placeholder: "hugo server -D"
          },
          outputDirectory: {
            placeholder: "`public` or `publishDir` from the `config` file"
          }
        },
        getOutputDirName: async (dirPrefix) => {
          const config2 = await (0, read_config_file_1.readConfigFile)(["config.json", "config.yaml", "config.toml"].map((fileName) => (0, path_1.join)(dirPrefix, fileName)));
          return config2 && config2.publishDir || "public";
        },
        defaultVersion: "0.58.2"
        // Must match the build image
      },
      {
        name: "Jekyll",
        slug: "jekyll",
        demo: "https://jekyll-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/jekyll.svg",
        tagline: "Jekyll makes it super easy to transform your plain text into static websites and blogs.",
        description: "A Jekyll site, created with the Jekyll CLI.",
        website: "https://jekyllrb.com/",
        detectors: {
          every: [
            {
              path: "_config.yml"
            }
          ]
        },
        settings: {
          installCommand: {
            value: "bundle install"
          },
          buildCommand: {
            placeholder: "`npm run build` or `jekyll build`",
            value: "jekyll build"
          },
          devCommand: {
            value: "bundle exec jekyll serve --watch --port $PORT",
            placeholder: "bundle exec jekyll serve"
          },
          outputDirectory: {
            placeholder: "`_site` or `destination` from `_config.yml`"
          }
        },
        getOutputDirName: async (dirPrefix) => {
          const config2 = await (0, read_config_file_1.readConfigFile)((0, path_1.join)(dirPrefix, "_config.yml"));
          return config2 && config2.destination || "_site";
        },
        cachePattern: "{vendor/bin,vendor/cache,vendor/bundle}/**"
      },
      {
        name: "Brunch",
        slug: "brunch",
        demo: "https://brunch-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/brunch.svg",
        tagline: "Brunch is a fast and simple webapp build tool with seamless incremental compilation for rapid development.",
        description: "A Brunch app, created with the Brunch CLI.",
        website: "https://brunch.io/",
        detectors: {
          some: [
            {
              matchPackage: "brunch"
            },
            {
              path: "brunch-config.js"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `brunch build --production`",
            value: "brunch build --production"
          },
          devCommand: {
            value: "brunch watch --server --port $PORT",
            placeholder: "brunch watch --server"
          },
          outputDirectory: {
            value: "public"
          }
        },
        getOutputDirName: async () => "public"
      },
      {
        name: "Middleman",
        slug: "middleman",
        demo: "https://middleman-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/middleman.svg",
        tagline: "Middleman is a static site generator that uses all the shortcuts and tools in modern web development.",
        description: "A Middleman app, created with the Middleman CLI.",
        website: "https://middlemanapp.com/",
        detectors: {
          every: [
            {
              path: "config.rb"
            }
          ]
        },
        settings: {
          installCommand: {
            value: "bundle install"
          },
          buildCommand: {
            placeholder: "`npm run build` or `bundle exec middleman build`",
            value: "bundle exec middleman build"
          },
          devCommand: {
            placeholder: "bundle exec middleman server",
            value: "bundle exec middleman server -p $PORT"
          },
          outputDirectory: {
            value: "build"
          }
        },
        getOutputDirName: async () => "build",
        cachePattern: "{vendor/bin,vendor/cache,vendor/bundle}/**"
      },
      {
        name: "Zola",
        slug: "zola",
        demo: "https://zola-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/zola.png",
        tagline: "Everything you need to make a static site engine in one binary.",
        description: 'A Zola app, created with the "Getting Started" tutorial.',
        website: "https://www.getzola.org",
        detectors: {
          every: [
            {
              path: "config.toml",
              matchContent: "base_url"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "None"
          },
          buildCommand: {
            value: "zola build"
          },
          devCommand: {
            placeholder: "zola serve",
            value: "zola serve --port $PORT"
          },
          outputDirectory: {
            value: "public"
          }
        },
        getOutputDirName: async () => "public",
        defaultVersion: "0.13.0"
        // Must match the build image
      },
      {
        name: "Hydrogen (v1)",
        slug: "hydrogen",
        demo: "https://hydrogen-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/hydrogen.svg",
        tagline: "React framework for headless commerce",
        description: "React framework for headless commerce",
        website: "https://hydrogen.shopify.dev",
        useRuntime: { src: "package.json", use: "@vercel/hydrogen" },
        envPrefix: "PUBLIC_",
        detectors: {
          some: [
            {
              matchPackage: "@shopify/hydrogen"
            },
            {
              path: "hydrogen.config.js"
            },
            {
              path: "hydrogen.config.ts"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            value: "shopify hydrogen build",
            placeholder: "`npm run build` or `shopify hydrogen build`"
          },
          devCommand: {
            value: "shopify hydrogen dev",
            placeholder: "shopify hydrogen dev"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "@shopify/hydrogen",
        getOutputDirName: async () => "dist"
      },
      {
        name: "Vite",
        slug: "vite",
        demo: "https://vite-vue-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/vite.svg",
        tagline: "Vite is a new breed of frontend build tool that significantly improves the frontend development experience.",
        description: "A Vue.js app, created with Vite.",
        website: "https://vitejs.dev",
        envPrefix: "VITE_",
        detectors: {
          every: [
            {
              matchPackage: "vite"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `vite build`",
            value: "vite build"
          },
          devCommand: {
            placeholder: "vite",
            value: "vite --port $PORT"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "vite",
        getOutputDirName: async () => "dist"
      },
      {
        name: "VitePress",
        slug: "vitepress",
        demo: "https://vitepress-starter-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/vite.svg",
        tagline: "VitePress is VuePress' little brother, built on top of Vite.",
        description: "VuePress on top of Vite",
        website: "https://vitepress.vuejs.org/",
        detectors: {
          every: [
            {
              matchPackage: "vitepress"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `vitepress build docs`",
            value: "vitepress build docs"
          },
          devCommand: {
            value: "vitepress dev docs --port $PORT"
          },
          outputDirectory: {
            value: "docs/.vitepress/dist"
          }
        },
        getOutputDirName: async () => "docs/.vitepress/dist"
      },
      {
        name: "VuePress",
        slug: "vuepress",
        demo: "https://vuepress-starter-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/vuepress.png",
        tagline: "Vue-powered Static Site Generator",
        description: "Vue-powered Static Site Generator",
        website: "https://vuepress.vuejs.org/",
        detectors: {
          every: [
            {
              matchPackage: "vuepress"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `vuepress build src`",
            value: "vuepress build src"
          },
          devCommand: {
            value: "vuepress dev src --port $PORT"
          },
          outputDirectory: {
            value: "src/.vuepress/dist"
          }
        },
        getOutputDirName: async () => "src/.vuepress/dist"
      },
      {
        name: "Parcel",
        slug: "parcel",
        demo: "https://parcel-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/parcel.png",
        tagline: "Parcel is a zero configuration build tool for the web that scales to projects of any size and complexity.",
        description: "A vanilla web app built with Parcel.",
        website: "https://parceljs.org",
        detectors: {
          every: [
            {
              matchPackage: "parcel"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `parcel build`",
            value: "parcel build"
          },
          devCommand: {
            placeholder: "parcel",
            value: "parcel"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "parcel",
        getOutputDirName: async () => "dist",
        defaultRoutes: [
          {
            src: "^/[^./]+\\.[0-9a-f]{8}\\.(css|js|png|jpg|webp|avif|svg)$",
            headers: { "cache-control": "s-maxage=31536000, immutable" },
            continue: !0
          },
          {
            handle: "filesystem"
          }
        ]
      },
      {
        name: "Sanity",
        slug: "sanity",
        demo: "https://sanity-studio-template.vercel.app",
        logo: "https://api-frameworks.vercel.sh/framework-logos/sanity.svg",
        tagline: "The structured content platform.",
        description: "A Sanity Studio",
        website: "https://www.sanity.io",
        envPrefix: "SANITY_STUDIO_",
        detectors: {
          some: [
            {
              path: "sanity.json"
            },
            {
              path: "sanity.config.js"
            },
            {
              path: "sanity.config.jsx"
            },
            {
              path: "sanity.config.ts"
            },
            {
              path: "sanity.config.tsx"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run build` or `sanity build`",
            value: "sanity build"
          },
          devCommand: {
            value: "sanity start --port $PORT"
          },
          outputDirectory: {
            value: "dist"
          }
        },
        dependency: "@sanity/cli",
        getOutputDirName: async () => "dist",
        defaultRoutes: [
          {
            handle: "filesystem"
          },
          {
            src: "/(.*)",
            dest: "/index.html"
          }
        ]
      },
      {
        name: "Storybook",
        slug: "storybook",
        logo: "https://api-frameworks.vercel.sh/framework-logos/storybook.svg",
        tagline: "Frontend workshop for UI development",
        description: "Storybook is a frontend workshop for building UI components and pages in isolation.",
        website: "https://storybook.js.org",
        ignoreRuntimes: ["@vercel/next", "@vercel/node"],
        disableRootMiddleware: !0,
        detectors: {
          every: [
            {
              matchPackage: "storybook"
            }
          ]
        },
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            value: "storybook build",
            ignorePackageJsonScript: !0
          },
          devCommand: {
            value: "storybook dev -p $PORT"
          },
          outputDirectory: {
            value: "storybook-static"
          }
        },
        getOutputDirName: async () => "storybook-static"
      },
      {
        name: "Other",
        slug: null,
        logo: "https://api-frameworks.vercel.sh/framework-logos/other.svg",
        description: "No framework or an unoptimized framework.",
        settings: {
          installCommand: {
            placeholder: "`yarn install`, `pnpm install`, or `npm install`"
          },
          buildCommand: {
            placeholder: "`npm run vercel-build` or `npm run build`",
            value: null
          },
          devCommand: {
            placeholder: "None",
            value: null
          },
          outputDirectory: {
            placeholder: "`public` if it exists, or `.`"
          }
        },
        getOutputDirName: async () => "public"
      }
    ];
    const def = exports2.frameworks;
    exports2.default = def;
  }(frameworks)), frameworks;
}
var frameworksExports = requireFrameworks(), dist$1 = {}, detectBuilders = {}, concatMap$1, hasRequiredConcatMap;
function requireConcatMap() {
  if (hasRequiredConcatMap) return concatMap$1;
  hasRequiredConcatMap = 1, concatMap$1 = function(xs, fn) {
    for (var res = [], i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      isArray2(x) ? res.push.apply(res, x) : res.push(x);
    }
    return res;
  };
  var isArray2 = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
  return concatMap$1;
}
var balancedMatch, hasRequiredBalancedMatch;
function requireBalancedMatch() {
  if (hasRequiredBalancedMatch) return balancedMatch;
  hasRequiredBalancedMatch = 1, balancedMatch = balanced;
  function balanced(a, b, str2) {
    a instanceof RegExp && (a = maybeMatch(a, str2)), b instanceof RegExp && (b = maybeMatch(b, str2));
    var r = range2(a, b, str2);
    return r && {
      start: r[0],
      end: r[1],
      pre: str2.slice(0, r[0]),
      body: str2.slice(r[0] + a.length, r[1]),
      post: str2.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str2) {
    var m = str2.match(reg);
    return m ? m[0] : null;
  }
  balanced.range = range2;
  function range2(a, b, str2) {
    var begs, beg, left, right, result, ai = str2.indexOf(a), bi = str2.indexOf(b, ai + 1), i = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b)
        return [ai, bi];
      for (begs = [], left = str2.length; i >= 0 && !result; )
        i == ai ? (begs.push(i), ai = str2.indexOf(a, i + 1)) : begs.length == 1 ? result = [begs.pop(), bi] : (beg = begs.pop(), beg < left && (left = beg, right = bi), bi = str2.indexOf(b, i + 1)), i = ai < bi && ai >= 0 ? ai : bi;
      begs.length && (result = [left, right]);
    }
    return result;
  }
  return balancedMatch;
}
var braceExpansion$1, hasRequiredBraceExpansion$1;
function requireBraceExpansion$1() {
  if (hasRequiredBraceExpansion$1) return braceExpansion$1;
  hasRequiredBraceExpansion$1 = 1;
  var concatMap2 = requireConcatMap(), balanced = requireBalancedMatch();
  braceExpansion$1 = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0", escOpen = "\0OPEN" + Math.random() + "\0", escClose = "\0CLOSE" + Math.random() + "\0", escComma = "\0COMMA" + Math.random() + "\0", escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str2) {
    return parseInt(str2, 10) == str2 ? parseInt(str2, 10) : str2.charCodeAt(0);
  }
  function escapeBraces(str2) {
    return str2.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str2) {
    return str2.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str2) {
    if (!str2)
      return [""];
    var parts = [], m = balanced("{", "}", str2);
    if (!m)
      return str2.split(",");
    var pre = m.pre, body = m.body, post = m.post, p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    return post.length && (p[p.length - 1] += postParts.shift(), p.push.apply(p, postParts)), parts.push.apply(parts, p), parts;
  }
  function expandTop(str2) {
    return str2 ? (str2.substr(0, 2) === "{}" && (str2 = "\\{\\}" + str2.substr(2)), expand2(escapeBraces(str2), !0).map(unescapeBraces)) : [];
  }
  function embrace(str2) {
    return "{" + str2 + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand2(str2, isTop) {
    var expansions = [], m = balanced("{", "}", str2);
    if (!m || /\$$/.test(m.pre)) return [str2];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body), isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body), isSequence = isNumericSequence || isAlphaSequence, isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions)
      return m.post.match(/,(?!,).*\}/) ? (str2 = m.pre + "{" + m.body + escClose + m.post, expand2(str2)) : [str2];
    var n;
    if (isSequence)
      n = m.body.split(/\.\./);
    else if (n = parseCommaParts(m.body), n.length === 1 && (n = expand2(n[0], !1).map(embrace), n.length === 1)) {
      var post = m.post.length ? expand2(m.post, !1) : [""];
      return post.map(function(p) {
        return m.pre + n[0] + p;
      });
    }
    var pre = m.pre, post = m.post.length ? expand2(m.post, !1) : [""], N;
    if (isSequence) {
      var x = numeric(n[0]), y = numeric(n[1]), width = Math.max(n[0].length, n[1].length), incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1, test = lte, reverse = y < x;
      reverse && (incr *= -1, test = gte);
      var pad = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c2;
        if (isAlphaSequence)
          c2 = String.fromCharCode(i), c2 === "\\" && (c2 = "");
        else if (c2 = String(i), pad) {
          var need = width - c2.length;
          if (need > 0) {
            var z = new Array(need + 1).join("0");
            i < 0 ? c2 = "-" + z + c2.slice(1) : c2 = z + c2;
          }
        }
        N.push(c2);
      }
    } else
      N = concatMap2(n, function(el) {
        return expand2(el, !1);
      });
    for (var j = 0; j < N.length; j++)
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        (!isTop || isSequence || expansion) && expansions.push(expansion);
      }
    return expansions;
  }
  return braceExpansion$1;
}
var minimatch_1$1, hasRequiredMinimatch$1;
function requireMinimatch$1() {
  if (hasRequiredMinimatch$1) return minimatch_1$1;
  hasRequiredMinimatch$1 = 1, minimatch_1$1 = minimatch2, minimatch2.Minimatch = Minimatch2;
  var path2 = function() {
    try {
      return require("path");
    } catch {
    }
  }() || {
    sep: "/"
  };
  minimatch2.sep = path2.sep;
  var GLOBSTAR2 = minimatch2.GLOBSTAR = Minimatch2.GLOBSTAR = {}, expand2 = requireBraceExpansion$1(), plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  }, qmark2 = "[^/]", star3 = qmark2 + "*?", twoStarDot2 = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", twoStarNoDot2 = "(?:(?!(?:\\/|^)\\.).)*?", reSpecials2 = charSet("().*{}+?[]^$\\!");
  function charSet(s) {
    return s.split("").reduce(function(set2, c2) {
      return set2[c2] = !0, set2;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch2.filter = filter2;
  function filter2(pattern, options2) {
    return options2 = options2 || {}, function(p, i, list2) {
      return minimatch2(p, pattern, options2);
    };
  }
  function ext2(a, b) {
    b = b || {};
    var t = {};
    return Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    }), Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    }), t;
  }
  minimatch2.defaults = function(def) {
    if (!def || typeof def != "object" || !Object.keys(def).length)
      return minimatch2;
    var orig = minimatch2, m = function(p, pattern, options2) {
      return orig(p, pattern, ext2(def, options2));
    };
    return m.Minimatch = function(pattern, options2) {
      return new orig.Minimatch(pattern, ext2(def, options2));
    }, m.Minimatch.defaults = function(options2) {
      return orig.defaults(ext2(def, options2)).Minimatch;
    }, m.filter = function(pattern, options2) {
      return orig.filter(pattern, ext2(def, options2));
    }, m.defaults = function(options2) {
      return orig.defaults(ext2(def, options2));
    }, m.makeRe = function(pattern, options2) {
      return orig.makeRe(pattern, ext2(def, options2));
    }, m.braceExpand = function(pattern, options2) {
      return orig.braceExpand(pattern, ext2(def, options2));
    }, m.match = function(list2, pattern, options2) {
      return orig.match(list2, pattern, ext2(def, options2));
    }, m;
  }, Minimatch2.defaults = function(def) {
    return minimatch2.defaults(def).Minimatch;
  };
  function minimatch2(p, pattern, options2) {
    return assertValidPattern2(pattern), options2 || (options2 = {}), !options2.nocomment && pattern.charAt(0) === "#" ? !1 : new Minimatch2(pattern, options2).match(p);
  }
  function Minimatch2(pattern, options2) {
    if (!(this instanceof Minimatch2))
      return new Minimatch2(pattern, options2);
    assertValidPattern2(pattern), options2 || (options2 = {}), pattern = pattern.trim(), !options2.allowWindowsEscape && path2.sep !== "/" && (pattern = pattern.split(path2.sep).join("/")), this.options = options2, this.set = [], this.pattern = pattern, this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.partial = !!options2.partial, this.make();
  }
  Minimatch2.prototype.debug = function() {
  }, Minimatch2.prototype.make = make;
  function make() {
    var pattern = this.pattern, options2 = this.options;
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      this.comment = !0;
      return;
    }
    if (!pattern) {
      this.empty = !0;
      return;
    }
    this.parseNegate();
    var set2 = this.globSet = this.braceExpand();
    options2.debug && (this.debug = function() {
      console.error.apply(console, arguments);
    }), this.debug(this.pattern, set2), set2 = this.globParts = set2.map(function(s) {
      return s.split(slashSplit);
    }), this.debug(this.pattern, set2), set2 = set2.map(function(s, si, set3) {
      return s.map(this.parse, this);
    }, this), this.debug(this.pattern, set2), set2 = set2.filter(function(s) {
      return s.indexOf(!1) === -1;
    }), this.debug(this.pattern, set2), this.set = set2;
  }
  Minimatch2.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern, negate = !1, options2 = this.options, negateOffset = 0;
    if (!options2.nonegate) {
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++)
        negate = !negate, negateOffset++;
      negateOffset && (this.pattern = pattern.substr(negateOffset)), this.negate = negate;
    }
  }
  minimatch2.braceExpand = function(pattern, options2) {
    return braceExpand2(pattern, options2);
  }, Minimatch2.prototype.braceExpand = braceExpand2;
  function braceExpand2(pattern, options2) {
    return options2 || (this instanceof Minimatch2 ? options2 = this.options : options2 = {}), pattern = typeof pattern > "u" ? this.pattern : pattern, assertValidPattern2(pattern), options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern) ? [pattern] : expand2(pattern);
  }
  var MAX_PATTERN_LENGTH2 = 1024 * 64, assertValidPattern2 = function(pattern) {
    if (typeof pattern != "string")
      throw new TypeError("invalid pattern");
    if (pattern.length > MAX_PATTERN_LENGTH2)
      throw new TypeError("pattern is too long");
  };
  Minimatch2.prototype.parse = parse3;
  var SUBPARSE = {};
  function parse3(pattern, isSub) {
    assertValidPattern2(pattern);
    var options2 = this.options;
    if (pattern === "**")
      if (options2.noglobstar)
        pattern = "*";
      else
        return GLOBSTAR2;
    if (pattern === "") return "";
    var re = "", hasMagic2 = !!options2.nocase, escaping = !1, patternListStack = [], negativeLists = [], stateChar, inClass = !1, reClassStart = -1, classStart = -1, patternStart = pattern.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star3, hasMagic2 = !0;
            break;
          case "?":
            re += qmark2, hasMagic2 = !0;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re), stateChar = !1;
      }
    }
    for (var i = 0, len = pattern.length, c2; i < len && (c2 = pattern.charAt(i)); i++) {
      if (this.debug("%s	%s %s %j", pattern, i, re, c2), escaping && reSpecials2[c2]) {
        re += "\\" + c2, escaping = !1;
        continue;
      }
      switch (c2) {
        /* istanbul ignore next */
        case "/":
          return !1;
        case "\\":
          clearStateChar(), escaping = !0;
          continue;
        // the various stateChar values
        // for the "extglob" stuff.
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          if (this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c2), inClass) {
            this.debug("  in class"), c2 === "!" && i === classStart + 1 && (c2 = "^"), re += c2;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar), clearStateChar(), stateChar = c2, options2.noext && clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          }), re += stateChar === "!" ? "(?:(?!(?:" : "(?:", this.debug("plType %j %j", stateChar, re), stateChar = !1;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar(), hasMagic2 = !0;
          var pl = patternListStack.pop();
          re += pl.close, pl.type === "!" && negativeLists.push(pl), pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|", escaping = !1;
            continue;
          }
          clearStateChar(), re += "|";
          continue;
        // these are mostly the same in regexp and glob
        case "[":
          if (clearStateChar(), inClass) {
            re += "\\" + c2;
            continue;
          }
          inClass = !0, classStart = i, reClassStart = re.length, re += c2;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c2, escaping = !1;
            continue;
          }
          var cs = pattern.substring(classStart + 1, i);
          try {
            RegExp("[" + cs + "]");
          } catch {
            var sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]", hasMagic2 = hasMagic2 || sp[1], inClass = !1;
            continue;
          }
          hasMagic2 = !0, inClass = !1, re += c2;
          continue;
        default:
          clearStateChar(), escaping ? escaping = !1 : reSpecials2[c2] && !(c2 === "^" && inClass) && (re += "\\"), re += c2;
      }
    }
    for (inClass && (cs = pattern.substr(classStart + 1), sp = this.parse(cs, SUBPARSE), re = re.substr(0, reClassStart) + "\\[" + sp[0], hasMagic2 = hasMagic2 || sp[1]), pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl), tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        return $2 || ($2 = "\\"), $1 + $1 + $2 + "|";
      }), this.debug(`tail=%j
   %s`, tail, tail, pl, re);
      var t = pl.type === "*" ? star3 : pl.type === "?" ? qmark2 : "\\" + pl.type;
      hasMagic2 = !0, re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar(), escaping && (re += "\\\\");
    var addPatternStart2 = !1;
    switch (re.charAt(0)) {
      case "[":
      case ".":
      case "(":
        addPatternStart2 = !0;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n], nlBefore = re.slice(0, nl.reStart), nlFirst = re.slice(nl.reStart, nl.reEnd - 8), nlLast = re.slice(nl.reEnd - 8, nl.reEnd), nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1, cleanAfter = nlAfter;
      for (i = 0; i < openParensBefore; i++)
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      nlAfter = cleanAfter;
      var dollar = "";
      nlAfter === "" && isSub !== SUBPARSE && (dollar = "$");
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic2 && (re = "(?=.)" + re), addPatternStart2 && (re = patternStart + re), isSub === SUBPARSE)
      return [re, hasMagic2];
    if (!hasMagic2)
      return globUnescape(pattern);
    var flags = options2.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch {
      return new RegExp("$.");
    }
    return regExp._glob = pattern, regExp._src = re, regExp;
  }
  minimatch2.makeRe = function(pattern, options2) {
    return new Minimatch2(pattern, options2 || {}).makeRe();
  }, Minimatch2.prototype.makeRe = makeRe2;
  function makeRe2() {
    if (this.regexp || this.regexp === !1) return this.regexp;
    var set2 = this.set;
    if (!set2.length)
      return this.regexp = !1, this.regexp;
    var options2 = this.options, twoStar = options2.noglobstar ? star3 : options2.dot ? twoStarDot2 : twoStarNoDot2, flags = options2.nocase ? "i" : "", re = set2.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR2 ? twoStar : typeof p == "string" ? regExpEscape2(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$", this.negate && (re = "^(?!" + re + ").*$");
    try {
      this.regexp = new RegExp(re, flags);
    } catch {
      this.regexp = !1;
    }
    return this.regexp;
  }
  minimatch2.match = function(list2, pattern, options2) {
    options2 = options2 || {};
    var mm = new Minimatch2(pattern, options2);
    return list2 = list2.filter(function(f) {
      return mm.match(f);
    }), mm.options.nonull && !list2.length && list2.push(pattern), list2;
  }, Minimatch2.prototype.match = function(f, partial) {
    if (typeof partial > "u" && (partial = this.partial), this.debug("match", f, this.pattern), this.comment) return !1;
    if (this.empty) return f === "";
    if (f === "/" && partial) return !0;
    var options2 = this.options;
    path2.sep !== "/" && (f = f.split(path2.sep).join("/")), f = f.split(slashSplit), this.debug(this.pattern, "split", f);
    var set2 = this.set;
    this.debug(this.pattern, "set", set2);
    var filename, i;
    for (i = f.length - 1; i >= 0 && (filename = f[i], !filename); i--)
      ;
    for (i = 0; i < set2.length; i++) {
      var pattern = set2[i], file = f;
      options2.matchBase && pattern.length === 1 && (file = [filename]);
      var hit = this.matchOne(file, pattern, partial);
      if (hit)
        return options2.flipNegate ? !0 : !this.negate;
    }
    return options2.flipNegate ? !1 : this.negate;
  }, Minimatch2.prototype.matchOne = function(file, pattern, partial) {
    var options2 = this.options;
    this.debug(
      "matchOne",
      { this: this, file, pattern }
    ), this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi], f = file[fi];
      if (this.debug(pattern, p, f), p === !1) return !1;
      if (p === GLOBSTAR2) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi, pr = pi + 1;
        if (pr === pl) {
          for (this.debug("** at the end"); fi < fl; fi++)
            if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".") return !1;
          return !0;
        }
        for (; fr < fl; ) {
          var swallowee = file[fr];
          if (this.debug(`
globstar while`, file, fr, pattern, pr, swallowee), this.matchOne(file.slice(fr), pattern.slice(pr), partial))
            return this.debug("globstar found match!", fr, fl, swallowee), !0;
          if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
            this.debug("dot detected!", file, fr, pattern, pr);
            break;
          }
          this.debug("globstar swallow a segment, and continue"), fr++;
        }
        return !!(partial && (this.debug(`
>>> no match, partial?`, file, fr, pattern, pr), fr === fl));
      }
      var hit;
      if (typeof p == "string" ? (hit = f === p, this.debug("string match", p, f, hit)) : (hit = f.match(p), this.debug("pattern match", p, f, hit)), !hit) return !1;
    }
    if (fi === fl && pi === pl)
      return !0;
    if (fi === fl)
      return partial;
    if (pi === pl)
      return fi === fl - 1 && file[fi] === "";
    throw new Error("wtf?");
  };
  function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
  }
  function regExpEscape2(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  return minimatch_1$1;
}
var isOfficialRuntime = {}, hasRequiredIsOfficialRuntime;
function requireIsOfficialRuntime() {
  return hasRequiredIsOfficialRuntime || (hasRequiredIsOfficialRuntime = 1, function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.isStaticRuntime = exports2.isOfficialRuntime = void 0;
    const isOfficialRuntime2 = (desired, name) => typeof name != "string" ? !1 : name === `@vercel/${desired}` || name === `@now/${desired}` || name.startsWith(`@vercel/${desired}@`) || name.startsWith(`@now/${desired}@`);
    exports2.isOfficialRuntime = isOfficialRuntime2;
    const isStaticRuntime = (name) => (0, exports2.isOfficialRuntime)("static", name);
    exports2.isStaticRuntime = isStaticRuntime;
  }(isOfficialRuntime)), isOfficialRuntime;
}
var hasRequiredDetectBuilders;
function requireDetectBuilders() {
  if (hasRequiredDetectBuilders) return detectBuilders;
  hasRequiredDetectBuilders = 1;
  var __importDefault2 = detectBuilders && detectBuilders.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(detectBuilders, "__esModule", { value: !0 }), detectBuilders.detectBuilders = detectBuilders.detectOutputDirectory = detectBuilders.detectApiDirectory = detectBuilders.detectApiExtensions = detectBuilders.sortFiles = void 0;
  const minimatch_12 = __importDefault2(requireMinimatch$1()), semver_1 = semver__default.default, path_1 = require$$0__default$1.default, frameworks_1 = __importDefault2(requireFrameworks()), is_official_runtime_1 = requireIsOfficialRuntime(), slugToFramework = new Map(frameworks_1.default.map((f) => [f.slug, f]));
  function sortFiles(fileA, fileB) {
    return fileA.localeCompare(fileB);
  }
  detectBuilders.sortFiles = sortFiles;
  function detectApiExtensions(builders) {
    return new Set(builders.filter((b) => !!(b.config && b.config.zeroConfig && b.src?.startsWith("api/"))).map((b) => (0, path_1.extname)(b.src)).filter(Boolean));
  }
  detectBuilders.detectApiExtensions = detectApiExtensions;
  function detectApiDirectory(builders) {
    return builders.some((b) => b.config && b.config.zeroConfig && b.src?.startsWith("api/")) ? "api" : null;
  }
  detectBuilders.detectApiDirectory = detectApiDirectory;
  function getPublicBuilder(builders) {
    for (const builder of builders)
      if (typeof builder.src == "string" && (0, is_official_runtime_1.isOfficialRuntime)("static", builder.use) && /^.*\/\*\*\/\*$/.test(builder.src) && builder.config?.zeroConfig === !0)
        return builder;
    return null;
  }
  function detectOutputDirectory(builders) {
    const publicBuilder = getPublicBuilder(builders);
    return publicBuilder ? publicBuilder.src.replace("/**/*", "") : null;
  }
  detectBuilders.detectOutputDirectory = detectOutputDirectory;
  async function detectBuilders$1(files, pkg, options2 = {}) {
    const errors = [], warnings = [];
    let apiBuilders = [], frontendBuilder = null;
    const functionError = validateFunctions(options2);
    if (functionError)
      return {
        builders: null,
        errors: [functionError],
        warnings,
        defaultRoutes: null,
        redirectRoutes: null,
        rewriteRoutes: null,
        errorRoutes: null
      };
    const sortedFiles = files.sort(sortFiles), apiSortedFiles = files.sort(sortFilesBySegmentCount), usedFunctions = /* @__PURE__ */ new Set(), addToUsedFunctions = (builder) => {
      const key2 = Object.keys(builder.config.functions || {})[0];
      key2 && usedFunctions.add(key2);
    }, absolutePathCache = /* @__PURE__ */ new Map(), { projectSettings = {} } = options2, { buildCommand, outputDirectory, framework } = projectSettings, frameworkConfig = slugToFramework.get(framework || ""), ignoreRuntimes = new Set(frameworkConfig?.ignoreRuntimes), withTag = options2.tag ? `@${options2.tag}` : "", apiMatches = getApiMatches().filter((b) => (
      // Root-level middleware is enabled, unless `disableRootMiddleware: true`
      b.config?.middleware && !frameworkConfig?.disableRootMiddleware || // "api" dir runtimes are enabled, unless opted-out via `ignoreRuntimes`
      !ignoreRuntimes.has(b.use)
    )).map((b) => (b.use = `${b.use}${withTag}`, b)), makeFrontendStatic = buildCommand === "" || outputDirectory === "", usedOutputDirectory = outputDirectory || "public";
    let hasUsedOutputDirectory = !1, hasNoneApiFiles = !1, hasNextApiFiles = !1, fallbackEntrypoint = null;
    const apiRoutes = [], dynamicRoutes = [];
    for (const fileName of sortedFiles) {
      const apiBuilder = maybeGetApiBuilder(fileName, apiMatches, options2);
      if (apiBuilder) {
        const { routeError, apiRoute, isDynamic } = getApiRoute(fileName, apiSortedFiles, options2, absolutePathCache);
        if (routeError)
          return {
            builders: null,
            errors: [routeError],
            warnings,
            defaultRoutes: null,
            redirectRoutes: null,
            rewriteRoutes: null,
            errorRoutes: null
          };
        apiRoute && (apiRoutes.push(apiRoute), isDynamic && dynamicRoutes.push(apiRoute)), addToUsedFunctions(apiBuilder), apiBuilders.push(apiBuilder);
        continue;
      }
      !hasUsedOutputDirectory && fileName.startsWith(`${usedOutputDirectory}/`) && (hasUsedOutputDirectory = !0), !hasNoneApiFiles && !fileName.startsWith("api/") && fileName !== "package.json" && (hasNoneApiFiles = !0), !hasNextApiFiles && (fileName.startsWith("pages/api") || fileName.startsWith("src/pages/api")) && (hasNextApiFiles = !0), !fallbackEntrypoint && buildCommand && !fileName.includes("/") && fileName !== "now.json" && fileName !== "vercel.json" && (fallbackEntrypoint = fileName);
    }
    if (!makeFrontendStatic && (hasBuildScript(pkg) || buildCommand || framework))
      frontendBuilder = detectFrontBuilder(pkg, files, usedFunctions, fallbackEntrypoint, options2);
    else {
      if (pkg && !makeFrontendStatic && !apiBuilders.length && !options2.ignoreBuildScript)
        return errors.push(getMissingBuildScriptError()), {
          errors,
          warnings,
          builders: null,
          redirectRoutes: null,
          defaultRoutes: null,
          rewriteRoutes: null,
          errorRoutes: null
        };
      hasUsedOutputDirectory && outputDirectory !== "" ? frontendBuilder = {
        use: "@vercel/static",
        src: `${usedOutputDirectory}/**/*`,
        config: {
          zeroConfig: !0,
          outputDirectory: usedOutputDirectory
        }
      } : apiBuilders.length && hasNoneApiFiles && (frontendBuilder = {
        use: "@vercel/static",
        src: "!{api/**,package.json,middleware.[jt]s}",
        config: {
          zeroConfig: !0
        }
      });
    }
    const unusedFunctionError = checkUnusedFunctions(frontendBuilder, usedFunctions, options2);
    if (unusedFunctionError)
      return {
        builders: null,
        errors: [unusedFunctionError],
        warnings,
        redirectRoutes: null,
        defaultRoutes: null,
        rewriteRoutes: null,
        errorRoutes: null
      };
    framework === null && frontendBuilder?.use === "@vercel/next" && apiBuilders.length > 0 && (apiBuilders = apiBuilders.filter((builder) => !(builder.use === "@vercel/node" && builder.config?.middleware)));
    const builders = [];
    apiBuilders.length && builders.push(...apiBuilders), frontendBuilder && (builders.push(frontendBuilder), hasNextApiFiles && apiBuilders.some((b) => (0, is_official_runtime_1.isOfficialRuntime)("node", b.use)) && warnings.push({
      code: "conflicting_files",
      message: "When using Next.js, it is recommended to place JavaScript Functions inside of the `pages/api` (provided by Next.js) directory instead of `api` (provided by Vercel). Other languages (Python, Go, etc) should still go in the `api` directory.",
      link: "https://nextjs.org/docs/api-routes/introduction",
      action: "Learn More"
    }));
    const routesResult = getRouteResult(apiRoutes, dynamicRoutes, usedOutputDirectory, apiBuilders, frontendBuilder, options2);
    return {
      warnings,
      builders: builders.length ? builders : null,
      errors: errors.length ? errors : null,
      redirectRoutes: routesResult.redirectRoutes,
      defaultRoutes: routesResult.defaultRoutes,
      rewriteRoutes: routesResult.rewriteRoutes,
      errorRoutes: routesResult.errorRoutes
    };
  }
  detectBuilders.detectBuilders = detectBuilders$1;
  function maybeGetApiBuilder(fileName, apiMatches, options2) {
    const middleware = fileName === "middleware.js" || fileName === "middleware.ts";
    if (middleware && options2.projectSettings?.framework === "nextjs" || !(fileName.startsWith("api/") || middleware) || fileName.includes("/.") || fileName.includes("/_") || fileName.includes("/node_modules/") || fileName.endsWith(".d.ts"))
      return null;
    const match2 = apiMatches.find(({ src: src2 = "**" }) => src2 === fileName || (0, minimatch_12.default)(fileName, src2)), { fnPattern, func } = getFunction(fileName, options2), use = func?.runtime || match2?.use;
    if (!use)
      return null;
    const config2 = { zeroConfig: !0 };
    return middleware && (config2.middleware = !0), fnPattern && func && (config2.functions = { [fnPattern]: func }, func.includeFiles && (config2.includeFiles = func.includeFiles), func.excludeFiles && (config2.excludeFiles = func.excludeFiles)), {
      use,
      src: fileName,
      config: config2
    };
  }
  function getFunction(fileName, { functions = {} }) {
    const keys = Object.keys(functions);
    if (!keys.length)
      return { fnPattern: null, func: null };
    const func = keys.find((key2) => key2 === fileName || (0, minimatch_12.default)(fileName, key2));
    return func ? { fnPattern: func, func: functions[func] } : { fnPattern: null, func: null };
  }
  function getApiMatches() {
    const config2 = { zeroConfig: !0 };
    return [
      {
        src: "middleware.[jt]s",
        use: "@vercel/node",
        config: { ...config2, middleware: !0 }
      },
      { src: "api/**/*.+(js|mjs|ts|tsx)", use: "@vercel/node", config: config2 },
      { src: "api/**/!(*_test).go", use: "@vercel/go", config: config2 },
      { src: "api/**/*.py", use: "@vercel/python", config: config2 },
      { src: "api/**/*.rb", use: "@vercel/ruby", config: config2 }
    ];
  }
  function hasBuildScript(pkg) {
    const { scripts = {} } = pkg || {};
    return !!(scripts && scripts.build);
  }
  function detectFrontBuilder(pkg, files, usedFunctions, fallbackEntrypoint, options2) {
    const { tag, projectSettings = {} } = options2, withTag = tag ? `@${tag}` : "", { createdAt = 0 } = projectSettings;
    let { framework } = projectSettings;
    const config2 = {
      zeroConfig: !0
    };
    framework && (config2.framework = framework), projectSettings.devCommand && (config2.devCommand = projectSettings.devCommand), typeof projectSettings.installCommand == "string" && (config2.installCommand = projectSettings.installCommand), projectSettings.buildCommand && (config2.buildCommand = projectSettings.buildCommand), projectSettings.outputDirectory && (config2.outputDirectory = projectSettings.outputDirectory), pkg && (framework === void 0 || framework !== "storybook" && createdAt < Date.parse("2020-03-01")) && {
      ...pkg.dependencies,
      ...pkg.devDependencies
    }.next && (framework = "nextjs"), options2.functions && Object.entries(options2.functions).forEach(([key2, func]) => {
      usedFunctions.has(key2) || (config2.functions || (config2.functions = {}), config2.functions[key2] = { ...func });
    });
    const f = slugToFramework.get(framework || "");
    if (f && f.useRuntime) {
      const { src: src2, use } = f.useRuntime;
      return { src: src2, use: `${use}${withTag}`, config: config2 };
    }
    const entrypoints = /* @__PURE__ */ new Set([
      "package.json",
      "config.yaml",
      "config.toml",
      "config.json",
      "_config.yml",
      "config.yml",
      "config.rb"
    ]);
    return {
      src: (pkg ? "package.json" : files.find((file) => entrypoints.has(file)) || fallbackEntrypoint || "package.json") || "package.json",
      use: `@vercel/static-build${withTag}`,
      config: config2
    };
  }
  function getMissingBuildScriptError() {
    return {
      code: "missing_build_script",
      message: "Your `package.json` file is missing a `build` property inside the `scripts` property.\nLearn More: https://vercel.link/missing-build-script"
    };
  }
  function validateFunctions({ functions = {} }) {
    for (const [path2, func] of Object.entries(functions)) {
      if (path2.length > 256)
        return {
          code: "invalid_function_glob",
          message: "Function globs must be less than 256 characters long."
        };
      if (!func || typeof func != "object")
        return {
          code: "invalid_function",
          message: "Function must be an object."
        };
      if (Object.keys(func).length === 0)
        return {
          code: "invalid_function",
          message: "Function must contain at least one property."
        };
      if (func.maxDuration !== void 0 && (func.maxDuration < 1 || func.maxDuration > 900 || !Number.isInteger(func.maxDuration)))
        return {
          code: "invalid_function_duration",
          message: "Functions must have a duration between 1 and 900."
        };
      if (func.memory !== void 0 && (func.memory < 128 || func.memory > 3008))
        return {
          code: "invalid_function_memory",
          message: "Functions must have a memory value between 128 and 3008"
        };
      if (path2.startsWith("/"))
        return {
          code: "invalid_function_source",
          message: `The function path "${path2}" is invalid. The path must be relative to your project root and therefore cannot start with a slash.`
        };
      if (func.runtime !== void 0) {
        const tag = `${func.runtime}`.split("@").pop();
        if (!tag || !(0, semver_1.valid)(tag))
          return {
            code: "invalid_function_runtime",
            message: "Function Runtimes must have a valid version, for example `now-php@1.0.0`."
          };
      }
      if (func.includeFiles !== void 0 && typeof func.includeFiles != "string")
        return {
          code: "invalid_function_property",
          message: "The property `includeFiles` must be a string."
        };
      if (func.excludeFiles !== void 0 && typeof func.excludeFiles != "string")
        return {
          code: "invalid_function_property",
          message: "The property `excludeFiles` must be a string."
        };
    }
    return null;
  }
  function checkUnusedFunctions(frontendBuilder, usedFunctions, options2) {
    const unusedFunctions = new Set(Object.keys(options2.functions || {}).filter((key2) => !usedFunctions.has(key2)));
    if (!unusedFunctions.size)
      return null;
    if (frontendBuilder && (0, is_official_runtime_1.isOfficialRuntime)("next", frontendBuilder.use))
      for (const fnKey of unusedFunctions.values())
        if (fnKey.startsWith("pages/") || fnKey.startsWith("src/pages") || fnKey.startsWith("app/") || fnKey.startsWith("src/app/"))
          unusedFunctions.delete(fnKey);
        else
          return {
            code: "unused_function",
            message: `The pattern "${fnKey}" defined in \`functions\` doesn't match any Serverless Functions.`,
            action: "Learn More",
            link: "https://vercel.link/unmatched-function-pattern"
          };
    if (unusedFunctions.size) {
      const [fnKey] = Array.from(unusedFunctions);
      return {
        code: "unused_function",
        message: `The pattern "${fnKey}" defined in \`functions\` doesn't match any Serverless Functions inside the \`api\` directory.`,
        action: "Learn More",
        link: "https://vercel.link/unmatched-function-pattern"
      };
    }
    return null;
  }
  function getApiRoute(fileName, sortedFiles, options2, absolutePathCache) {
    const conflictingSegment = getConflictingSegment(fileName);
    if (conflictingSegment)
      return {
        apiRoute: null,
        isDynamic: !1,
        routeError: {
          code: "conflicting_path_segment",
          message: `The segment "${conflictingSegment}" occurs more than one time in your path "${fileName}". Please make sure that every segment in a path is unique.`
        }
      };
    const occurrences = pathOccurrences(fileName, sortedFiles, absolutePathCache);
    if (occurrences.length > 0) {
      const messagePaths = concatArrayOfText(occurrences.map((name) => `"${name}"`));
      return {
        apiRoute: null,
        isDynamic: !1,
        routeError: {
          code: "conflicting_file_path",
          message: `Two or more files have conflicting paths or names. Please make sure path segments and filenames, without their extension, are unique. The path "${fileName}" has conflicts with ${messagePaths}.`
        }
      };
    }
    const out = createRouteFromPath(fileName, !!options2.featHandleMiss, !!options2.cleanUrls);
    return {
      apiRoute: out.route,
      isDynamic: out.isDynamic,
      routeError: null
    };
  }
  function getConflictingSegment(filePath) {
    const segments = /* @__PURE__ */ new Set();
    for (const segment of filePath.split("/")) {
      const name = getSegmentName(segment);
      if (name !== null && segments.has(name))
        return name;
      name && segments.add(name);
    }
    return null;
  }
  function getSegmentName(segment) {
    const { name } = (0, path_1.parse)(segment);
    return name.startsWith("[") && name.endsWith("]") ? name.slice(1, -1) : null;
  }
  function getAbsolutePath(unresolvedPath) {
    const { dir, name } = (0, path_1.parse)(unresolvedPath);
    return joinPath(dir, name).split("/").map((part) => part.replace(/\[.*\]/, "1")).join("/");
  }
  function pathOccurrences(fileName, files, absolutePathCache) {
    let currentAbsolutePath = absolutePathCache.get(fileName);
    currentAbsolutePath || (currentAbsolutePath = getAbsolutePath(fileName), absolutePathCache.set(fileName, currentAbsolutePath));
    const prev = [];
    for (const file of files) {
      if (file === fileName)
        continue;
      let absolutePath = absolutePathCache.get(file);
      absolutePath || (absolutePath = getAbsolutePath(file), absolutePathCache.set(file, absolutePath)), (absolutePath === currentAbsolutePath || partiallyMatches(fileName, file)) && prev.push(file);
    }
    return prev;
  }
  function joinPath(...segments) {
    return segments.join("/").replace(/\/{2,}/g, "/");
  }
  function escapeName(name) {
    const special = "[]^$.|?*+()".split("");
    for (const char of special)
      name = name.replace(new RegExp(`\\${char}`, "g"), `\\${char}`);
    return name;
  }
  function concatArrayOfText(texts) {
    if (texts.length <= 2)
      return texts.join(" and ");
    const last2 = texts.pop();
    return `${texts.join(", ")}, and ${last2}`;
  }
  function partiallyMatches(pathA, pathB) {
    const partsA = pathA.split("/"), partsB = pathB.split("/"), long = partsA.length > partsB.length ? partsA : partsB, short = long === partsA ? partsB : partsA;
    let index = 0;
    for (const segmentShort of short) {
      const segmentLong = long[index], nameLong = getSegmentName(segmentLong), nameShort = getSegmentName(segmentShort);
      if (segmentShort !== segmentLong && (!nameLong || !nameShort))
        return !1;
      if (nameLong !== nameShort)
        return !0;
      index += 1;
    }
    return !1;
  }
  function createRouteFromPath(filePath, featHandleMiss, cleanUrls) {
    const parts = filePath.split("/");
    let counter = 1;
    const query = [];
    let isDynamic = !1;
    const srcParts = parts.map((segment, i) => {
      const name = getSegmentName(segment), isLast = i === parts.length - 1;
      if (name !== null)
        return query.push(`${name}=$${counter++}`), isDynamic = !0, "([^/]+)";
      if (isLast) {
        const { name: fileName2, ext: ext3 } = (0, path_1.parse)(segment), isIndex2 = fileName2 === "index", prefix = isIndex2 ? "/" : "";
        return `(${[
          isIndex2 ? prefix : `${fileName2}/`,
          prefix + escapeName(fileName2),
          featHandleMiss && cleanUrls ? "" : prefix + escapeName(fileName2) + escapeName(ext3)
        ].filter(Boolean).join("|")})${isIndex2 ? "?" : ""}`;
      }
      return segment;
    }), { name: fileName, ext: ext2 } = (0, path_1.parse)(filePath), isIndex = fileName === "index", queryString = `${query.length ? "?" : ""}${query.join("&")}`, src2 = isIndex ? `^/${srcParts.slice(0, -1).join("/")}${srcParts.slice(-1)[0]}$` : `^/${srcParts.join("/")}$`;
    let route;
    if (featHandleMiss) {
      const extensionless = ext2 ? filePath.slice(0, -ext2.length) : filePath;
      route = {
        src: src2,
        dest: `/${extensionless}${queryString}`,
        check: !0
      };
    } else
      route = {
        src: src2,
        dest: `/${filePath}${queryString}`
      };
    return { route, isDynamic };
  }
  function getRouteResult(apiRoutes, dynamicRoutes, outputDirectory, apiBuilders, frontendBuilder, options2) {
    const defaultRoutes = [], redirectRoutes = [], rewriteRoutes = [], errorRoutes = [], framework = frontendBuilder?.config?.framework || "", isNextjs = framework === "nextjs" || (0, is_official_runtime_1.isOfficialRuntime)("next", frontendBuilder?.use), ignoreRuntimes = slugToFramework.get(framework)?.ignoreRuntimes;
    if (apiRoutes && apiRoutes.length > 0)
      if (options2.featHandleMiss) {
        const extSet = detectApiExtensions(apiBuilders);
        if (extSet.size > 0) {
          const extGroup = `(?:\\.(?:${Array.from(extSet).map((ext2) => ext2.slice(1)).join("|")}))`;
          options2.cleanUrls ? (redirectRoutes.push({
            src: `^/(api(?:.+)?)/index${extGroup}?/?$`,
            headers: { Location: options2.trailingSlash ? "/$1/" : "/$1" },
            status: 308
          }), redirectRoutes.push({
            src: `^/api/(.+)${extGroup}/?$`,
            headers: {
              Location: options2.trailingSlash ? "/api/$1/" : "/api/$1"
            },
            status: 308
          })) : (defaultRoutes.push({ handle: "miss" }), defaultRoutes.push({
            src: `^/api/(.+)${extGroup}$`,
            dest: "/api/$1",
            check: !0
          }));
        }
        rewriteRoutes.push(...dynamicRoutes);
        const hasApiBuild = apiBuilders.find((builder) => builder.src?.startsWith("api/"));
        typeof ignoreRuntimes > "u" && hasApiBuild && rewriteRoutes.push({
          src: "^/api(/.*)?$",
          status: 404
        });
      } else
        defaultRoutes.push(...apiRoutes), apiRoutes.length && defaultRoutes.push({
          status: 404,
          src: "^/api(/.*)?$"
        });
    return frontendBuilder && !options2.featHandleMiss && (0, is_official_runtime_1.isOfficialRuntime)("static", frontendBuilder.use) && defaultRoutes.push({
      src: "/(.*)",
      dest: `/${outputDirectory}/$1`
    }), options2.featHandleMiss && !isNextjs && errorRoutes.push({
      status: 404,
      src: "^(?!/api).*$",
      dest: options2.cleanUrls ? "/404" : "/404.html"
    }), {
      defaultRoutes,
      redirectRoutes,
      rewriteRoutes,
      errorRoutes
    };
  }
  function sortFilesBySegmentCount(fileA, fileB) {
    const lengthA = fileA.split("/").length, lengthB = fileB.split("/").length;
    if (lengthA > lengthB)
      return -1;
    if (lengthA < lengthB)
      return 1;
    const countSegments = (prev, segment) => getSegmentName(segment) ? prev + 1 : 0, segmentLengthA = fileA.split("/").reduce(countSegments, 0), segmentLengthB = fileB.split("/").reduce(countSegments, 0);
    return segmentLengthA > segmentLengthB ? 1 : segmentLengthA < segmentLengthB ? -1 : fileA.localeCompare(fileB);
  }
  return detectBuilders;
}
var detectFileSystemApi = {}, hasRequiredDetectFileSystemApi;
function requireDetectFileSystemApi() {
  if (hasRequiredDetectFileSystemApi) return detectFileSystemApi;
  hasRequiredDetectFileSystemApi = 1;
  var __importDefault2 = detectFileSystemApi && detectFileSystemApi.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(detectFileSystemApi, "__esModule", { value: !0 }), detectFileSystemApi.detectFileSystemAPI = void 0;
  const semver_1 = __importDefault2(semver__default.default), _1 = requireDist();
  async function detectFileSystemAPI({ files, projectSettings, builders, vercelConfig, pkg, tag, enableFlag = !1 }) {
    const framework = projectSettings.framework || "", deps = Object.assign({}, pkg?.dependencies, pkg?.devDependencies), plugins = Object.keys(deps).filter((dep) => dep.startsWith("vercel-plugin-")), hasDotOutput = Object.keys(files).some((file) => file.startsWith(".output/")), hasMiddleware = !!(files["_middleware.js"] || files["_middleware.ts"]), metadata = {
      plugins,
      hasDotOutput,
      hasMiddleware
    };
    if (!(enableFlag || hasMiddleware || hasDotOutput))
      return { metadata, fsApiBuilder: null, reason: "Flag not enabled." };
    if (vercelConfig?.builds && vercelConfig.builds.length > 0)
      return {
        metadata,
        fsApiBuilder: null,
        reason: "Detected `builds` in vercel.json. Please remove it in favor of CLI plugins."
      };
    if (Object.values(vercelConfig?.functions || {}).some((fn) => !!fn.runtime))
      return {
        metadata,
        fsApiBuilder: null,
        reason: "Detected `functions.runtime` in vercel.json. Please remove it in favor of CLI plugins."
      };
    if (process.env.HUGO_VERSION)
      return {
        metadata,
        fsApiBuilder: null,
        reason: "Detected `HUGO_VERSION` environment variable. Please remove it."
      };
    if (process.env.ZOLA_VERSION)
      return {
        metadata,
        fsApiBuilder: null,
        reason: "Detected `ZOLA_VERSION` environment variable. Please remove it."
      };
    if (process.env.GUTENBERG_VERSION)
      return {
        metadata,
        fsApiBuilder: null,
        reason: "Detected `GUTENBERG_VERSION` environment variable. Please remove it."
      };
    const invalidBuilder = builders.find(({ use }) => !((0, _1.isOfficialRuntime)("go", use) || (0, _1.isOfficialRuntime)("python", use) || (0, _1.isOfficialRuntime)("ruby", use) || (0, _1.isOfficialRuntime)("node", use) || (0, _1.isOfficialRuntime)("next", use) || (0, _1.isOfficialRuntime)("static", use) || (0, _1.isOfficialRuntime)("static-build", use)));
    if (invalidBuilder)
      return {
        metadata,
        fsApiBuilder: null,
        reason: `Detected \`${invalidBuilder.use}\` in vercel.json. Please remove it in favor of CLI plugins.`
      };
    for (const lang of ["go", "python", "ruby"])
      for (const { use } of builders) {
        const plugin = "vercel-plugin-" + lang;
        if ((0, _1.isOfficialRuntime)(lang, use) && !deps[plugin])
          return {
            metadata,
            fsApiBuilder: null,
            reason: `Detected \`${lang}\` Serverless Function usage without plugin \`${plugin}\`. Please run \`npm i ${plugin}\`.`
          };
      }
    if (framework === "nuxtjs" || framework === "sveltekit" || framework === "redwoodjs")
      return {
        metadata,
        fsApiBuilder: null,
        reason: `Detected framework \`${framework}\` that only supports legacy File System API. Please contact the framework author.`
      };
    if (framework === "nextjs" && !hasDotOutput) {
      if (projectSettings?.outputDirectory)
        return {
          metadata,
          fsApiBuilder: null,
          reason: `Detected Next.js with Output Directory \`${projectSettings.outputDirectory}\` override. Please change it back to the default.`
        };
      const nextVersion = deps.next;
      if (!nextVersion)
        return {
          metadata,
          fsApiBuilder: null,
          reason: "Detected Next.js in Project Settings but missing `next` package.json dependencies. Please run `npm i next`."
        };
      if (nextVersion !== "latest" && nextVersion !== "canary") {
        const fixedVersion = semver_1.default.valid(semver_1.default.coerce(nextVersion) || "");
        if (!fixedVersion || !semver_1.default.gte(fixedVersion, "12.0.0"))
          return {
            metadata,
            fsApiBuilder: null,
            reason: `Detected legacy Next.js version "${nextVersion}" in package.json. Please run \`npm i next@latest\` to upgrade.`
          };
      }
    }
    if (!hasDotOutput) {
      const vercelCliVersion = deps.vercel;
      if (vercelCliVersion && vercelCliVersion !== "latest" && vercelCliVersion !== "canary") {
        const fixedVersion = semver_1.default.valid(semver_1.default.coerce(vercelCliVersion) || "");
        if (!fixedVersion || !semver_1.default.gte(fixedVersion, "23.1.3-canary.68"))
          return {
            metadata,
            fsApiBuilder: null,
            reason: `Detected legacy Vercel CLI version "${vercelCliVersion}" in package.json. Please run \`npm i vercel@latest\` to upgrade.`
          };
      }
    }
    const config2 = builders.find(({ use }) => (0, _1.isOfficialRuntime)("next", use) || (0, _1.isOfficialRuntime)("static", use) || (0, _1.isOfficialRuntime)("static-build", use))?.config || {}, fsApiBuilder = {
      use: `@vercelruntimes/file-system-api${tag ? `@${tag}` : ""}`,
      src: "**",
      config: {
        ...config2,
        fileSystemAPI: !0,
        framework: config2.framework || framework || null,
        projectSettings,
        hasMiddleware,
        hasDotOutput
      }
    };
    return { metadata, fsApiBuilder, reason: null };
  }
  return detectFileSystemApi.detectFileSystemAPI = detectFileSystemAPI, detectFileSystemApi;
}
var detectFramework = {}, hasRequiredDetectFramework;
function requireDetectFramework() {
  if (hasRequiredDetectFramework) return detectFramework;
  hasRequiredDetectFramework = 1, Object.defineProperty(detectFramework, "__esModule", { value: !0 }), detectFramework.detectFrameworkVersion = detectFramework.detectFrameworkRecord = detectFramework.detectFrameworks = detectFramework.detectFramework = void 0;
  const child_process_1 = require$$1__default$2.default;
  async function matches(fs2, framework) {
    const { detectors } = framework;
    if (!detectors)
      return;
    const { every: every2, some } = detectors;
    if (every2 !== void 0 && !Array.isArray(every2) || some !== void 0 && !Array.isArray(some))
      return;
    const check = async ({ path: path2, matchContent, matchPackage }) => {
      if (matchPackage && matchContent)
        throw new Error(`Cannot specify "matchPackage" and "matchContent" in the same detector for "${framework.slug}"`);
      if (matchPackage && path2)
        throw new Error(`Cannot specify "matchPackage" and "path" in the same detector for "${framework.slug}" because "path" is assumed to be "package.json".`);
      if (!path2 && !matchPackage)
        throw new Error(`Must specify either "path" or "matchPackage" in detector for "${framework.slug}".`);
      if (path2 || (path2 = "package.json"), matchPackage && (matchContent = `"(dev)?(d|D)ependencies":\\s*{[^}]*"${matchPackage}":\\s*"(.+?)"[^}]*}`), await fs2.hasPath(path2) !== !1) {
        if (matchContent) {
          if (await fs2.isFile(path2) === !1)
            return;
          const regex2 = new RegExp(matchContent, "m"), match2 = (await fs2.readFile(path2)).toString().match(regex2);
          if (!match2)
            return;
          if (matchPackage && match2[3])
            return {
              framework,
              detectedVersion: match2[3]
            };
        }
        return {
          framework
        };
      }
    }, result = [];
    if (every2) {
      const everyResult = await Promise.all(every2.map((item) => check(item)));
      result.push(...everyResult);
    }
    if (some) {
      let someResult;
      for (const item of some) {
        const itemResult = await check(item);
        if (itemResult) {
          someResult = itemResult;
          break;
        }
      }
      result.push(someResult);
    }
    if (!result.every((res) => !!res))
      return;
    const detectedVersion = result.find((r) => typeof r == "object" && r.detectedVersion)?.detectedVersion;
    return {
      framework,
      detectedVersion
    };
  }
  async function detectFramework$1({ fs: fs2, frameworkList }) {
    return (await Promise.all(frameworkList.map(async (frameworkMatch) => await matches(fs2, frameworkMatch) ? frameworkMatch.slug : null))).find((res) => res !== null) ?? null;
  }
  detectFramework.detectFramework = detectFramework$1;
  async function detectFrameworks({ fs: fs2, frameworkList }) {
    return (await Promise.all(frameworkList.map(async (frameworkMatch) => await matches(fs2, frameworkMatch) ? frameworkMatch : null))).filter((res) => res !== null);
  }
  detectFramework.detectFrameworks = detectFrameworks;
  async function detectFrameworkRecord({ fs: fs2, frameworkList }) {
    return (await Promise.all(frameworkList.map(async (frameworkMatch) => {
      const matchResult = await matches(fs2, frameworkMatch);
      return matchResult ? {
        ...frameworkMatch,
        detectedVersion: matchResult?.detectedVersion
      } : null;
    }))).find((res) => res !== null) ?? null;
  }
  detectFramework.detectFrameworkRecord = detectFrameworkRecord;
  function detectFrameworkVersion(frameworkRecord) {
    const firstMatchPackage = [
      ...frameworkRecord.detectors?.every || [],
      ...frameworkRecord.detectors?.some || []
    ].find((d) => d.matchPackage);
    if (firstMatchPackage?.matchPackage)
      return lookupInstalledVersion(process.execPath, firstMatchPackage.matchPackage);
  }
  detectFramework.detectFrameworkVersion = detectFrameworkVersion;
  function lookupInstalledVersion(cwd, packageName) {
    try {
      const script = `require('${packageName}/package.json').version`;
      return (0, child_process_1.spawnSync)(cwd, ["-p", script], {
        encoding: "utf-8"
      }).stdout.trim();
    } catch (error2) {
      console.debug(`Error looking up version of installed package "${packageName}": ${error2}`);
    }
  }
  return detectFramework;
}
var getProjectPaths = {}, hasRequiredGetProjectPaths;
function requireGetProjectPaths() {
  return hasRequiredGetProjectPaths || (hasRequiredGetProjectPaths = 1, function(exports2) {
    var __importDefault2 = getProjectPaths && getProjectPaths.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.getProjectPaths = void 0;
    const detect_framework_1 = requireDetectFramework(), frameworks_1 = __importDefault2(requireFrameworks()), MAX_DEPTH_TRAVERSE = 3, getProjectPaths$1 = async ({ fs: fs2, path: path2, skipPaths, depth = MAX_DEPTH_TRAVERSE }) => {
      if (depth === 0)
        return [];
      const allPaths = [], topPath = path2 ?? "./";
      if (path2 && skipPaths?.includes(path2))
        return allPaths;
      if (await (0, detect_framework_1.detectFramework)({
        fs: fs2.chdir(topPath),
        frameworkList: frameworks_1.default
      }) !== null && allPaths.push(topPath), depth > 1) {
        const childDirectories = (await fs2.readdir(topPath)).filter((stat2) => stat2.type === "dir" && !skipPaths?.includes(stat2.path));
        return [...(await Promise.all(childDirectories.map(({ path: path3 }) => (0, exports2.getProjectPaths)({
          fs: fs2,
          path: path3,
          depth: depth - 1,
          skipPaths
        })))).flat(), ...allPaths];
      }
      return allPaths;
    };
    exports2.getProjectPaths = getProjectPaths$1;
  }(getProjectPaths)), getProjectPaths;
}
var filesystem = {}, hasRequiredFilesystem;
function requireFilesystem() {
  if (hasRequiredFilesystem) return filesystem;
  hasRequiredFilesystem = 1, Object.defineProperty(filesystem, "__esModule", { value: !0 }), filesystem.DetectorFilesystem = void 0;
  const path_1 = require$$0__default$1.default;
  class DetectorFilesystem {
    constructor() {
      this.hasPath = async (path2) => {
        let p = this.pathCache.get(path2);
        return p || (p = this._hasPath(path2), this.pathCache.set(path2, p)), p;
      }, this.isFile = async (name) => {
        let p = this.fileCache.get(name);
        return p || (p = this._isFile(name), this.fileCache.set(name, p)), p;
      }, this.readFile = async (name) => {
        let p = this.readFileCache.get(name);
        return p || (p = this._readFile(name), this.readFileCache.set(name, p)), p;
      }, this.readdir = async (dirPath, options2) => {
        let p = this.readdirCache.get(dirPath);
        p || (p = this._readdir(dirPath), this.readdirCache.set(dirPath, p));
        const directoryContent = await p, directoryFiles = /* @__PURE__ */ new Set();
        for (const file of directoryContent)
          file.type === "file" && (this.fileCache.set(file.path, Promise.resolve(!0)), this.pathCache.set(file.path, Promise.resolve(!0)), directoryFiles.add(file.name));
        if (options2?.potentialFiles) {
          const filesThatDoNotExist = options2.potentialFiles.filter((path2) => !directoryFiles.has(path2));
          for (const filePath of filesThatDoNotExist) {
            const fullFilePath = dirPath === "/" ? filePath : path_1.posix.join(dirPath, filePath);
            this.fileCache.set(fullFilePath, Promise.resolve(!1)), this.pathCache.set(fullFilePath, Promise.resolve(!1));
          }
        }
        return p;
      }, this.chdir = (name) => this._chdir(name), this.writeFile = async (name, content) => {
        this.readFileCache.set(name, Promise.resolve(Buffer.from(content))), this.fileCache.set(name, Promise.resolve(!0)), this.pathCache.set(name, Promise.resolve(!0));
      }, this.pathCache = /* @__PURE__ */ new Map(), this.fileCache = /* @__PURE__ */ new Map(), this.readFileCache = /* @__PURE__ */ new Map(), this.readdirCache = /* @__PURE__ */ new Map();
    }
  }
  return filesystem.DetectorFilesystem = DetectorFilesystem, filesystem;
}
var localFileSystemDetector = {}, hasRequiredLocalFileSystemDetector;
function requireLocalFileSystemDetector() {
  if (hasRequiredLocalFileSystemDetector) return localFileSystemDetector;
  hasRequiredLocalFileSystemDetector = 1;
  var __importDefault2 = localFileSystemDetector && localFileSystemDetector.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(localFileSystemDetector, "__esModule", { value: !0 }), localFileSystemDetector.LocalFileSystemDetector = void 0;
  const promises_1 = __importDefault2(require$$0__default$8.default), path_1 = require$$0__default$1.default, filesystem_1 = requireFilesystem(), error_utils_1 = requireDist$1();
  class LocalFileSystemDetector extends filesystem_1.DetectorFilesystem {
    constructor(rootPath) {
      super(), this.rootPath = rootPath;
    }
    async _hasPath(name) {
      try {
        return await promises_1.default.stat(this.getFilePath(name)), !0;
      } catch (err) {
        if ((0, error_utils_1.isErrnoException)(err) && err.code === "ENOENT")
          return !1;
        throw err;
      }
    }
    _readFile(name) {
      return promises_1.default.readFile(this.getFilePath(name));
    }
    async _isFile(name) {
      return (await promises_1.default.stat(this.getFilePath(name))).isFile();
    }
    async _readdir(dir) {
      const dirPath = this.getFilePath(dir), files = await promises_1.default.readdir(dirPath);
      return Promise.all(files.map(async (name) => {
        const absPath = (0, path_1.join)(this.rootPath, dir, name), path2 = (0, path_1.join)(this.getRelativeFilePath(dir), name), stat2 = await promises_1.default.stat(absPath);
        let type2;
        if (stat2.isFile())
          type2 = "file";
        else if (stat2.isDirectory())
          type2 = "dir";
        else
          throw new Error(`Dirent was neither file nor directory: ${path2}`);
        return { name, path: path2, type: type2 };
      }));
    }
    _chdir(name) {
      return new LocalFileSystemDetector(this.getFilePath(name));
    }
    getRelativeFilePath(name) {
      return name.startsWith(this.rootPath) ? (0, path_1.relative)(this.rootPath, name) : name;
    }
    getFilePath(name) {
      return (0, path_1.join)(this.rootPath, this.getRelativeFilePath(name));
    }
  }
  return localFileSystemDetector.LocalFileSystemDetector = LocalFileSystemDetector, localFileSystemDetector;
}
var workspaceManagers = {}, hasRequiredWorkspaceManagers;
function requireWorkspaceManagers() {
  return hasRequiredWorkspaceManagers || (hasRequiredWorkspaceManagers = 1, function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.workspaceManagers = void 0, exports2.workspaceManagers = [
      {
        name: "Yarn",
        slug: "yarn",
        detectors: {
          every: [
            {
              path: "package.json",
              matchContent: '"workspaces":\\s*(?:\\[[^\\]]*]|{[^}]*"packages":[^}]*})'
            },
            {
              path: "yarn.lock"
            }
          ]
        }
      },
      {
        name: "pnpm",
        slug: "pnpm",
        detectors: {
          every: [
            {
              path: "pnpm-workspace.yaml"
            }
          ]
        }
      },
      {
        name: "npm",
        slug: "npm",
        detectors: {
          every: [
            {
              path: "package.json",
              matchContent: '"workspaces":\\s*(?:\\[[^\\]]*]|{[^}]*"packages":[^}]*})'
            },
            {
              path: "package-lock.json"
            }
          ]
        }
      },
      {
        name: "nx",
        slug: "nx",
        detectors: {
          every: [
            {
              path: "workspace.json",
              matchContent: '"projects":\\s*{[^}]'
            }
          ]
        }
      },
      {
        name: "rush",
        slug: "rush",
        detectors: {
          every: [
            {
              path: "rush.json"
            }
          ]
        }
      },
      {
        name: "default",
        slug: "yarn",
        detectors: {
          every: [
            {
              path: "package.json",
              matchContent: '"workspaces":\\s*(?:\\[[^\\]]*]|{[^}]*"packages":[^}]*})'
            }
          ]
        }
      }
    ], exports2.default = exports2.workspaceManagers;
  }(workspaceManagers)), workspaceManagers;
}
var getWorkspaces = {}, hasRequiredGetWorkspaces;
function requireGetWorkspaces() {
  if (hasRequiredGetWorkspaces) return getWorkspaces;
  hasRequiredGetWorkspaces = 1;
  var __importDefault2 = getWorkspaces && getWorkspaces.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(getWorkspaces, "__esModule", { value: !0 }), getWorkspaces.getWorkspaces = void 0;
  const path_1 = __importDefault2(require$$0__default$1.default), workspace_managers_1 = requireWorkspaceManagers(), detect_framework_1 = requireDetectFramework(), MAX_DEPTH_TRAVERSE = 3, posixPath = path_1.default.posix;
  async function getWorkspaces$1({ fs: fs2, depth = MAX_DEPTH_TRAVERSE, cwd = "/" }) {
    if (depth === 0)
      return [];
    const workspaceType = await (0, detect_framework_1.detectFramework)({
      fs: fs2,
      frameworkList: workspace_managers_1.workspaceManagers
    });
    if (workspaceType === null) {
      const childDirectories = (await fs2.readdir("./")).filter((stat2) => stat2.type === "dir");
      return (await Promise.all(childDirectories.map((childDirectory) => getWorkspaces$1({
        fs: fs2.chdir(childDirectory.path),
        depth: depth - 1,
        cwd: posixPath.join(cwd, childDirectory.path)
      })))).flat();
    }
    return [
      {
        type: workspaceType,
        rootPath: cwd
      }
    ];
  }
  return getWorkspaces.getWorkspaces = getWorkspaces$1, getWorkspaces;
}
var getWorkspacePackagePaths = {}, jsYaml$2 = {}, loader$1 = {}, common$2 = {}, hasRequiredCommon$2;
function requireCommon$2() {
  if (hasRequiredCommon$2) return common$2;
  hasRequiredCommon$2 = 1;
  function isNothing(subject) {
    return typeof subject > "u" || subject === null;
  }
  function isObject2(subject) {
    return typeof subject == "object" && subject !== null;
  }
  function toArray2(sequence) {
    return Array.isArray(sequence) ? sequence : isNothing(sequence) ? [] : [sequence];
  }
  function extend(target, source2) {
    var index, length, key2, sourceKeys;
    if (source2)
      for (sourceKeys = Object.keys(source2), index = 0, length = sourceKeys.length; index < length; index += 1)
        key2 = sourceKeys[index], target[key2] = source2[key2];
    return target;
  }
  function repeat2(string, count2) {
    var result = "", cycle;
    for (cycle = 0; cycle < count2; cycle += 1)
      result += string;
    return result;
  }
  function isNegativeZero(number2) {
    return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
  }
  return common$2.isNothing = isNothing, common$2.isObject = isObject2, common$2.toArray = toArray2, common$2.repeat = repeat2, common$2.isNegativeZero = isNegativeZero, common$2.extend = extend, common$2;
}
var exception$1, hasRequiredException$1;
function requireException$1() {
  if (hasRequiredException$1) return exception$1;
  hasRequiredException$1 = 1;
  function formatError(exception2, compact) {
    var where = "", message = exception2.reason || "(unknown reason)";
    return exception2.mark ? (exception2.mark.name && (where += 'in "' + exception2.mark.name + '" '), where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")", !compact && exception2.mark.snippet && (where += `

` + exception2.mark.snippet), message + " " + where) : message;
  }
  function YAMLException(reason, mark2) {
    Error.call(this), this.name = "YAMLException", this.reason = reason, this.mark = mark2, this.message = formatError(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
  }
  return YAMLException.prototype = Object.create(Error.prototype), YAMLException.prototype.constructor = YAMLException, YAMLException.prototype.toString = function(compact) {
    return this.name + ": " + formatError(this, compact);
  }, exception$1 = YAMLException, exception$1;
}
var snippet, hasRequiredSnippet;
function requireSnippet() {
  if (hasRequiredSnippet) return snippet;
  hasRequiredSnippet = 1;
  var common2 = requireCommon$2();
  function getLine(buffer2, lineStart, lineEnd, position, maxLineLength) {
    var head = "", tail = "", maxHalfLength = Math.floor(maxLineLength / 2) - 1;
    return position - lineStart > maxHalfLength && (head = " ... ", lineStart = position - maxHalfLength + head.length), lineEnd - position > maxHalfLength && (tail = " ...", lineEnd = position + maxHalfLength - tail.length), {
      str: head + buffer2.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
      pos: position - lineStart + head.length
      // relative position
    };
  }
  function padStart(string, max2) {
    return common2.repeat(" ", max2 - string.length) + string;
  }
  function makeSnippet(mark2, options2) {
    if (options2 = Object.create(options2 || null), !mark2.buffer) return null;
    options2.maxLength || (options2.maxLength = 79), typeof options2.indent != "number" && (options2.indent = 1), typeof options2.linesBefore != "number" && (options2.linesBefore = 3), typeof options2.linesAfter != "number" && (options2.linesAfter = 2);
    for (var re = /\r?\n|\r|\0/g, lineStarts = [0], lineEnds = [], match2, foundLineNo = -1; match2 = re.exec(mark2.buffer); )
      lineEnds.push(match2.index), lineStarts.push(match2.index + match2[0].length), mark2.position <= match2.index && foundLineNo < 0 && (foundLineNo = lineStarts.length - 2);
    foundLineNo < 0 && (foundLineNo = lineStarts.length - 1);
    var result = "", i, line3, lineNoLength = Math.min(mark2.line + options2.linesAfter, lineEnds.length).toString().length, maxLineLength = options2.maxLength - (options2.indent + lineNoLength + 3);
    for (i = 1; i <= options2.linesBefore && !(foundLineNo - i < 0); i++)
      line3 = getLine(
        mark2.buffer,
        lineStarts[foundLineNo - i],
        lineEnds[foundLineNo - i],
        mark2.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
        maxLineLength
      ), result = common2.repeat(" ", options2.indent) + padStart((mark2.line - i + 1).toString(), lineNoLength) + " | " + line3.str + `
` + result;
    for (line3 = getLine(mark2.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark2.position, maxLineLength), result += common2.repeat(" ", options2.indent) + padStart((mark2.line + 1).toString(), lineNoLength) + " | " + line3.str + `
`, result += common2.repeat("-", options2.indent + lineNoLength + 3 + line3.pos) + `^
`, i = 1; i <= options2.linesAfter && !(foundLineNo + i >= lineEnds.length); i++)
      line3 = getLine(
        mark2.buffer,
        lineStarts[foundLineNo + i],
        lineEnds[foundLineNo + i],
        mark2.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
        maxLineLength
      ), result += common2.repeat(" ", options2.indent) + padStart((mark2.line + i + 1).toString(), lineNoLength) + " | " + line3.str + `
`;
    return result.replace(/\n$/, "");
  }
  return snippet = makeSnippet, snippet;
}
var type$1, hasRequiredType$1;
function requireType$1() {
  if (hasRequiredType$1) return type$1;
  hasRequiredType$1 = 1;
  var YAMLException = requireException$1(), TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ], YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map2) {
    var result = {};
    return map2 !== null && Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    }), result;
  }
  function Type(tag, options2) {
    if (options2 = options2 || {}, Object.keys(options2).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1)
        throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }), this.options = options2, this.tag = tag, this.kind = options2.kind || null, this.resolve = options2.resolve || function() {
      return !0;
    }, this.construct = options2.construct || function(data) {
      return data;
    }, this.instanceOf = options2.instanceOf || null, this.predicate = options2.predicate || null, this.represent = options2.represent || null, this.representName = options2.representName || null, this.defaultStyle = options2.defaultStyle || null, this.multi = options2.multi || !1, this.styleAliases = compileStyleAliases(options2.styleAliases || null), YAML_NODE_KINDS.indexOf(this.kind) === -1)
      throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
  return type$1 = Type, type$1;
}
var schema$1, hasRequiredSchema$1;
function requireSchema$1() {
  if (hasRequiredSchema$1) return schema$1;
  hasRequiredSchema$1 = 1;
  var YAMLException = requireException$1(), Type = requireType$1();
  function compileList(schema2, name) {
    var result = [];
    return schema2[name].forEach(function(currentType) {
      var newIndex = result.length;
      result.forEach(function(previousType, previousIndex) {
        previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi && (newIndex = previousIndex);
      }), result[newIndex] = currentType;
    }), result;
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, index, length;
    function collectType(type2) {
      type2.multi ? (result.multi[type2.kind].push(type2), result.multi.fallback.push(type2)) : result[type2.kind][type2.tag] = result.fallback[type2.tag] = type2;
    }
    for (index = 0, length = arguments.length; index < length; index += 1)
      arguments[index].forEach(collectType);
    return result;
  }
  function Schema(definition) {
    return this.extend(definition);
  }
  return Schema.prototype.extend = function(definition) {
    var implicit = [], explicit = [];
    if (definition instanceof Type)
      explicit.push(definition);
    else if (Array.isArray(definition))
      explicit = explicit.concat(definition);
    else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit)))
      definition.implicit && (implicit = implicit.concat(definition.implicit)), definition.explicit && (explicit = explicit.concat(definition.explicit));
    else
      throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    implicit.forEach(function(type2) {
      if (!(type2 instanceof Type))
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      if (type2.loadKind && type2.loadKind !== "scalar")
        throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      if (type2.multi)
        throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }), explicit.forEach(function(type2) {
      if (!(type2 instanceof Type))
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    });
    var result = Object.create(Schema.prototype);
    return result.implicit = (this.implicit || []).concat(implicit), result.explicit = (this.explicit || []).concat(explicit), result.compiledImplicit = compileList(result, "implicit"), result.compiledExplicit = compileList(result, "explicit"), result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit), result;
  }, schema$1 = Schema, schema$1;
}
var str$1, hasRequiredStr$1;
function requireStr$1() {
  if (hasRequiredStr$1) return str$1;
  hasRequiredStr$1 = 1;
  var Type = requireType$1();
  return str$1 = new Type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  }), str$1;
}
var seq$1, hasRequiredSeq$1;
function requireSeq$1() {
  if (hasRequiredSeq$1) return seq$1;
  hasRequiredSeq$1 = 1;
  var Type = requireType$1();
  return seq$1 = new Type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  }), seq$1;
}
var map$2, hasRequiredMap$1;
function requireMap$1() {
  if (hasRequiredMap$1) return map$2;
  hasRequiredMap$1 = 1;
  var Type = requireType$1();
  return map$2 = new Type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  }), map$2;
}
var failsafe$1, hasRequiredFailsafe$1;
function requireFailsafe$1() {
  if (hasRequiredFailsafe$1) return failsafe$1;
  hasRequiredFailsafe$1 = 1;
  var Schema = requireSchema$1();
  return failsafe$1 = new Schema({
    explicit: [
      requireStr$1(),
      requireSeq$1(),
      requireMap$1()
    ]
  }), failsafe$1;
}
var _null$1, hasRequired_null$1;
function require_null$1() {
  if (hasRequired_null$1) return _null$1;
  hasRequired_null$1 = 1;
  var Type = requireType$1();
  function resolveYamlNull(data) {
    if (data === null) return !0;
    var max2 = data.length;
    return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  return _null$1 = new Type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  }), _null$1;
}
var bool$1, hasRequiredBool$1;
function requireBool$1() {
  if (hasRequiredBool$1) return bool$1;
  hasRequiredBool$1 = 1;
  var Type = requireType$1();
  function resolveYamlBoolean(data) {
    if (data === null) return !1;
    var max2 = data.length;
    return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  return bool$1 = new Type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  }), bool$1;
}
var int$1, hasRequiredInt$1;
function requireInt$1() {
  if (hasRequiredInt$1) return int$1;
  hasRequiredInt$1 = 1;
  var common2 = requireCommon$2(), Type = requireType$1();
  function isHexCode(c2) {
    return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
  }
  function isOctCode(c2) {
    return 48 <= c2 && c2 <= 55;
  }
  function isDecCode(c2) {
    return 48 <= c2 && c2 <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null) return !1;
    var max2 = data.length, index = 0, hasDigits = !1, ch;
    if (!max2) return !1;
    if (ch = data[index], (ch === "-" || ch === "+") && (ch = data[++index]), ch === "0") {
      if (index + 1 === max2) return !0;
      if (ch = data[++index], ch === "b") {
        for (index++; index < max2; index++)
          if (ch = data[index], ch !== "_") {
            if (ch !== "0" && ch !== "1") return !1;
            hasDigits = !0;
          }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        for (index++; index < max2; index++)
          if (ch = data[index], ch !== "_") {
            if (!isHexCode(data.charCodeAt(index))) return !1;
            hasDigits = !0;
          }
        return hasDigits && ch !== "_";
      }
      if (ch === "o") {
        for (index++; index < max2; index++)
          if (ch = data[index], ch !== "_") {
            if (!isOctCode(data.charCodeAt(index))) return !1;
            hasDigits = !0;
          }
        return hasDigits && ch !== "_";
      }
    }
    if (ch === "_") return !1;
    for (; index < max2; index++)
      if (ch = data[index], ch !== "_") {
        if (!isDecCode(data.charCodeAt(index)))
          return !1;
        hasDigits = !0;
      }
    return !(!hasDigits || ch === "_");
  }
  function constructYamlInteger(data) {
    var value = data, sign2 = 1, ch;
    if (value.indexOf("_") !== -1 && (value = value.replace(/_/g, "")), ch = value[0], (ch === "-" || ch === "+") && (ch === "-" && (sign2 = -1), value = value.slice(1), ch = value[0]), value === "0") return 0;
    if (ch === "0") {
      if (value[1] === "b") return sign2 * parseInt(value.slice(2), 2);
      if (value[1] === "x") return sign2 * parseInt(value.slice(2), 16);
      if (value[1] === "o") return sign2 * parseInt(value.slice(2), 8);
    }
    return sign2 * parseInt(value, 10);
  }
  function isInteger2(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common2.isNegativeZero(object);
  }
  return int$1 = new Type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger2,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  }), int$1;
}
var float$1, hasRequiredFloat$1;
function requireFloat$1() {
  if (hasRequiredFloat$1) return float$1;
  hasRequiredFloat$1 = 1;
  var common2 = requireCommon$2(), Type = requireType$1(), YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function resolveYamlFloat(data) {
    return !(data === null || !YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_");
  }
  function constructYamlFloat(data) {
    var value, sign2;
    return value = data.replace(/_/g, "").toLowerCase(), sign2 = value[0] === "-" ? -1 : 1, "+-".indexOf(value[0]) >= 0 && (value = value.slice(1)), value === ".inf" ? sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : value === ".nan" ? NaN : sign2 * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object))
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    else if (Number.POSITIVE_INFINITY === object)
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    else if (Number.NEGATIVE_INFINITY === object)
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    else if (common2.isNegativeZero(object))
      return "-0.0";
    return res = object.toString(10), SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat2(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common2.isNegativeZero(object));
  }
  return float$1 = new Type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat2,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  }), float$1;
}
var json$1, hasRequiredJson$1;
function requireJson$1() {
  return hasRequiredJson$1 || (hasRequiredJson$1 = 1, json$1 = requireFailsafe$1().extend({
    implicit: [
      require_null$1(),
      requireBool$1(),
      requireInt$1(),
      requireFloat$1()
    ]
  })), json$1;
}
var core$4, hasRequiredCore$4;
function requireCore$4() {
  return hasRequiredCore$4 || (hasRequiredCore$4 = 1, core$4 = requireJson$1()), core$4;
}
var timestamp$2, hasRequiredTimestamp$1;
function requireTimestamp$1() {
  if (hasRequiredTimestamp$1) return timestamp$2;
  hasRequiredTimestamp$1 = 1;
  var Type = requireType$1(), YAML_DATE_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  ), YAML_TIMESTAMP_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function resolveYamlTimestamp(data) {
    return data === null ? !1 : YAML_DATE_REGEXP.exec(data) !== null || YAML_TIMESTAMP_REGEXP.exec(data) !== null;
  }
  function constructYamlTimestamp(data) {
    var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    if (match2 = YAML_DATE_REGEXP.exec(data), match2 === null && (match2 = YAML_TIMESTAMP_REGEXP.exec(data)), match2 === null) throw new Error("Date resolve error");
    if (year = +match2[1], month = +match2[2] - 1, day = +match2[3], !match2[4])
      return new Date(Date.UTC(year, month, day));
    if (hour = +match2[4], minute = +match2[5], second = +match2[6], match2[7]) {
      for (fraction = match2[7].slice(0, 3); fraction.length < 3; )
        fraction += "0";
      fraction = +fraction;
    }
    return match2[9] && (tz_hour = +match2[10], tz_minute = +(match2[11] || 0), delta = (tz_hour * 60 + tz_minute) * 6e4, match2[9] === "-" && (delta = -delta)), date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction)), delta && date.setTime(date.getTime() - delta), date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  return timestamp$2 = new Type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  }), timestamp$2;
}
var merge$3, hasRequiredMerge$1;
function requireMerge$1() {
  if (hasRequiredMerge$1) return merge$3;
  hasRequiredMerge$1 = 1;
  var Type = requireType$1();
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  return merge$3 = new Type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  }), merge$3;
}
var binary$2, hasRequiredBinary$1;
function requireBinary$1() {
  if (hasRequiredBinary$1) return binary$2;
  hasRequiredBinary$1 = 1;
  var Type = requireType$1(), BASE64_MAP = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function resolveYamlBinary(data) {
    if (data === null) return !1;
    var code, idx, bitlen = 0, max2 = data.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++)
      if (code = map2.indexOf(data.charAt(idx)), !(code > 64)) {
        if (code < 0) return !1;
        bitlen += 6;
      }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input2 = data.replace(/[\r\n=]/g, ""), max2 = input2.length, map2 = BASE64_MAP, bits = 0, result = [];
    for (idx = 0; idx < max2; idx++)
      idx % 4 === 0 && idx && (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)), bits = bits << 6 | map2.indexOf(input2.charAt(idx));
    return tailbits = max2 % 4 * 6, tailbits === 0 ? (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)) : tailbits === 18 ? (result.push(bits >> 10 & 255), result.push(bits >> 2 & 255)) : tailbits === 12 && result.push(bits >> 4 & 255), new Uint8Array(result);
  }
  function representYamlBinary(object) {
    var result = "", bits = 0, idx, tail, max2 = object.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++)
      idx % 3 === 0 && idx && (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]), bits = (bits << 8) + object[idx];
    return tail = max2 % 3, tail === 0 ? (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]) : tail === 2 ? (result += map2[bits >> 10 & 63], result += map2[bits >> 4 & 63], result += map2[bits << 2 & 63], result += map2[64]) : tail === 1 && (result += map2[bits >> 2 & 63], result += map2[bits << 4 & 63], result += map2[64], result += map2[64]), result;
  }
  function isBinary(obj) {
    return Object.prototype.toString.call(obj) === "[object Uint8Array]";
  }
  return binary$2 = new Type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  }), binary$2;
}
var omap$1, hasRequiredOmap$1;
function requireOmap$1() {
  if (hasRequiredOmap$1) return omap$1;
  hasRequiredOmap$1 = 1;
  var Type = requireType$1(), _hasOwnProperty = Object.prototype.hasOwnProperty, _toString = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null) return !0;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for (index = 0, length = object.length; index < length; index += 1) {
      if (pair = object[index], pairHasKey = !1, _toString.call(pair) !== "[object Object]") return !1;
      for (pairKey in pair)
        if (_hasOwnProperty.call(pair, pairKey))
          if (!pairHasKey) pairHasKey = !0;
          else return !1;
      if (!pairHasKey) return !1;
      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return !1;
    }
    return !0;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  return omap$1 = new Type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  }), omap$1;
}
var pairs$2, hasRequiredPairs$1;
function requirePairs$1() {
  if (hasRequiredPairs$1) return pairs$2;
  hasRequiredPairs$1 = 1;
  var Type = requireType$1(), _toString = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null) return !0;
    var index, length, pair, keys, result, object = data;
    for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1) {
      if (pair = object[index], _toString.call(pair) !== "[object Object]" || (keys = Object.keys(pair), keys.length !== 1)) return !1;
      result[index] = [keys[0], pair[keys[0]]];
    }
    return !0;
  }
  function constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair, keys, result, object = data;
    for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1)
      pair = object[index], keys = Object.keys(pair), result[index] = [keys[0], pair[keys[0]]];
    return result;
  }
  return pairs$2 = new Type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  }), pairs$2;
}
var set$1, hasRequiredSet$1;
function requireSet$1() {
  if (hasRequiredSet$1) return set$1;
  hasRequiredSet$1 = 1;
  var Type = requireType$1(), _hasOwnProperty = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null) return !0;
    var key2, object = data;
    for (key2 in object)
      if (_hasOwnProperty.call(object, key2) && object[key2] !== null)
        return !1;
    return !0;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  return set$1 = new Type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  }), set$1;
}
var _default, hasRequired_default;
function require_default() {
  return hasRequired_default || (hasRequired_default = 1, _default = requireCore$4().extend({
    implicit: [
      requireTimestamp$1(),
      requireMerge$1()
    ],
    explicit: [
      requireBinary$1(),
      requireOmap$1(),
      requirePairs$1(),
      requireSet$1()
    ]
  })), _default;
}
var hasRequiredLoader$1;
function requireLoader$1() {
  if (hasRequiredLoader$1) return loader$1;
  hasRequiredLoader$1 = 1;
  var common2 = requireCommon$2(), YAMLException = requireException$1(), makeSnippet = requireSnippet(), DEFAULT_SCHEMA = require_default(), _hasOwnProperty = Object.prototype.hasOwnProperty, CONTEXT_FLOW_IN = 1, CONTEXT_FLOW_OUT = 2, CONTEXT_BLOCK_IN = 3, CONTEXT_BLOCK_OUT = 4, CHOMPING_CLIP = 1, CHOMPING_STRIP = 2, CHOMPING_KEEP = 3, PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/, PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/, PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i, PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c2) {
    return c2 === 10 || c2 === 13;
  }
  function is_WHITE_SPACE(c2) {
    return c2 === 9 || c2 === 32;
  }
  function is_WS_OR_EOL(c2) {
    return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
  }
  function is_FLOW_INDICATOR(c2) {
    return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
  }
  function fromHexCode(c2) {
    var lc;
    return 48 <= c2 && c2 <= 57 ? c2 - 48 : (lc = c2 | 32, 97 <= lc && lc <= 102 ? lc - 97 + 10 : -1);
  }
  function escapedHexLen(c2) {
    return c2 === 120 ? 2 : c2 === 117 ? 4 : c2 === 85 ? 8 : 0;
  }
  function fromDecimalCode(c2) {
    return 48 <= c2 && c2 <= 57 ? c2 - 48 : -1;
  }
  function simpleEscapeSequence(c2) {
    return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 || c2 === 9 ? "	" : c2 === 110 ? `
` : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c2) {
    return c2 <= 65535 ? String.fromCharCode(c2) : String.fromCharCode(
      (c2 - 65536 >> 10) + 55296,
      (c2 - 65536 & 1023) + 56320
    );
  }
  for (var simpleEscapeCheck = new Array(256), simpleEscapeMap = new Array(256), i = 0; i < 256; i++)
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0, simpleEscapeMap[i] = simpleEscapeSequence(i);
  function State(input2, options2) {
    this.input = input2, this.filename = options2.filename || null, this.schema = options2.schema || DEFAULT_SCHEMA, this.onWarning = options2.onWarning || null, this.legacy = options2.legacy || !1, this.json = options2.json || !1, this.listener = options2.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = input2.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
  }
  function generateError(state, message) {
    var mark2 = {
      name: state.filename,
      buffer: state.input.slice(0, -1),
      // omit trailing \0
      position: state.position,
      line: state.line,
      column: state.position - state.lineStart
    };
    return mark2.snippet = makeSnippet(mark2), new YAMLException(message, mark2);
  }
  function throwError2(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    state.onWarning && state.onWarning.call(null, generateError(state, message));
  }
  var directiveHandlers = {
    YAML: function(state, name, args) {
      var match2, major2, minor2;
      state.version !== null && throwError2(state, "duplication of %YAML directive"), args.length !== 1 && throwError2(state, "YAML directive accepts exactly one argument"), match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]), match2 === null && throwError2(state, "ill-formed argument of the YAML directive"), major2 = parseInt(match2[1], 10), minor2 = parseInt(match2[2], 10), major2 !== 1 && throwError2(state, "unacceptable YAML version of the document"), state.version = args[0], state.checkLineBreaks = minor2 < 2, minor2 !== 1 && minor2 !== 2 && throwWarning(state, "unsupported YAML version of the document");
    },
    TAG: function(state, name, args) {
      var handle, prefix;
      args.length !== 2 && throwError2(state, "TAG directive accepts exactly two arguments"), handle = args[0], prefix = args[1], PATTERN_TAG_HANDLE.test(handle) || throwError2(state, "ill-formed tag handle (first argument) of the TAG directive"), _hasOwnProperty.call(state.tagMap, handle) && throwError2(state, 'there is a previously declared suffix for "' + handle + '" tag handle'), PATTERN_TAG_URI.test(prefix) || throwError2(state, "ill-formed tag prefix (second argument) of the TAG directive");
      try {
        prefix = decodeURIComponent(prefix);
      } catch {
        throwError2(state, "tag prefix is malformed: " + prefix);
      }
      state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      if (_result = state.input.slice(start, end), checkJson)
        for (_position = 0, _length = _result.length; _position < _length; _position += 1)
          _character = _result.charCodeAt(_position), _character === 9 || 32 <= _character && _character <= 1114111 || throwError2(state, "expected valid JSON character");
      else PATTERN_NON_PRINTABLE.test(_result) && throwError2(state, "the stream contains non-printable characters");
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source2, overridableKeys) {
    var sourceKeys, key2, index, quantity;
    for (common2.isObject(source2) || throwError2(state, "cannot merge mappings; the provided source object is unacceptable"), sourceKeys = Object.keys(source2), index = 0, quantity = sourceKeys.length; index < quantity; index += 1)
      key2 = sourceKeys[index], _hasOwnProperty.call(destination, key2) || (destination[key2] = source2[key2], overridableKeys[key2] = !0);
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode))
      for (keyNode = Array.prototype.slice.call(keyNode), index = 0, quantity = keyNode.length; index < quantity; index += 1)
        Array.isArray(keyNode[index]) && throwError2(state, "nested arrays are not supported inside keys"), typeof keyNode == "object" && _class(keyNode[index]) === "[object Object]" && (keyNode[index] = "[object Object]");
    if (typeof keyNode == "object" && _class(keyNode) === "[object Object]" && (keyNode = "[object Object]"), keyNode = String(keyNode), _result === null && (_result = {}), keyTag === "tag:yaml.org,2002:merge")
      if (Array.isArray(valueNode))
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1)
          mergeMappings(state, _result, valueNode[index], overridableKeys);
      else
        mergeMappings(state, _result, valueNode, overridableKeys);
    else
      !state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode) && (state.line = startLine || state.line, state.lineStart = startLineStart || state.lineStart, state.position = startPos || state.position, throwError2(state, "duplicated mapping key")), keyNode === "__proto__" ? Object.defineProperty(_result, keyNode, {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        value: valueNode
      }) : _result[keyNode] = valueNode, delete overridableKeys[keyNode];
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position), ch === 10 ? state.position++ : ch === 13 ? (state.position++, state.input.charCodeAt(state.position) === 10 && state.position++) : throwError2(state, "a line break is expected"), state.line += 1, state.lineStart = state.position, state.firstTabInLine = -1;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    for (var lineBreaks = 0, ch = state.input.charCodeAt(state.position); ch !== 0; ) {
      for (; is_WHITE_SPACE(ch); )
        ch === 9 && state.firstTabInLine === -1 && (state.firstTabInLine = state.position), ch = state.input.charCodeAt(++state.position);
      if (allowComments && ch === 35)
        do
          ch = state.input.charCodeAt(++state.position);
        while (ch !== 10 && ch !== 13 && ch !== 0);
      if (is_EOL(ch))
        for (readLineBreak(state), ch = state.input.charCodeAt(state.position), lineBreaks++, state.lineIndent = 0; ch === 32; )
          state.lineIndent++, ch = state.input.charCodeAt(++state.position);
      else
        break;
    }
    return checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent && throwWarning(state, "deficient indentation"), lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch;
    return ch = state.input.charCodeAt(_position), !!((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2) && (_position += 3, ch = state.input.charCodeAt(_position), ch === 0 || is_WS_OR_EOL(ch)));
  }
  function writeFoldedLines(state, count2) {
    count2 === 1 ? state.result += " " : count2 > 1 && (state.result += common2.repeat(`
`, count2 - 1));
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    if (ch = state.input.charCodeAt(state.position), is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96 || (ch === 63 || ch === 45) && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)))
      return !1;
    for (state.kind = "scalar", state.result = "", captureStart = captureEnd = state.position, hasPendingContent = !1; ch !== 0; ) {
      if (ch === 58) {
        if (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following))
          break;
      } else if (ch === 35) {
        if (preceding = state.input.charCodeAt(state.position - 1), is_WS_OR_EOL(preceding))
          break;
      } else {
        if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch))
          break;
        if (is_EOL(ch))
          if (_line = state.line, _lineStart = state.lineStart, _lineIndent = state.lineIndent, skipSeparationSpace(state, !1, -1), state.lineIndent >= nodeIndent) {
            hasPendingContent = !0, ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd, state.line = _line, state.lineStart = _lineStart, state.lineIndent = _lineIndent;
            break;
          }
      }
      hasPendingContent && (captureSegment(state, captureStart, captureEnd, !1), writeFoldedLines(state, state.line - _line), captureStart = captureEnd = state.position, hasPendingContent = !1), is_WHITE_SPACE(ch) || (captureEnd = state.position + 1), ch = state.input.charCodeAt(++state.position);
    }
    return captureSegment(state, captureStart, captureEnd, !1), state.result ? !0 : (state.kind = _kind, state.result = _result, !1);
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    if (ch = state.input.charCodeAt(state.position), ch !== 39)
      return !1;
    for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; )
      if (ch === 39)
        if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), ch === 39)
          captureStart = state.position, state.position++, captureEnd = state.position;
        else
          return !0;
      else is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError2(state, "unexpected end of the document within a single quoted scalar") : (state.position++, captureEnd = state.position);
    throwError2(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp2, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 34)
      return !1;
    for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; ) {
      if (ch === 34)
        return captureSegment(state, captureStart, state.position, !0), state.position++, !0;
      if (ch === 92) {
        if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), is_EOL(ch))
          skipSeparationSpace(state, !1, nodeIndent);
        else if (ch < 256 && simpleEscapeCheck[ch])
          state.result += simpleEscapeMap[ch], state.position++;
        else if ((tmp2 = escapedHexLen(ch)) > 0) {
          for (hexLength = tmp2, hexResult = 0; hexLength > 0; hexLength--)
            ch = state.input.charCodeAt(++state.position), (tmp2 = fromHexCode(ch)) >= 0 ? hexResult = (hexResult << 4) + tmp2 : throwError2(state, "expected hexadecimal character");
          state.result += charFromCodepoint(hexResult), state.position++;
        } else
          throwError2(state, "unknown escape sequence");
        captureStart = captureEnd = state.position;
      } else is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError2(state, "unexpected end of the document within a double quoted scalar") : (state.position++, captureEnd = state.position);
    }
    throwError2(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = !0, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
    if (ch = state.input.charCodeAt(state.position), ch === 91)
      terminator = 93, isMapping = !1, _result = [];
    else if (ch === 123)
      terminator = 125, isMapping = !0, _result = {};
    else
      return !1;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(++state.position); ch !== 0; ) {
      if (skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === terminator)
        return state.position++, state.tag = _tag, state.anchor = _anchor, state.kind = isMapping ? "mapping" : "sequence", state.result = _result, !0;
      readNext ? ch === 44 && throwError2(state, "expected the node content, but found ','") : throwError2(state, "missed comma between flow collection entries"), keyTag = keyNode = valueNode = null, isPair = isExplicitPair = !1, ch === 63 && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) && (isPair = isExplicitPair = !0, state.position++, skipSeparationSpace(state, !0, nodeIndent))), _line = state.line, _lineStart = state.lineStart, _pos = state.position, composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), keyTag = state.tag, keyNode = state.result, skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), (isExplicitPair || state.line === _line) && ch === 58 && (isPair = !0, ch = state.input.charCodeAt(++state.position), skipSeparationSpace(state, !0, nodeIndent), composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), valueNode = state.result), isMapping ? storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos) : isPair ? _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos)) : _result.push(keyNode), skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === 44 ? (readNext = !0, ch = state.input.charCodeAt(++state.position)) : readNext = !1;
    }
    throwError2(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = !1, detectedIndent = !1, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = !1, tmp2, ch;
    if (ch = state.input.charCodeAt(state.position), ch === 124)
      folding = !1;
    else if (ch === 62)
      folding = !0;
    else
      return !1;
    for (state.kind = "scalar", state.result = ""; ch !== 0; )
      if (ch = state.input.charCodeAt(++state.position), ch === 43 || ch === 45)
        CHOMPING_CLIP === chomping ? chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP : throwError2(state, "repeat of a chomping mode identifier");
      else if ((tmp2 = fromDecimalCode(ch)) >= 0)
        tmp2 === 0 ? throwError2(state, "bad explicit indentation width of a block scalar; it cannot be less than one") : detectedIndent ? throwError2(state, "repeat of an indentation width identifier") : (textIndent = nodeIndent + tmp2 - 1, detectedIndent = !0);
      else
        break;
    if (is_WHITE_SPACE(ch)) {
      do
        ch = state.input.charCodeAt(++state.position);
      while (is_WHITE_SPACE(ch));
      if (ch === 35)
        do
          ch = state.input.charCodeAt(++state.position);
        while (!is_EOL(ch) && ch !== 0);
    }
    for (; ch !== 0; ) {
      for (readLineBreak(state), state.lineIndent = 0, ch = state.input.charCodeAt(state.position); (!detectedIndent || state.lineIndent < textIndent) && ch === 32; )
        state.lineIndent++, ch = state.input.charCodeAt(++state.position);
      if (!detectedIndent && state.lineIndent > textIndent && (textIndent = state.lineIndent), is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        chomping === CHOMPING_KEEP ? state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines) : chomping === CHOMPING_CLIP && didReadContent && (state.result += `
`);
        break;
      }
      for (folding ? is_WHITE_SPACE(ch) ? (atMoreIndented = !0, state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines)) : atMoreIndented ? (atMoreIndented = !1, state.result += common2.repeat(`
`, emptyLines + 1)) : emptyLines === 0 ? didReadContent && (state.result += " ") : state.result += common2.repeat(`
`, emptyLines) : state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines), didReadContent = !0, detectedIndent = !0, emptyLines = 0, captureStart = state.position; !is_EOL(ch) && ch !== 0; )
        ch = state.input.charCodeAt(++state.position);
      captureSegment(state, captureStart, state.position, !1);
    }
    return !0;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = !1, ch;
    if (state.firstTabInLine !== -1) return !1;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0 && (state.firstTabInLine !== -1 && (state.position = state.firstTabInLine, throwError2(state, "tab characters must not be used in indentation")), !(ch !== 45 || (following = state.input.charCodeAt(state.position + 1), !is_WS_OR_EOL(following)))); ) {
      if (detected = !0, state.position++, skipSeparationSpace(state, !0, -1) && state.lineIndent <= nodeIndent) {
        _result.push(null), ch = state.input.charCodeAt(state.position);
        continue;
      }
      if (_line = state.line, composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, !1, !0), _result.push(state.result), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), (state.line === _line || state.lineIndent > nodeIndent) && ch !== 0)
        throwError2(state, "bad indentation of a sequence entry");
      else if (state.lineIndent < nodeIndent)
        break;
    }
    return detected ? (state.tag = _tag, state.anchor = _anchor, state.kind = "sequence", state.result = _result, !0) : !1;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = !1, detected = !1, ch;
    if (state.firstTabInLine !== -1) return !1;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0; ) {
      if (!atExplicitKey && state.firstTabInLine !== -1 && (state.position = state.firstTabInLine, throwError2(state, "tab characters must not be used in indentation")), following = state.input.charCodeAt(state.position + 1), _line = state.line, (ch === 63 || ch === 58) && is_WS_OR_EOL(following))
        ch === 63 ? (atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !0, allowCompact = !0) : atExplicitKey ? (atExplicitKey = !1, allowCompact = !0) : throwError2(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), state.position += 1, ch = following;
      else {
        if (_keyLine = state.line, _keyLineStart = state.lineStart, _keyPos = state.position, !composeNode(state, flowIndent, CONTEXT_FLOW_OUT, !1, !0))
          break;
        if (state.line === _line) {
          for (ch = state.input.charCodeAt(state.position); is_WHITE_SPACE(ch); )
            ch = state.input.charCodeAt(++state.position);
          if (ch === 58)
            ch = state.input.charCodeAt(++state.position), is_WS_OR_EOL(ch) || throwError2(state, "a whitespace character is expected after the key-value separator within a block mapping"), atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !1, allowCompact = !1, keyTag = state.tag, keyNode = state.result;
          else if (detected)
            throwError2(state, "can not read an implicit mapping pair; a colon is missed");
          else
            return state.tag = _tag, state.anchor = _anchor, !0;
        } else if (detected)
          throwError2(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        else
          return state.tag = _tag, state.anchor = _anchor, !0;
      }
      if ((state.line === _line || state.lineIndent > nodeIndent) && (atExplicitKey && (_keyLine = state.line, _keyLineStart = state.lineStart, _keyPos = state.position), composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, !0, allowCompact) && (atExplicitKey ? keyNode = state.result : valueNode = state.result), atExplicitKey || (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos), keyTag = keyNode = valueNode = null), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position)), (state.line === _line || state.lineIndent > nodeIndent) && ch !== 0)
        throwError2(state, "bad indentation of a mapping entry");
      else if (state.lineIndent < nodeIndent)
        break;
    }
    return atExplicitKey && storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos), detected && (state.tag = _tag, state.anchor = _anchor, state.kind = "mapping", state.result = _result), detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = !1, isNamed = !1, tagHandle, tagName, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 33) return !1;
    if (state.tag !== null && throwError2(state, "duplication of a tag property"), ch = state.input.charCodeAt(++state.position), ch === 60 ? (isVerbatim = !0, ch = state.input.charCodeAt(++state.position)) : ch === 33 ? (isNamed = !0, tagHandle = "!!", ch = state.input.charCodeAt(++state.position)) : tagHandle = "!", _position = state.position, isVerbatim) {
      do
        ch = state.input.charCodeAt(++state.position);
      while (ch !== 0 && ch !== 62);
      state.position < state.length ? (tagName = state.input.slice(_position, state.position), ch = state.input.charCodeAt(++state.position)) : throwError2(state, "unexpected end of the stream within a verbatim tag");
    } else {
      for (; ch !== 0 && !is_WS_OR_EOL(ch); )
        ch === 33 && (isNamed ? throwError2(state, "tag suffix cannot contain exclamation marks") : (tagHandle = state.input.slice(_position - 1, state.position + 1), PATTERN_TAG_HANDLE.test(tagHandle) || throwError2(state, "named tag handle cannot contain such characters"), isNamed = !0, _position = state.position + 1)), ch = state.input.charCodeAt(++state.position);
      tagName = state.input.slice(_position, state.position), PATTERN_FLOW_INDICATORS.test(tagName) && throwError2(state, "tag suffix cannot contain flow indicator characters");
    }
    tagName && !PATTERN_TAG_URI.test(tagName) && throwError2(state, "tag name cannot contain such characters: " + tagName);
    try {
      tagName = decodeURIComponent(tagName);
    } catch {
      throwError2(state, "tag name is malformed: " + tagName);
    }
    return isVerbatim ? state.tag = tagName : _hasOwnProperty.call(state.tagMap, tagHandle) ? state.tag = state.tagMap[tagHandle] + tagName : tagHandle === "!" ? state.tag = "!" + tagName : tagHandle === "!!" ? state.tag = "tag:yaml.org,2002:" + tagName : throwError2(state, 'undeclared tag handle "' + tagHandle + '"'), !0;
  }
  function readAnchorProperty(state) {
    var _position, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 38) return !1;
    for (state.anchor !== null && throwError2(state, "duplication of an anchor property"), ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
      ch = state.input.charCodeAt(++state.position);
    return state.position === _position && throwError2(state, "name of an anchor node must contain at least one character"), state.anchor = state.input.slice(_position, state.position), !0;
  }
  function readAlias(state) {
    var _position, alias, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 42) return !1;
    for (ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
      ch = state.input.charCodeAt(++state.position);
    return state.position === _position && throwError2(state, "name of an alias node must contain at least one character"), alias = state.input.slice(_position, state.position), _hasOwnProperty.call(state.anchorMap, alias) || throwError2(state, 'unidentified alias "' + alias + '"'), state.result = state.anchorMap[alias], skipSeparationSpace(state, !0, -1), !0;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = !1, hasContent = !1, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
    if (state.listener !== null && state.listener("open", state), state.tag = null, state.anchor = null, state.kind = null, state.result = null, allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext, allowToSeek && skipSeparationSpace(state, !0, -1) && (atNewLine = !0, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)), indentStatus === 1)
      for (; readTagProperty(state) || readAnchorProperty(state); )
        skipSeparationSpace(state, !0, -1) ? (atNewLine = !0, allowBlockCollections = allowBlockStyles, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)) : allowBlockCollections = !1;
    if (allowBlockCollections && (allowBlockCollections = atNewLine || allowCompact), (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) && (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext ? flowIndent = parentIndent : flowIndent = parentIndent + 1, blockIndent = state.position - state.lineStart, indentStatus === 1 ? allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent) ? hasContent = !0 : (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent) ? hasContent = !0 : readAlias(state) ? (hasContent = !0, (state.tag !== null || state.anchor !== null) && throwError2(state, "alias node should not have any properties")) : readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext) && (hasContent = !0, state.tag === null && (state.tag = "?")), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : indentStatus === 0 && (hasContent = allowBlockCollections && readBlockSequence(state, blockIndent))), state.tag === null)
      state.anchor !== null && (state.anchorMap[state.anchor] = state.result);
    else if (state.tag === "?") {
      for (state.result !== null && state.kind !== "scalar" && throwError2(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"'), typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1)
        if (type2 = state.implicitTypes[typeIndex], type2.resolve(state.result)) {
          state.result = type2.construct(state.result), state.tag = type2.tag, state.anchor !== null && (state.anchorMap[state.anchor] = state.result);
          break;
        }
    } else if (state.tag !== "!") {
      if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag))
        type2 = state.typeMap[state.kind || "fallback"][state.tag];
      else
        for (type2 = null, typeList = state.typeMap.multi[state.kind || "fallback"], typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1)
          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type2 = typeList[typeIndex];
            break;
          }
      type2 || throwError2(state, "unknown tag !<" + state.tag + ">"), state.result !== null && type2.kind !== state.kind && throwError2(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"'), type2.resolve(state.result, state.tag) ? (state.result = type2.construct(state.result, state.tag), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : throwError2(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    }
    return state.listener !== null && state.listener("close", state), state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = !1, ch;
    for (state.version = null, state.checkLineBreaks = state.legacy, state.tagMap = /* @__PURE__ */ Object.create(null), state.anchorMap = /* @__PURE__ */ Object.create(null); (ch = state.input.charCodeAt(state.position)) !== 0 && (skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), !(state.lineIndent > 0 || ch !== 37)); ) {
      for (hasDirectives = !0, ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
        ch = state.input.charCodeAt(++state.position);
      for (directiveName = state.input.slice(_position, state.position), directiveArgs = [], directiveName.length < 1 && throwError2(state, "directive name must not be less than one character in length"); ch !== 0; ) {
        for (; is_WHITE_SPACE(ch); )
          ch = state.input.charCodeAt(++state.position);
        if (ch === 35) {
          do
            ch = state.input.charCodeAt(++state.position);
          while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch)) break;
        for (_position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
          ch = state.input.charCodeAt(++state.position);
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      ch !== 0 && readLineBreak(state), _hasOwnProperty.call(directiveHandlers, directiveName) ? directiveHandlers[directiveName](state, directiveName, directiveArgs) : throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
    if (skipSeparationSpace(state, !0, -1), state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45 ? (state.position += 3, skipSeparationSpace(state, !0, -1)) : hasDirectives && throwError2(state, "directives end mark is expected"), composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, !1, !0), skipSeparationSpace(state, !0, -1), state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position)) && throwWarning(state, "non-ASCII line breaks are interpreted as content"), state.documents.push(state.result), state.position === state.lineStart && testDocumentSeparator(state)) {
      state.input.charCodeAt(state.position) === 46 && (state.position += 3, skipSeparationSpace(state, !0, -1));
      return;
    }
    if (state.position < state.length - 1)
      throwError2(state, "end of the stream or a document separator is expected");
    else
      return;
  }
  function loadDocuments(input2, options2) {
    input2 = String(input2), options2 = options2 || {}, input2.length !== 0 && (input2.charCodeAt(input2.length - 1) !== 10 && input2.charCodeAt(input2.length - 1) !== 13 && (input2 += `
`), input2.charCodeAt(0) === 65279 && (input2 = input2.slice(1)));
    var state = new State(input2, options2), nullpos = input2.indexOf("\0");
    for (nullpos !== -1 && (state.position = nullpos, throwError2(state, "null byte is not allowed in input")), state.input += "\0"; state.input.charCodeAt(state.position) === 32; )
      state.lineIndent += 1, state.position += 1;
    for (; state.position < state.length - 1; )
      readDocument(state);
    return state.documents;
  }
  function loadAll(input2, iterator2, options2) {
    iterator2 !== null && typeof iterator2 == "object" && typeof options2 > "u" && (options2 = iterator2, iterator2 = null);
    var documents = loadDocuments(input2, options2);
    if (typeof iterator2 != "function")
      return documents;
    for (var index = 0, length = documents.length; index < length; index += 1)
      iterator2(documents[index]);
  }
  function load(input2, options2) {
    var documents = loadDocuments(input2, options2);
    if (documents.length !== 0) {
      if (documents.length === 1)
        return documents[0];
      throw new YAMLException("expected a single document in the stream, but found more");
    }
  }
  return loader$1.loadAll = loadAll, loader$1.load = load, loader$1;
}
var dumper$1 = {}, hasRequiredDumper$1;
function requireDumper$1() {
  if (hasRequiredDumper$1) return dumper$1;
  hasRequiredDumper$1 = 1;
  var common2 = requireCommon$2(), YAMLException = requireException$1(), DEFAULT_SCHEMA = require_default(), _toString = Object.prototype.toString, _hasOwnProperty = Object.prototype.hasOwnProperty, CHAR_BOM = 65279, CHAR_TAB = 9, CHAR_LINE_FEED = 10, CHAR_CARRIAGE_RETURN = 13, CHAR_SPACE = 32, CHAR_EXCLAMATION = 33, CHAR_DOUBLE_QUOTE = 34, CHAR_SHARP = 35, CHAR_PERCENT = 37, CHAR_AMPERSAND = 38, CHAR_SINGLE_QUOTE = 39, CHAR_ASTERISK = 42, CHAR_COMMA2 = 44, CHAR_MINUS = 45, CHAR_COLON2 = 58, CHAR_EQUALS2 = 61, CHAR_GREATER_THAN = 62, CHAR_QUESTION = 63, CHAR_COMMERCIAL_AT = 64, CHAR_LEFT_SQUARE_BRACKET = 91, CHAR_RIGHT_SQUARE_BRACKET = 93, CHAR_GRAVE_ACCENT = 96, CHAR_LEFT_CURLY_BRACKET = 123, CHAR_VERTICAL_LINE = 124, CHAR_RIGHT_CURLY_BRACKET = 125, ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0", ESCAPE_SEQUENCES[7] = "\\a", ESCAPE_SEQUENCES[8] = "\\b", ESCAPE_SEQUENCES[9] = "\\t", ESCAPE_SEQUENCES[10] = "\\n", ESCAPE_SEQUENCES[11] = "\\v", ESCAPE_SEQUENCES[12] = "\\f", ESCAPE_SEQUENCES[13] = "\\r", ESCAPE_SEQUENCES[27] = "\\e", ESCAPE_SEQUENCES[34] = '\\"', ESCAPE_SEQUENCES[92] = "\\\\", ESCAPE_SEQUENCES[133] = "\\N", ESCAPE_SEQUENCES[160] = "\\_", ESCAPE_SEQUENCES[8232] = "\\L", ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ], DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function compileStyleMap(schema2, map2) {
    var result, keys, index, length, tag, style, type2;
    if (map2 === null) return {};
    for (result = {}, keys = Object.keys(map2), index = 0, length = keys.length; index < length; index += 1)
      tag = keys[index], style = String(map2[tag]), tag.slice(0, 2) === "!!" && (tag = "tag:yaml.org,2002:" + tag.slice(2)), type2 = schema2.compiledTypeMap.fallback[tag], type2 && _hasOwnProperty.call(type2.styleAliases, style) && (style = type2.styleAliases[style]), result[tag] = style;
    return result;
  }
  function encodeHex(character) {
    var string, handle, length;
    if (string = character.toString(16).toUpperCase(), character <= 255)
      handle = "x", length = 2;
    else if (character <= 65535)
      handle = "u", length = 4;
    else if (character <= 4294967295)
      handle = "U", length = 8;
    else
      throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + handle + common2.repeat("0", length - string.length) + string;
  }
  var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
  function State(options2) {
    this.schema = options2.schema || DEFAULT_SCHEMA, this.indent = Math.max(1, options2.indent || 2), this.noArrayIndent = options2.noArrayIndent || !1, this.skipInvalid = options2.skipInvalid || !1, this.flowLevel = common2.isNothing(options2.flowLevel) ? -1 : options2.flowLevel, this.styleMap = compileStyleMap(this.schema, options2.styles || null), this.sortKeys = options2.sortKeys || !1, this.lineWidth = options2.lineWidth || 80, this.noRefs = options2.noRefs || !1, this.noCompatMode = options2.noCompatMode || !1, this.condenseFlow = options2.condenseFlow || !1, this.quotingType = options2.quotingType === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE, this.forceQuotes = options2.forceQuotes || !1, this.replacer = typeof options2.replacer == "function" ? options2.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
  }
  function indentString2(string, spaces) {
    for (var ind = common2.repeat(" ", spaces), position = 0, next = -1, result = "", line3, length = string.length; position < length; )
      next = string.indexOf(`
`, position), next === -1 ? (line3 = string.slice(position), position = length) : (line3 = string.slice(position, next + 1), position = next + 1), line3.length && line3 !== `
` && (result += ind), result += line3;
    return result;
  }
  function generateNextLine(state, level) {
    return `
` + common2.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str2) {
    var index, length, type2;
    for (index = 0, length = state.implicitTypes.length; index < length; index += 1)
      if (type2 = state.implicitTypes[index], type2.resolve(str2))
        return !0;
    return !1;
  }
  function isWhitespace(c2) {
    return c2 === CHAR_SPACE || c2 === CHAR_TAB;
  }
  function isPrintable(c2) {
    return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== CHAR_BOM || 65536 <= c2 && c2 <= 1114111;
  }
  function isNsCharOrWhitespace(c2) {
    return isPrintable(c2) && c2 !== CHAR_BOM && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c2, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c2), cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c2);
    return (
      // ns-plain-safe
      (inblock ? (
        // c = flow-in
        cIsNsCharOrWhitespace
      ) : cIsNsCharOrWhitespace && c2 !== CHAR_COMMA2 && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET) && c2 !== CHAR_SHARP && !(prev === CHAR_COLON2 && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c2 === CHAR_SHARP || prev === CHAR_COLON2 && cIsNsChar
    );
  }
  function isPlainSafeFirst(c2) {
    return isPrintable(c2) && c2 !== CHAR_BOM && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON2 && c2 !== CHAR_COMMA2 && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS2 && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
  }
  function isPlainSafeLast(c2) {
    return !isWhitespace(c2) && c2 !== CHAR_COLON2;
  }
  function codePointAt(string, pos2) {
    var first2 = string.charCodeAt(pos2), second;
    return first2 >= 55296 && first2 <= 56319 && pos2 + 1 < string.length && (second = string.charCodeAt(pos2 + 1), second >= 56320 && second <= 57343) ? (first2 - 55296) * 1024 + second - 56320 + 65536 : first2;
  }
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }
  var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
    var i, char = 0, prevChar = null, hasLineBreak = !1, hasFoldableLine = !1, shouldTrackWidth = lineWidth !== -1, previousLineBreak = -1, plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
    if (singleLineOnly || forceQuotes)
      for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
        if (char = codePointAt(string, i), !isPrintable(char))
          return STYLE_DOUBLE;
        plain = plain && isPlainSafe(char, prevChar, inblock), prevChar = char;
      }
    else {
      for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
        if (char = codePointAt(string, i), char === CHAR_LINE_FEED)
          hasLineBreak = !0, shouldTrackWidth && (hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ", previousLineBreak = i);
        else if (!isPrintable(char))
          return STYLE_DOUBLE;
        plain = plain && isPlainSafe(char, prevChar, inblock), prevChar = char;
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
    }
    return !hasLineBreak && !hasFoldableLine ? plain && !forceQuotes && !testAmbiguousType(string) ? STYLE_PLAIN : quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE : indentPerLevel > 9 && needIndentIndicator(string) ? STYLE_DOUBLE : forceQuotes ? quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE : hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  function writeScalar(state, string, level, iskey, inblock) {
    state.dump = function() {
      if (string.length === 0)
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
      if (!state.noCompatMode && (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)))
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      var indent = state.indent * Math.max(1, level), lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent), singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state, string2);
      }
      switch (chooseScalarStyle(
        string,
        singleLineOnly,
        state.indent,
        lineWidth,
        testAmbiguity,
        state.quotingType,
        state.forceQuotes && !iskey,
        inblock
      )) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString2(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString2(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';
        default:
          throw new YAMLException("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "", clip = string[string.length - 1] === `
`, keep = clip && (string[string.length - 2] === `
` || string === `
`), chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + `
`;
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === `
` ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    for (var lineRe = /(\n+)([^\n]*)/g, result = function() {
      var nextLF = string.indexOf(`
`);
      return nextLF = nextLF !== -1 ? nextLF : string.length, lineRe.lastIndex = nextLF, foldLine(string.slice(0, nextLF), width);
    }(), prevMoreIndented = string[0] === `
` || string[0] === " ", moreIndented, match2; match2 = lineRe.exec(string); ) {
      var prefix = match2[1], line3 = match2[2];
      moreIndented = line3[0] === " ", result += prefix + (!prevMoreIndented && !moreIndented && line3 !== "" ? `
` : "") + foldLine(line3, width), prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line3, width) {
    if (line3 === "" || line3[0] === " ") return line3;
    for (var breakRe = / [^ ]/g, match2, start = 0, end, curr = 0, next = 0, result = ""; match2 = breakRe.exec(line3); )
      next = match2.index, next - start > width && (end = curr > start ? curr : next, result += `
` + line3.slice(start, end), start = end + 1), curr = next;
    return result += `
`, line3.length - start > width && curr > start ? result += line3.slice(start, curr) + `
` + line3.slice(curr + 1) : result += line3.slice(start), result.slice(1);
  }
  function escapeString(string) {
    for (var result = "", char = 0, escapeSeq, i = 0; i < string.length; char >= 65536 ? i += 2 : i++)
      char = codePointAt(string, i), escapeSeq = ESCAPE_SEQUENCES[char], !escapeSeq && isPrintable(char) ? (result += string[i], char >= 65536 && (result += string[i + 1])) : result += escapeSeq || encodeHex(char);
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object.length; index < length; index += 1)
      value = object[index], state.replacer && (value = state.replacer.call(object, String(index), value)), (writeNode(state, level, value, !1, !1) || typeof value > "u" && writeNode(state, level, null, !1, !1)) && (_result !== "" && (_result += "," + (state.condenseFlow ? "" : " ")), _result += state.dump);
    state.tag = _tag, state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object.length; index < length; index += 1)
      value = object[index], state.replacer && (value = state.replacer.call(object, String(index), value)), (writeNode(state, level + 1, value, !0, !0, !1, !0) || typeof value > "u" && writeNode(state, level + 1, null, !0, !0, !1, !0)) && ((!compact || _result !== "") && (_result += generateNextLine(state, level)), state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? _result += "-" : _result += "- ", _result += state.dump);
    state.tag = _tag, state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length; index < length; index += 1)
      pairBuffer = "", _result !== "" && (pairBuffer += ", "), state.condenseFlow && (pairBuffer += '"'), objectKey = objectKeyList[index], objectValue = object[objectKey], state.replacer && (objectValue = state.replacer.call(object, objectKey, objectValue)), writeNode(state, level, objectKey, !1, !1) && (state.dump.length > 1024 && (pairBuffer += "? "), pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " "), writeNode(state, level, objectValue, !1, !1) && (pairBuffer += state.dump, _result += pairBuffer));
    state.tag = _tag, state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === !0)
      objectKeyList.sort();
    else if (typeof state.sortKeys == "function")
      objectKeyList.sort(state.sortKeys);
    else if (state.sortKeys)
      throw new YAMLException("sortKeys must be a boolean or a function");
    for (index = 0, length = objectKeyList.length; index < length; index += 1)
      pairBuffer = "", (!compact || _result !== "") && (pairBuffer += generateNextLine(state, level)), objectKey = objectKeyList[index], objectValue = object[objectKey], state.replacer && (objectValue = state.replacer.call(object, objectKey, objectValue)), writeNode(state, level + 1, objectKey, !0, !0, !0) && (explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024, explicitPair && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += "?" : pairBuffer += "? "), pairBuffer += state.dump, explicitPair && (pairBuffer += generateNextLine(state, level)), writeNode(state, level + 1, objectValue, !0, explicitPair) && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += ":" : pairBuffer += ": ", pairBuffer += state.dump, _result += pairBuffer));
    state.tag = _tag, state.dump = _result || "{}";
  }
  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type2, style;
    for (typeList = explicit ? state.explicitTypes : state.implicitTypes, index = 0, length = typeList.length; index < length; index += 1)
      if (type2 = typeList[index], (type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object == "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
        if (explicit ? type2.multi && type2.representName ? state.tag = type2.representName(object) : state.tag = type2.tag : state.tag = "?", type2.represent) {
          if (style = state.styleMap[type2.tag] || type2.defaultStyle, _toString.call(type2.represent) === "[object Function]")
            _result = type2.represent(object, style);
          else if (_hasOwnProperty.call(type2.represent, style))
            _result = type2.represent[style](object, style);
          else
            throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
          state.dump = _result;
        }
        return !0;
      }
    return !1;
  }
  function writeNode(state, level, object, block, compact, iskey, isblockseq) {
    state.tag = null, state.dump = object, detectType(state, object, !1) || detectType(state, object, !0);
    var type2 = _toString.call(state.dump), inblock = block, tagStr;
    block && (block = state.flowLevel < 0 || state.flowLevel > level);
    var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray && (duplicateIndex = state.duplicates.indexOf(object), duplicate = duplicateIndex !== -1), (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) && (compact = !1), duplicate && state.usedDuplicates[duplicateIndex])
      state.dump = "*ref_" + duplicateIndex;
    else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex] && (state.usedDuplicates[duplicateIndex] = !0), type2 === "[object Object]")
        block && Object.keys(state.dump).length !== 0 ? (writeBlockMapping(state, level, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowMapping(state, level, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
      else if (type2 === "[object Array]")
        block && state.dump.length !== 0 ? (state.noArrayIndent && !isblockseq && level > 0 ? writeBlockSequence(state, level - 1, state.dump, compact) : writeBlockSequence(state, level, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowSequence(state, level, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
      else if (type2 === "[object String]")
        state.tag !== "?" && writeScalar(state, state.dump, level, iskey, inblock);
      else {
        if (type2 === "[object Undefined]")
          return !1;
        if (state.skipInvalid) return !1;
        throw new YAMLException("unacceptable kind of an object to dump " + type2);
      }
      state.tag !== null && state.tag !== "?" && (tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21"), state.tag[0] === "!" ? tagStr = "!" + tagStr : tagStr.slice(0, 18) === "tag:yaml.org,2002:" ? tagStr = "!!" + tagStr.slice(18) : tagStr = "!<" + tagStr + ">", state.dump = tagStr + " " + state.dump);
    }
    return !0;
  }
  function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    for (inspectNode(object, objects, duplicatesIndexes), index = 0, length = duplicatesIndexes.length; index < length; index += 1)
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object == "object")
      if (index = objects.indexOf(object), index !== -1)
        duplicatesIndexes.indexOf(index) === -1 && duplicatesIndexes.push(index);
      else if (objects.push(object), Array.isArray(object))
        for (index = 0, length = object.length; index < length; index += 1)
          inspectNode(object[index], objects, duplicatesIndexes);
      else
        for (objectKeyList = Object.keys(object), index = 0, length = objectKeyList.length; index < length; index += 1)
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
  }
  function dump(input2, options2) {
    options2 = options2 || {};
    var state = new State(options2);
    state.noRefs || getDuplicateReferences(input2, state);
    var value = input2;
    return state.replacer && (value = state.replacer.call({ "": value }, "", value)), writeNode(state, 0, value, !0, !0) ? state.dump + `
` : "";
  }
  return dumper$1.dump = dump, dumper$1;
}
var hasRequiredJsYaml$2;
function requireJsYaml$2() {
  if (hasRequiredJsYaml$2) return jsYaml$2;
  hasRequiredJsYaml$2 = 1;
  var loader2 = requireLoader$1(), dumper2 = requireDumper$1();
  function renamed(from2, to) {
    return function() {
      throw new Error("Function yaml." + from2 + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
    };
  }
  return jsYaml$2.Type = requireType$1(), jsYaml$2.Schema = requireSchema$1(), jsYaml$2.FAILSAFE_SCHEMA = requireFailsafe$1(), jsYaml$2.JSON_SCHEMA = requireJson$1(), jsYaml$2.CORE_SCHEMA = requireCore$4(), jsYaml$2.DEFAULT_SCHEMA = require_default(), jsYaml$2.load = loader2.load, jsYaml$2.loadAll = loader2.loadAll, jsYaml$2.dump = dumper2.dump, jsYaml$2.YAMLException = requireException$1(), jsYaml$2.types = {
    binary: requireBinary$1(),
    float: requireFloat$1(),
    map: requireMap$1(),
    null: require_null$1(),
    pairs: requirePairs$1(),
    set: requireSet$1(),
    timestamp: requireTimestamp$1(),
    bool: requireBool$1(),
    int: requireInt$1(),
    merge: requireMerge$1(),
    omap: requireOmap$1(),
    seq: requireSeq$1(),
    str: requireStr$1()
  }, jsYaml$2.safeLoad = renamed("safeLoad", "load"), jsYaml$2.safeLoadAll = renamed("safeLoadAll", "loadAll"), jsYaml$2.safeDump = renamed("safeDump", "dump"), jsYaml$2;
}
var old = {}, hasRequiredOld;
function requireOld() {
  if (hasRequiredOld) return old;
  hasRequiredOld = 1;
  var pathModule = require$$0__default$1.default, isWindows = process.platform === "win32", fs2 = require$$0__default.default, DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
  function rethrow() {
    var callback;
    if (DEBUG) {
      var backtrace = new Error();
      callback = debugCallback;
    } else
      callback = missingCallback;
    return callback;
    function debugCallback(err) {
      err && (backtrace.message = err.message, err = backtrace, missingCallback(err));
    }
    function missingCallback(err) {
      if (err) {
        if (process.throwDeprecation)
          throw err;
        if (!process.noDeprecation) {
          var msg = "fs: missing callback " + (err.stack || err.message);
          process.traceDeprecation ? console.trace(msg) : console.error(msg);
        }
      }
    }
  }
  function maybeCallback(cb) {
    return typeof cb == "function" ? cb : rethrow();
  }
  if (isWindows)
    var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
  else
    var nextPartRe = /(.*?)(?:[\/]+|$)/g;
  if (isWindows)
    var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  else
    var splitRootRe = /^[\/]*/;
  return old.realpathSync = function(p, cache) {
    if (p = pathModule.resolve(p), cache && Object.prototype.hasOwnProperty.call(cache, p))
      return cache[p];
    var original = p, seenLinks = {}, knownHard = {}, pos2, current, base2, previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos2 = m[0].length, current = m[0], base2 = m[0], previous = "", isWindows && !knownHard[base2] && (fs2.lstatSync(base2), knownHard[base2] = !0);
    }
    for (; pos2 < p.length; ) {
      nextPartRe.lastIndex = pos2;
      var result = nextPartRe.exec(p);
      if (previous = current, current += result[0], base2 = previous + result[1], pos2 = nextPartRe.lastIndex, !(knownHard[base2] || cache && cache[base2] === base2)) {
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base2))
          resolvedLink = cache[base2];
        else {
          var stat2 = fs2.lstatSync(base2);
          if (!stat2.isSymbolicLink()) {
            knownHard[base2] = !0, cache && (cache[base2] = base2);
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
            seenLinks.hasOwnProperty(id) && (linkTarget = seenLinks[id]);
          }
          linkTarget === null && (fs2.statSync(base2), linkTarget = fs2.readlinkSync(base2)), resolvedLink = pathModule.resolve(previous, linkTarget), cache && (cache[base2] = resolvedLink), isWindows || (seenLinks[id] = linkTarget);
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos2)), start();
      }
    }
    return cache && (cache[original] = p), p;
  }, old.realpath = function(p, cache, cb) {
    if (typeof cb != "function" && (cb = maybeCallback(cache), cache = null), p = pathModule.resolve(p), cache && Object.prototype.hasOwnProperty.call(cache, p))
      return process.nextTick(cb.bind(null, null, cache[p]));
    var original = p, seenLinks = {}, knownHard = {}, pos2, current, base2, previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos2 = m[0].length, current = m[0], base2 = m[0], previous = "", isWindows && !knownHard[base2] ? fs2.lstat(base2, function(err) {
        if (err) return cb(err);
        knownHard[base2] = !0, LOOP();
      }) : process.nextTick(LOOP);
    }
    function LOOP() {
      if (pos2 >= p.length)
        return cache && (cache[original] = p), cb(null, p);
      nextPartRe.lastIndex = pos2;
      var result = nextPartRe.exec(p);
      return previous = current, current += result[0], base2 = previous + result[1], pos2 = nextPartRe.lastIndex, knownHard[base2] || cache && cache[base2] === base2 ? process.nextTick(LOOP) : cache && Object.prototype.hasOwnProperty.call(cache, base2) ? gotResolvedLink(cache[base2]) : fs2.lstat(base2, gotStat);
    }
    function gotStat(err, stat2) {
      if (err) return cb(err);
      if (!stat2.isSymbolicLink())
        return knownHard[base2] = !0, cache && (cache[base2] = base2), process.nextTick(LOOP);
      if (!isWindows) {
        var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
        if (seenLinks.hasOwnProperty(id))
          return gotTarget(null, seenLinks[id], base2);
      }
      fs2.stat(base2, function(err2) {
        if (err2) return cb(err2);
        fs2.readlink(base2, function(err3, target) {
          isWindows || (seenLinks[id] = target), gotTarget(err3, target);
        });
      });
    }
    function gotTarget(err, target, base3) {
      if (err) return cb(err);
      var resolvedLink = pathModule.resolve(previous, target);
      cache && (cache[base3] = resolvedLink), gotResolvedLink(resolvedLink);
    }
    function gotResolvedLink(resolvedLink) {
      p = pathModule.resolve(resolvedLink, p.slice(pos2)), start();
    }
  }, old;
}
var fs_realpath, hasRequiredFs_realpath;
function requireFs_realpath() {
  if (hasRequiredFs_realpath) return fs_realpath;
  hasRequiredFs_realpath = 1, fs_realpath = realpath, realpath.realpath = realpath, realpath.sync = realpathSync2, realpath.realpathSync = realpathSync2, realpath.monkeypatch = monkeypatch, realpath.unmonkeypatch = unmonkeypatch;
  var fs2 = require$$0__default.default, origRealpath = fs2.realpath, origRealpathSync = fs2.realpathSync, version2 = process.version, ok = /^v[0-5]\./.test(version2), old2 = requireOld();
  function newError(er) {
    return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
  }
  function realpath(p, cache, cb) {
    if (ok)
      return origRealpath(p, cache, cb);
    typeof cache == "function" && (cb = cache, cache = null), origRealpath(p, cache, function(er, result) {
      newError(er) ? old2.realpath(p, cache, cb) : cb(er, result);
    });
  }
  function realpathSync2(p, cache) {
    if (ok)
      return origRealpathSync(p, cache);
    try {
      return origRealpathSync(p, cache);
    } catch (er) {
      if (newError(er))
        return old2.realpathSync(p, cache);
      throw er;
    }
  }
  function monkeypatch() {
    fs2.realpath = realpath, fs2.realpathSync = realpathSync2;
  }
  function unmonkeypatch() {
    fs2.realpath = origRealpath, fs2.realpathSync = origRealpathSync;
  }
  return fs_realpath;
}
var path$2, hasRequiredPath$1;
function requirePath$1() {
  return hasRequiredPath$1 || (hasRequiredPath$1 = 1, path$2 = typeof process == "object" && process && process.platform === "win32" ? { sep: "\\" } : { sep: "/" }), path$2;
}
var braceExpansion, hasRequiredBraceExpansion;
function requireBraceExpansion() {
  if (hasRequiredBraceExpansion) return braceExpansion;
  hasRequiredBraceExpansion = 1;
  var balanced = requireBalancedMatch();
  braceExpansion = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0", escOpen = "\0OPEN" + Math.random() + "\0", escClose = "\0CLOSE" + Math.random() + "\0", escComma = "\0COMMA" + Math.random() + "\0", escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str2) {
    return parseInt(str2, 10) == str2 ? parseInt(str2, 10) : str2.charCodeAt(0);
  }
  function escapeBraces(str2) {
    return str2.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str2) {
    return str2.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str2) {
    if (!str2)
      return [""];
    var parts = [], m = balanced("{", "}", str2);
    if (!m)
      return str2.split(",");
    var pre = m.pre, body = m.body, post = m.post, p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    return post.length && (p[p.length - 1] += postParts.shift(), p.push.apply(p, postParts)), parts.push.apply(parts, p), parts;
  }
  function expandTop(str2) {
    return str2 ? (str2.substr(0, 2) === "{}" && (str2 = "\\{\\}" + str2.substr(2)), expand2(escapeBraces(str2), !0).map(unescapeBraces)) : [];
  }
  function embrace(str2) {
    return "{" + str2 + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand2(str2, isTop) {
    var expansions = [], m = balanced("{", "}", str2);
    if (!m) return [str2];
    var pre = m.pre, post = m.post.length ? expand2(m.post, !1) : [""];
    if (/\$$/.test(m.pre))
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + "{" + m.body + "}" + post[k];
        expansions.push(expansion);
      }
    else {
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body), isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body), isSequence = isNumericSequence || isAlphaSequence, isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions)
        return m.post.match(/,(?!,).*\}/) ? (str2 = m.pre + "{" + m.body + escClose + m.post, expand2(str2)) : [str2];
      var n;
      if (isSequence)
        n = m.body.split(/\.\./);
      else if (n = parseCommaParts(m.body), n.length === 1 && (n = expand2(n[0], !1).map(embrace), n.length === 1))
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      var N;
      if (isSequence) {
        var x = numeric(n[0]), y = numeric(n[1]), width = Math.max(n[0].length, n[1].length), incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1, test = lte, reverse = y < x;
        reverse && (incr *= -1, test = gte);
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c2;
          if (isAlphaSequence)
            c2 = String.fromCharCode(i), c2 === "\\" && (c2 = "");
          else if (c2 = String(i), pad) {
            var need = width - c2.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              i < 0 ? c2 = "-" + z + c2.slice(1) : c2 = z + c2;
            }
          }
          N.push(c2);
        }
      } else {
        N = [];
        for (var j = 0; j < n.length; j++)
          N.push.apply(N, expand2(n[j], !1));
      }
      for (var j = 0; j < N.length; j++)
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          (!isTop || isSequence || expansion) && expansions.push(expansion);
        }
    }
    return expansions;
  }
  return braceExpansion;
}
var minimatch_1, hasRequiredMinimatch;
function requireMinimatch() {
  if (hasRequiredMinimatch) return minimatch_1;
  hasRequiredMinimatch = 1;
  const minimatch2 = minimatch_1 = (p, pattern, options2 = {}) => (assertValidPattern2(pattern), !options2.nocomment && pattern.charAt(0) === "#" ? !1 : new Minimatch2(pattern, options2).match(p));
  minimatch_1 = minimatch2;
  const path2 = requirePath$1();
  minimatch2.sep = path2.sep;
  const GLOBSTAR2 = Symbol("globstar **");
  minimatch2.GLOBSTAR = GLOBSTAR2;
  const expand2 = requireBraceExpansion(), plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  }, qmark2 = "[^/]", star3 = qmark2 + "*?", twoStarDot2 = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", twoStarNoDot2 = "(?:(?!(?:\\/|^)\\.).)*?", charSet = (s) => s.split("").reduce((set2, c2) => (set2[c2] = !0, set2), {}), reSpecials2 = charSet("().*{}+?[]^$\\!"), addPatternStartSet = charSet("[.("), slashSplit = /\/+/;
  minimatch2.filter = (pattern, options2 = {}) => (p, i, list2) => minimatch2(p, pattern, options2);
  const ext2 = (a, b = {}) => {
    const t = {};
    return Object.keys(a).forEach((k) => t[k] = a[k]), Object.keys(b).forEach((k) => t[k] = b[k]), t;
  };
  minimatch2.defaults = (def) => {
    if (!def || typeof def != "object" || !Object.keys(def).length)
      return minimatch2;
    const orig = minimatch2, m = (p, pattern, options2) => orig(p, pattern, ext2(def, options2));
    return m.Minimatch = class extends orig.Minimatch {
      constructor(pattern, options2) {
        super(pattern, ext2(def, options2));
      }
    }, m.Minimatch.defaults = (options2) => orig.defaults(ext2(def, options2)).Minimatch, m.filter = (pattern, options2) => orig.filter(pattern, ext2(def, options2)), m.defaults = (options2) => orig.defaults(ext2(def, options2)), m.makeRe = (pattern, options2) => orig.makeRe(pattern, ext2(def, options2)), m.braceExpand = (pattern, options2) => orig.braceExpand(pattern, ext2(def, options2)), m.match = (list2, pattern, options2) => orig.match(list2, pattern, ext2(def, options2)), m;
  }, minimatch2.braceExpand = (pattern, options2) => braceExpand2(pattern, options2);
  const braceExpand2 = (pattern, options2 = {}) => (assertValidPattern2(pattern), options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern) ? [pattern] : expand2(pattern)), MAX_PATTERN_LENGTH2 = 1024 * 64, assertValidPattern2 = (pattern) => {
    if (typeof pattern != "string")
      throw new TypeError("invalid pattern");
    if (pattern.length > MAX_PATTERN_LENGTH2)
      throw new TypeError("pattern is too long");
  }, SUBPARSE = Symbol("subparse");
  minimatch2.makeRe = (pattern, options2) => new Minimatch2(pattern, options2 || {}).makeRe(), minimatch2.match = (list2, pattern, options2 = {}) => {
    const mm = new Minimatch2(pattern, options2);
    return list2 = list2.filter((f) => mm.match(f)), mm.options.nonull && !list2.length && list2.push(pattern), list2;
  };
  const globUnescape = (s) => s.replace(/\\(.)/g, "$1"), charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1"), regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
  class Minimatch2 {
    constructor(pattern, options2) {
      assertValidPattern2(pattern), options2 || (options2 = {}), this.options = options2, this.set = [], this.pattern = pattern, this.windowsPathsNoEscape = !!options2.windowsPathsNoEscape || options2.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.partial = !!options2.partial, this.make();
    }
    debug() {
    }
    make() {
      const pattern = this.pattern, options2 = this.options;
      if (!options2.nocomment && pattern.charAt(0) === "#") {
        this.comment = !0;
        return;
      }
      if (!pattern) {
        this.empty = !0;
        return;
      }
      this.parseNegate();
      let set2 = this.globSet = this.braceExpand();
      options2.debug && (this.debug = (...args) => console.error(...args)), this.debug(this.pattern, set2), set2 = this.globParts = set2.map((s) => s.split(slashSplit)), this.debug(this.pattern, set2), set2 = set2.map((s, si, set3) => s.map(this.parse, this)), this.debug(this.pattern, set2), set2 = set2.filter((s) => s.indexOf(!1) === -1), this.debug(this.pattern, set2), this.set = set2;
    }
    parseNegate() {
      if (this.options.nonegate) return;
      const pattern = this.pattern;
      let negate = !1, negateOffset = 0;
      for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++)
        negate = !negate, negateOffset++;
      negateOffset && (this.pattern = pattern.slice(negateOffset)), this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial) {
      var options2 = this.options;
      this.debug(
        "matchOne",
        { this: this, file, pattern }
      ), this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi], f = file[fi];
        if (this.debug(pattern, p, f), p === !1) return !1;
        if (p === GLOBSTAR2) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi, pr = pi + 1;
          if (pr === pl) {
            for (this.debug("** at the end"); fi < fl; fi++)
              if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".") return !1;
            return !0;
          }
          for (; fr < fl; ) {
            var swallowee = file[fr];
            if (this.debug(`
globstar while`, file, fr, pattern, pr, swallowee), this.matchOne(file.slice(fr), pattern.slice(pr), partial))
              return this.debug("globstar found match!", fr, fl, swallowee), !0;
            if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue"), fr++;
          }
          return !!(partial && (this.debug(`
>>> no match, partial?`, file, fr, pattern, pr), fr === fl));
        }
        var hit;
        if (typeof p == "string" ? (hit = f === p, this.debug("string match", p, f, hit)) : (hit = f.match(p), this.debug("pattern match", p, f, hit)), !hit) return !1;
      }
      if (fi === fl && pi === pl)
        return !0;
      if (fi === fl)
        return partial;
      if (pi === pl)
        return fi === fl - 1 && file[fi] === "";
      throw new Error("wtf?");
    }
    braceExpand() {
      return braceExpand2(this.pattern, this.options);
    }
    parse(pattern, isSub) {
      assertValidPattern2(pattern);
      const options2 = this.options;
      if (pattern === "**")
        if (options2.noglobstar)
          pattern = "*";
        else
          return GLOBSTAR2;
      if (pattern === "") return "";
      let re = "", hasMagic2 = !1, escaping = !1;
      const patternListStack = [], negativeLists = [];
      let stateChar, inClass = !1, reClassStart = -1, classStart = -1, cs, pl, sp, dotTravAllowed = pattern.charAt(0) === ".", dotFileAllowed = options2.dot || dotTravAllowed;
      const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", subPatternStart = (p) => p.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", clearStateChar = () => {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star3, hasMagic2 = !0;
              break;
            case "?":
              re += qmark2, hasMagic2 = !0;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          this.debug("clearStateChar %j %j", stateChar, re), stateChar = !1;
        }
      };
      for (let i = 0, c2; i < pattern.length && (c2 = pattern.charAt(i)); i++) {
        if (this.debug("%s	%s %s %j", pattern, i, re, c2), escaping) {
          if (c2 === "/")
            return !1;
          reSpecials2[c2] && (re += "\\"), re += c2, escaping = !1;
          continue;
        }
        switch (c2) {
          /* istanbul ignore next */
          case "/":
            return !1;
          case "\\":
            if (inClass && pattern.charAt(i + 1) === "-") {
              re += c2;
              continue;
            }
            clearStateChar(), escaping = !0;
            continue;
          // the various stateChar values
          // for the "extglob" stuff.
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            if (this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c2), inClass) {
              this.debug("  in class"), c2 === "!" && i === classStart + 1 && (c2 = "^"), re += c2;
              continue;
            }
            this.debug("call clearStateChar %j", stateChar), clearStateChar(), stateChar = c2, options2.noext && clearStateChar();
            continue;
          case "(": {
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            const plEntry = {
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            };
            this.debug(this.pattern, "	", plEntry), patternListStack.push(plEntry), re += plEntry.open, plEntry.start === 0 && plEntry.type !== "!" && (dotTravAllowed = !0, re += subPatternStart(pattern.slice(i + 1))), this.debug("plType %j %j", stateChar, re), stateChar = !1;
            continue;
          }
          case ")": {
            const plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re += "\\)";
              continue;
            }
            patternListStack.pop(), clearStateChar(), hasMagic2 = !0, pl = plEntry, re += pl.close, pl.type === "!" && negativeLists.push(Object.assign(pl, { reEnd: re.length }));
            continue;
          }
          case "|": {
            const plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re += "\\|";
              continue;
            }
            clearStateChar(), re += "|", plEntry.start === 0 && plEntry.type !== "!" && (dotTravAllowed = !0, re += subPatternStart(pattern.slice(i + 1)));
            continue;
          }
          // these are mostly the same in regexp and glob
          case "[":
            if (clearStateChar(), inClass) {
              re += "\\" + c2;
              continue;
            }
            inClass = !0, classStart = i, reClassStart = re.length, re += c2;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c2;
              continue;
            }
            cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + braExpEscape(charUnescape(cs)) + "]"), re += c2;
            } catch {
              re = re.substring(0, reClassStart) + "(?:$.)";
            }
            hasMagic2 = !0, inClass = !1;
            continue;
          default:
            clearStateChar(), reSpecials2[c2] && !(c2 === "^" && inClass) && (re += "\\"), re += c2;
            break;
        }
      }
      for (inClass && (cs = pattern.slice(classStart + 1), sp = this.parse(cs, SUBPARSE), re = re.substring(0, reClassStart) + "\\[" + sp[0], hasMagic2 = hasMagic2 || sp[1]), pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        let tail;
        tail = re.slice(pl.reStart + pl.open.length), this.debug("setting tail", re, pl), tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => ($2 || ($2 = "\\"), $1 + $1 + $2 + "|")), this.debug(`tail=%j
   %s`, tail, tail, pl, re);
        const t = pl.type === "*" ? star3 : pl.type === "?" ? qmark2 : "\\" + pl.type;
        hasMagic2 = !0, re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar(), escaping && (re += "\\\\");
      const addPatternStart2 = addPatternStartSet[re.charAt(0)];
      for (let n = negativeLists.length - 1; n > -1; n--) {
        const nl = negativeLists[n], nlBefore = re.slice(0, nl.reStart), nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        let nlAfter = re.slice(nl.reEnd);
        const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter, closeParensBefore = nlBefore.split(")").length, openParensBefore = nlBefore.split("(").length - closeParensBefore;
        let cleanAfter = nlAfter;
        for (let i = 0; i < openParensBefore; i++)
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        nlAfter = cleanAfter;
        const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
        re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      }
      if (re !== "" && hasMagic2 && (re = "(?=.)" + re), addPatternStart2 && (re = patternStart() + re), isSub === SUBPARSE)
        return [re, hasMagic2];
      if (options2.nocase && !hasMagic2 && (hasMagic2 = pattern.toUpperCase() !== pattern.toLowerCase()), !hasMagic2)
        return globUnescape(pattern);
      const flags = options2.nocase ? "i" : "";
      try {
        return Object.assign(new RegExp("^" + re + "$", flags), {
          _glob: pattern,
          _src: re
        });
      } catch {
        return new RegExp("$.");
      }
    }
    makeRe() {
      if (this.regexp || this.regexp === !1) return this.regexp;
      const set2 = this.set;
      if (!set2.length)
        return this.regexp = !1, this.regexp;
      const options2 = this.options, twoStar = options2.noglobstar ? star3 : options2.dot ? twoStarDot2 : twoStarNoDot2, flags = options2.nocase ? "i" : "";
      let re = set2.map((pattern) => (pattern = pattern.map(
        (p) => typeof p == "string" ? regExpEscape2(p) : p === GLOBSTAR2 ? GLOBSTAR2 : p._src
      ).reduce((set3, p) => (set3[set3.length - 1] === GLOBSTAR2 && p === GLOBSTAR2 || set3.push(p), set3), []), pattern.forEach((p, i) => {
        p !== GLOBSTAR2 || pattern[i - 1] === GLOBSTAR2 || (i === 0 ? pattern.length > 1 ? pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1] : pattern[i] = twoStar : i === pattern.length - 1 ? pattern[i - 1] += "(?:\\/|" + twoStar + ")?" : (pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1], pattern[i + 1] = GLOBSTAR2));
      }), pattern.filter((p) => p !== GLOBSTAR2).join("/"))).join("|");
      re = "^(?:" + re + ")$", this.negate && (re = "^(?!" + re + ").*$");
      try {
        this.regexp = new RegExp(re, flags);
      } catch {
        this.regexp = !1;
      }
      return this.regexp;
    }
    match(f, partial = this.partial) {
      if (this.debug("match", f, this.pattern), this.comment) return !1;
      if (this.empty) return f === "";
      if (f === "/" && partial) return !0;
      const options2 = this.options;
      path2.sep !== "/" && (f = f.split(path2.sep).join("/")), f = f.split(slashSplit), this.debug(this.pattern, "split", f);
      const set2 = this.set;
      this.debug(this.pattern, "set", set2);
      let filename;
      for (let i = f.length - 1; i >= 0 && (filename = f[i], !filename); i--)
        ;
      for (let i = 0; i < set2.length; i++) {
        const pattern = set2[i];
        let file = f;
        if (options2.matchBase && pattern.length === 1 && (file = [filename]), this.matchOne(file, pattern, partial))
          return options2.flipNegate ? !0 : !this.negate;
      }
      return options2.flipNegate ? !1 : this.negate;
    }
    static defaults(def) {
      return minimatch2.defaults(def).Minimatch;
    }
  }
  return minimatch2.Minimatch = Minimatch2, minimatch_1;
}
var inherits = { exports: {} }, inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(ctor, superCtor) {
    superCtor && (ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser.exports = function(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
    }
  }), inherits_browser.exports;
}
var hasRequiredInherits;
function requireInherits() {
  if (hasRequiredInherits) return inherits.exports;
  hasRequiredInherits = 1;
  try {
    var util2 = require("util");
    if (typeof util2.inherits != "function") throw "";
    inherits.exports = util2.inherits;
  } catch {
    inherits.exports = requireInherits_browser();
  }
  return inherits.exports;
}
var common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1, common$1.setopts = setopts, common$1.ownProp = ownProp, common$1.makeAbs = makeAbs, common$1.finish = finish, common$1.mark = mark2, common$1.isIgnored = isIgnored, common$1.childrenIgnored = childrenIgnored;
  function ownProp(obj, field) {
    return Object.prototype.hasOwnProperty.call(obj, field);
  }
  var fs2 = require$$0__default.default, path2 = require$$0__default$1.default, minimatch2 = requireMinimatch(), isAbsolute = require$$0__default$1.default.isAbsolute, Minimatch2 = minimatch2.Minimatch;
  function alphasort(a, b) {
    return a.localeCompare(b, "en");
  }
  function setupIgnores(self2, options2) {
    self2.ignore = options2.ignore || [], Array.isArray(self2.ignore) || (self2.ignore = [self2.ignore]), self2.ignore.length && (self2.ignore = self2.ignore.map(ignoreMap));
  }
  function ignoreMap(pattern) {
    var gmatcher = null;
    if (pattern.slice(-3) === "/**") {
      var gpattern = pattern.replace(/(\/\*\*)+$/, "");
      gmatcher = new Minimatch2(gpattern, { dot: !0 });
    }
    return {
      matcher: new Minimatch2(pattern, { dot: !0 }),
      gmatcher
    };
  }
  function setopts(self2, pattern, options2) {
    if (options2 || (options2 = {}), options2.matchBase && pattern.indexOf("/") === -1) {
      if (options2.noglobstar)
        throw new Error("base matching requires globstar");
      pattern = "**/" + pattern;
    }
    self2.silent = !!options2.silent, self2.pattern = pattern, self2.strict = options2.strict !== !1, self2.realpath = !!options2.realpath, self2.realpathCache = options2.realpathCache || /* @__PURE__ */ Object.create(null), self2.follow = !!options2.follow, self2.dot = !!options2.dot, self2.mark = !!options2.mark, self2.nodir = !!options2.nodir, self2.nodir && (self2.mark = !0), self2.sync = !!options2.sync, self2.nounique = !!options2.nounique, self2.nonull = !!options2.nonull, self2.nosort = !!options2.nosort, self2.nocase = !!options2.nocase, self2.stat = !!options2.stat, self2.noprocess = !!options2.noprocess, self2.absolute = !!options2.absolute, self2.fs = options2.fs || fs2, self2.maxLength = options2.maxLength || 1 / 0, self2.cache = options2.cache || /* @__PURE__ */ Object.create(null), self2.statCache = options2.statCache || /* @__PURE__ */ Object.create(null), self2.symlinks = options2.symlinks || /* @__PURE__ */ Object.create(null), setupIgnores(self2, options2), self2.changedCwd = !1;
    var cwd = process.cwd();
    ownProp(options2, "cwd") ? (self2.cwd = path2.resolve(options2.cwd), self2.changedCwd = self2.cwd !== cwd) : self2.cwd = path2.resolve(cwd), self2.root = options2.root || path2.resolve(self2.cwd, "/"), self2.root = path2.resolve(self2.root), self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd), self2.nomount = !!options2.nomount, process.platform === "win32" && (self2.root = self2.root.replace(/\\/g, "/"), self2.cwd = self2.cwd.replace(/\\/g, "/"), self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/")), options2.nonegate = !0, options2.nocomment = !0, options2.allowWindowsEscape = !0, self2.minimatch = new Minimatch2(pattern, options2), self2.options = self2.minimatch.options;
  }
  function finish(self2) {
    for (var nou = self2.nounique, all = nou ? [] : /* @__PURE__ */ Object.create(null), i = 0, l = self2.matches.length; i < l; i++) {
      var matches = self2.matches[i];
      if (!matches || Object.keys(matches).length === 0) {
        if (self2.nonull) {
          var literal2 = self2.minimatch.globSet[i];
          nou ? all.push(literal2) : all[literal2] = !0;
        }
      } else {
        var m = Object.keys(matches);
        nou ? all.push.apply(all, m) : m.forEach(function(m2) {
          all[m2] = !0;
        });
      }
    }
    if (nou || (all = Object.keys(all)), self2.nosort || (all = all.sort(alphasort)), self2.mark) {
      for (var i = 0; i < all.length; i++)
        all[i] = self2._mark(all[i]);
      self2.nodir && (all = all.filter(function(e) {
        var notDir = !/\/$/.test(e), c2 = self2.cache[e] || self2.cache[makeAbs(self2, e)];
        return notDir && c2 && (notDir = c2 !== "DIR" && !Array.isArray(c2)), notDir;
      }));
    }
    self2.ignore.length && (all = all.filter(function(m2) {
      return !isIgnored(self2, m2);
    })), self2.found = all;
  }
  function mark2(self2, p) {
    var abs = makeAbs(self2, p), c2 = self2.cache[abs], m = p;
    if (c2) {
      var isDir2 = c2 === "DIR" || Array.isArray(c2), slash = p.slice(-1) === "/";
      if (isDir2 && !slash ? m += "/" : !isDir2 && slash && (m = m.slice(0, -1)), m !== p) {
        var mabs = makeAbs(self2, m);
        self2.statCache[mabs] = self2.statCache[abs], self2.cache[mabs] = self2.cache[abs];
      }
    }
    return m;
  }
  function makeAbs(self2, f) {
    var abs = f;
    return f.charAt(0) === "/" ? abs = path2.join(self2.root, f) : isAbsolute(f) || f === "" ? abs = f : self2.changedCwd ? abs = path2.resolve(self2.cwd, f) : abs = path2.resolve(f), process.platform === "win32" && (abs = abs.replace(/\\/g, "/")), abs;
  }
  function isIgnored(self2, path3) {
    return self2.ignore.length ? self2.ignore.some(function(item) {
      return item.matcher.match(path3) || !!(item.gmatcher && item.gmatcher.match(path3));
    }) : !1;
  }
  function childrenIgnored(self2, path3) {
    return self2.ignore.length ? self2.ignore.some(function(item) {
      return !!(item.gmatcher && item.gmatcher.match(path3));
    }) : !1;
  }
  return common$1;
}
var sync$1, hasRequiredSync;
function requireSync() {
  if (hasRequiredSync) return sync$1;
  hasRequiredSync = 1, sync$1 = globSync2, globSync2.GlobSync = GlobSync;
  var rp = requireFs_realpath(), minimatch2 = requireMinimatch();
  requireGlob().Glob;
  var path2 = require$$0__default$1.default, assert = require$$0__default$6.default, isAbsolute = require$$0__default$1.default.isAbsolute, common2 = requireCommon$1(), setopts = common2.setopts, ownProp = common2.ownProp, childrenIgnored = common2.childrenIgnored, isIgnored = common2.isIgnored;
  function globSync2(pattern, options2) {
    if (typeof options2 == "function" || arguments.length === 3)
      throw new TypeError(`callback provided to sync glob
See: https://github.com/isaacs/node-glob/issues/167`);
    return new GlobSync(pattern, options2).found;
  }
  function GlobSync(pattern, options2) {
    if (!pattern)
      throw new Error("must provide pattern");
    if (typeof options2 == "function" || arguments.length === 3)
      throw new TypeError(`callback provided to sync glob
See: https://github.com/isaacs/node-glob/issues/167`);
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern, options2);
    if (setopts(this, pattern, options2), this.noprocess)
      return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for (var i = 0; i < n; i++)
      this._process(this.minimatch.set[i], i, !1);
    this._finish();
  }
  return GlobSync.prototype._finish = function() {
    if (assert.ok(this instanceof GlobSync), this.realpath) {
      var self2 = this;
      this.matches.forEach(function(matchset, index) {
        var set2 = self2.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var p in matchset)
          try {
            p = self2._makeAbs(p);
            var real = rp.realpathSync(p, self2.realpathCache);
            set2[real] = !0;
          } catch (er) {
            if (er.syscall === "stat")
              set2[self2._makeAbs(p)] = !0;
            else
              throw er;
          }
      });
    }
    common2.finish(this);
  }, GlobSync.prototype._process = function(pattern, index, inGlobStar) {
    assert.ok(this instanceof GlobSync);
    for (var n = 0; typeof pattern[n] == "string"; )
      n++;
    var prefix;
    switch (n) {
      // if not, then this is rather simple
      case pattern.length:
        this._processSimple(pattern.join("/"), index);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n), read2;
    prefix === null ? read2 = "." : ((isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
      return typeof p == "string" ? p : "[*]";
    }).join("/"))) && (!prefix || !isAbsolute(prefix)) && (prefix = "/" + prefix), read2 = prefix);
    var abs = this._makeAbs(read2);
    if (!childrenIgnored(this, read2)) {
      var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
      isGlobStar ? this._processGlobStar(prefix, read2, abs, remain, index, inGlobStar) : this._processReaddir(prefix, read2, abs, remain, index, inGlobStar);
    }
  }, GlobSync.prototype._processReaddir = function(prefix, read2, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (entries) {
      for (var pn = remain[0], negate = !!this.minimatch.negate, rawGlob = pn._glob, dotOk = this.dot || rawGlob.charAt(0) === ".", matchedEntries = [], i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          negate && !prefix ? m = !e.match(pn) : m = e.match(pn), m && matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len !== 0) {
        if (remain.length === 1 && !this.mark && !this.stat) {
          this.matches[index] || (this.matches[index] = /* @__PURE__ */ Object.create(null));
          for (var i = 0; i < len; i++) {
            var e = matchedEntries[i];
            prefix && (prefix.slice(-1) !== "/" ? e = prefix + "/" + e : e = prefix + e), e.charAt(0) === "/" && !this.nomount && (e = path2.join(this.root, e)), this._emitMatch(index, e);
          }
          return;
        }
        remain.shift();
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i], newPattern;
          prefix ? newPattern = [prefix, e] : newPattern = [e], this._process(newPattern.concat(remain), index, inGlobStar);
        }
      }
    }
  }, GlobSync.prototype._emitMatch = function(index, e) {
    if (!isIgnored(this, e)) {
      var abs = this._makeAbs(e);
      if (this.mark && (e = this._mark(e)), this.absolute && (e = abs), !this.matches[index][e]) {
        if (this.nodir) {
          var c2 = this.cache[abs];
          if (c2 === "DIR" || Array.isArray(c2))
            return;
        }
        this.matches[index][e] = !0, this.stat && this._stat(e);
      }
    }
  }, GlobSync.prototype._readdirInGlobStar = function(abs) {
    if (this.follow)
      return this._readdir(abs, !1);
    var entries, lstat2;
    try {
      lstat2 = this.fs.lstatSync(abs);
    } catch (er) {
      if (er.code === "ENOENT")
        return null;
    }
    var isSym = lstat2 && lstat2.isSymbolicLink();
    return this.symlinks[abs] = isSym, !isSym && lstat2 && !lstat2.isDirectory() ? this.cache[abs] = "FILE" : entries = this._readdir(abs, !1), entries;
  }, GlobSync.prototype._readdir = function(abs, inGlobStar) {
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs);
    if (ownProp(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (!c2 || c2 === "FILE")
        return null;
      if (Array.isArray(c2))
        return c2;
    }
    try {
      return this._readdirEntries(abs, this.fs.readdirSync(abs));
    } catch (er) {
      return this._readdirError(abs, er), null;
    }
  }, GlobSync.prototype._readdirEntries = function(abs, entries) {
    if (!this.mark && !this.stat)
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        abs === "/" ? e = abs + e : e = abs + "/" + e, this.cache[e] = !0;
      }
    return this.cache[abs] = entries, entries;
  }, GlobSync.prototype._readdirError = function(f, er) {
    switch (er.code) {
      case "ENOTSUP":
      // https://github.com/isaacs/node-glob/issues/205
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        if (this.cache[abs] = "FILE", abs === this.cwdAbs) {
          var error2 = new Error(er.code + " invalid cwd " + this.cwd);
          throw error2.path = this.cwd, error2.code = er.code, error2;
        }
        break;
      case "ENOENT":
      // not terribly unusual
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = !1;
        break;
      default:
        if (this.cache[this._makeAbs(f)] = !1, this.strict)
          throw er;
        this.silent || console.error("glob error", er);
        break;
    }
  }, GlobSync.prototype._processGlobStar = function(prefix, read2, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (entries) {
      var remainWithoutGlobStar = remain.slice(1), gspref = prefix ? [prefix] : [], noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, !1);
      var len = entries.length, isSym = this.symlinks[abs];
      if (!(isSym && inGlobStar))
        for (var i = 0; i < len; i++) {
          var e = entries[i];
          if (!(e.charAt(0) === "." && !this.dot)) {
            var instead = gspref.concat(entries[i], remainWithoutGlobStar);
            this._process(instead, index, !0);
            var below = gspref.concat(entries[i], remain);
            this._process(below, index, !0);
          }
        }
    }
  }, GlobSync.prototype._processSimple = function(prefix, index) {
    var exists = this._stat(prefix);
    if (this.matches[index] || (this.matches[index] = /* @__PURE__ */ Object.create(null)), !!exists) {
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        prefix.charAt(0) === "/" ? prefix = path2.join(this.root, prefix) : (prefix = path2.resolve(this.root, prefix), trail && (prefix += "/"));
      }
      process.platform === "win32" && (prefix = prefix.replace(/\\/g, "/")), this._emitMatch(index, prefix);
    }
  }, GlobSync.prototype._stat = function(f) {
    var abs = this._makeAbs(f), needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return !1;
    if (!this.stat && ownProp(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (Array.isArray(c2) && (c2 = "DIR"), !needDir || c2 === "DIR")
        return c2;
      if (needDir && c2 === "FILE")
        return !1;
    }
    var stat2 = this.statCache[abs];
    if (!stat2) {
      var lstat2;
      try {
        lstat2 = this.fs.lstatSync(abs);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR"))
          return this.statCache[abs] = !1, !1;
      }
      if (lstat2 && lstat2.isSymbolicLink())
        try {
          stat2 = this.fs.statSync(abs);
        } catch {
          stat2 = lstat2;
        }
      else
        stat2 = lstat2;
    }
    this.statCache[abs] = stat2;
    var c2 = !0;
    return stat2 && (c2 = stat2.isDirectory() ? "DIR" : "FILE"), this.cache[abs] = this.cache[abs] || c2, needDir && c2 === "FILE" ? !1 : c2;
  }, GlobSync.prototype._mark = function(p) {
    return common2.mark(this, p);
  }, GlobSync.prototype._makeAbs = function(f) {
    return common2.makeAbs(this, f);
  }, sync$1;
}
var wrappy_1, hasRequiredWrappy;
function requireWrappy() {
  if (hasRequiredWrappy) return wrappy_1;
  hasRequiredWrappy = 1, wrappy_1 = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb) return wrappy(fn)(cb);
    if (typeof fn != "function")
      throw new TypeError("need wrapper function");
    return Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    }), wrapper;
    function wrapper() {
      for (var args = new Array(arguments.length), i = 0; i < args.length; i++)
        args[i] = arguments[i];
      var ret = fn.apply(this, args), cb2 = args[args.length - 1];
      return typeof ret == "function" && ret !== cb2 && Object.keys(cb2).forEach(function(k) {
        ret[k] = cb2[k];
      }), ret;
    }
  }
  return wrappy_1;
}
var once = { exports: {} }, hasRequiredOnce;
function requireOnce() {
  if (hasRequiredOnce) return once.exports;
  hasRequiredOnce = 1;
  var wrappy = requireWrappy();
  once.exports = wrappy(once$1), once.exports.strict = wrappy(onceStrict), once$1.proto = once$1(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once$1(this);
      },
      configurable: !0
    }), Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: !0
    });
  });
  function once$1(fn) {
    var f = function() {
      return f.called ? f.value : (f.called = !0, f.value = fn.apply(this, arguments));
    };
    return f.called = !1, f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      return f.called = !0, f.value = fn.apply(this, arguments);
    }, name = fn.name || "Function wrapped with `once`";
    return f.onceError = name + " shouldn't be called more than once", f.called = !1, f;
  }
  return once.exports;
}
var inflight_1, hasRequiredInflight;
function requireInflight() {
  if (hasRequiredInflight) return inflight_1;
  hasRequiredInflight = 1;
  var wrappy = requireWrappy(), reqs = /* @__PURE__ */ Object.create(null), once2 = requireOnce();
  inflight_1 = wrappy(inflight);
  function inflight(key2, cb) {
    return reqs[key2] ? (reqs[key2].push(cb), null) : (reqs[key2] = [cb], makeres(key2));
  }
  function makeres(key2) {
    return once2(function RES() {
      var cbs = reqs[key2], len = cbs.length, args = slice(arguments);
      try {
        for (var i = 0; i < len; i++)
          cbs[i].apply(null, args);
      } finally {
        cbs.length > len ? (cbs.splice(0, len), process.nextTick(function() {
          RES.apply(null, args);
        })) : delete reqs[key2];
      }
    });
  }
  function slice(args) {
    for (var length = args.length, array = [], i = 0; i < length; i++) array[i] = args[i];
    return array;
  }
  return inflight_1;
}
var glob_1, hasRequiredGlob;
function requireGlob() {
  if (hasRequiredGlob) return glob_1;
  hasRequiredGlob = 1, glob_1 = glob2;
  var rp = requireFs_realpath(), minimatch2 = requireMinimatch(), inherits2 = requireInherits(), EE = require$$0__default$7.default.EventEmitter, path2 = require$$0__default$1.default, assert = require$$0__default$6.default, isAbsolute = require$$0__default$1.default.isAbsolute, globSync2 = requireSync(), common2 = requireCommon$1(), setopts = common2.setopts, ownProp = common2.ownProp, inflight = requireInflight(), childrenIgnored = common2.childrenIgnored, isIgnored = common2.isIgnored, once2 = requireOnce();
  function glob2(pattern, options2, cb) {
    if (typeof options2 == "function" && (cb = options2, options2 = {}), options2 || (options2 = {}), options2.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync2(pattern, options2);
    }
    return new Glob2(pattern, options2, cb);
  }
  glob2.sync = globSync2;
  var GlobSync = glob2.GlobSync = globSync2.GlobSync;
  glob2.glob = glob2;
  function extend(origin, add) {
    if (add === null || typeof add != "object")
      return origin;
    for (var keys = Object.keys(add), i = keys.length; i--; )
      origin[keys[i]] = add[keys[i]];
    return origin;
  }
  glob2.hasMagic = function(pattern, options_) {
    var options2 = extend({}, options_);
    options2.noprocess = !0;
    var g = new Glob2(pattern, options2), set2 = g.minimatch.set;
    if (!pattern)
      return !1;
    if (set2.length > 1)
      return !0;
    for (var j = 0; j < set2[0].length; j++)
      if (typeof set2[0][j] != "string")
        return !0;
    return !1;
  }, glob2.Glob = Glob2, inherits2(Glob2, EE);
  function Glob2(pattern, options2, cb) {
    if (typeof options2 == "function" && (cb = options2, options2 = null), options2 && options2.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern, options2);
    }
    if (!(this instanceof Glob2))
      return new Glob2(pattern, options2, cb);
    setopts(this, pattern, options2), this._didRealPath = !1;
    var n = this.minimatch.set.length;
    this.matches = new Array(n), typeof cb == "function" && (cb = once2(cb), this.on("error", cb), this.on("end", function(matches) {
      cb(null, matches);
    }));
    var self2 = this;
    if (this._processing = 0, this._emitQueue = [], this._processQueue = [], this.paused = !1, this.noprocess)
      return this;
    if (n === 0)
      return done();
    for (var sync2 = !0, i = 0; i < n; i++)
      this._process(this.minimatch.set[i], i, !1, done);
    sync2 = !1;
    function done() {
      --self2._processing, self2._processing <= 0 && (sync2 ? process.nextTick(function() {
        self2._finish();
      }) : self2._finish());
    }
  }
  Glob2.prototype._finish = function() {
    if (assert(this instanceof Glob2), !this.aborted) {
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common2.finish(this), this.emit("end", this.found);
    }
  }, Glob2.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = !0;
    var n = this.matches.length;
    if (n === 0)
      return this._finish();
    for (var self2 = this, i = 0; i < this.matches.length; i++)
      this._realpathSet(i, next);
    function next() {
      --n === 0 && self2._finish();
    }
  }, Glob2.prototype._realpathSet = function(index, cb) {
    var matchset = this.matches[index];
    if (!matchset)
      return cb();
    var found = Object.keys(matchset), self2 = this, n = found.length;
    if (n === 0)
      return cb();
    var set2 = this.matches[index] = /* @__PURE__ */ Object.create(null);
    found.forEach(function(p, i) {
      p = self2._makeAbs(p), rp.realpath(p, self2.realpathCache, function(er, real) {
        er ? er.syscall === "stat" ? set2[p] = !0 : self2.emit("error", er) : set2[real] = !0, --n === 0 && (self2.matches[index] = set2, cb());
      });
    });
  }, Glob2.prototype._mark = function(p) {
    return common2.mark(this, p);
  }, Glob2.prototype._makeAbs = function(f) {
    return common2.makeAbs(this, f);
  }, Glob2.prototype.abort = function() {
    this.aborted = !0, this.emit("abort");
  }, Glob2.prototype.pause = function() {
    this.paused || (this.paused = !0, this.emit("pause"));
  }, Glob2.prototype.resume = function() {
    if (this.paused) {
      if (this.emit("resume"), this.paused = !1, this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i = 0; i < eq.length; i++) {
          var e = eq[i];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i = 0; i < pq.length; i++) {
          var p = pq[i];
          this._processing--, this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  }, Glob2.prototype._process = function(pattern, index, inGlobStar, cb) {
    if (assert(this instanceof Glob2), assert(typeof cb == "function"), !this.aborted) {
      if (this._processing++, this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      for (var n = 0; typeof pattern[n] == "string"; )
        n++;
      var prefix;
      switch (n) {
        // if not, then this is rather simple
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n), read2;
      prefix === null ? read2 = "." : ((isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p == "string" ? p : "[*]";
      }).join("/"))) && (!prefix || !isAbsolute(prefix)) && (prefix = "/" + prefix), read2 = prefix);
      var abs = this._makeAbs(read2);
      if (childrenIgnored(this, read2))
        return cb();
      var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
      isGlobStar ? this._processGlobStar(prefix, read2, abs, remain, index, inGlobStar, cb) : this._processReaddir(prefix, read2, abs, remain, index, inGlobStar, cb);
    }
  }, Glob2.prototype._processReaddir = function(prefix, read2, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      return self2._processReaddir2(prefix, read2, abs, remain, index, inGlobStar, entries, cb);
    });
  }, Glob2.prototype._processReaddir2 = function(prefix, read2, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    for (var pn = remain[0], negate = !!this.minimatch.negate, rawGlob = pn._glob, dotOk = this.dot || rawGlob.charAt(0) === ".", matchedEntries = [], i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        negate && !prefix ? m = !e.match(pn) : m = e.match(pn), m && matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      this.matches[index] || (this.matches[index] = /* @__PURE__ */ Object.create(null));
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        prefix && (prefix !== "/" ? e = prefix + "/" + e : e = prefix + e), e.charAt(0) === "/" && !this.nomount && (e = path2.join(this.root, e)), this._emitMatch(index, e);
      }
      return cb();
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      prefix && (prefix !== "/" ? e = prefix + "/" + e : e = prefix + e), this._process([e].concat(remain), index, inGlobStar, cb);
    }
    cb();
  }, Glob2.prototype._emitMatch = function(index, e) {
    if (!this.aborted && !isIgnored(this, e)) {
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark && (e = this._mark(e)), this.absolute && (e = abs), !this.matches[index][e]) {
        if (this.nodir) {
          var c2 = this.cache[abs];
          if (c2 === "DIR" || Array.isArray(c2))
            return;
        }
        this.matches[index][e] = !0;
        var st = this.statCache[abs];
        st && this.emit("stat", e, st), this.emit("match", e);
      }
    }
  }, Glob2.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs, !1, cb);
    var lstatkey = "lstat\0" + abs, self2 = this, lstatcb = inflight(lstatkey, lstatcb_);
    lstatcb && self2.fs.lstat(abs, lstatcb);
    function lstatcb_(er, lstat2) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat2 && lstat2.isSymbolicLink();
      self2.symlinks[abs] = isSym, !isSym && lstat2 && !lstat2.isDirectory() ? (self2.cache[abs] = "FILE", cb()) : self2._readdir(abs, !1, cb);
    }
  }, Glob2.prototype._readdir = function(abs, inGlobStar, cb) {
    if (!this.aborted && (cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb), !!cb)) {
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c2 = this.cache[abs];
        if (!c2 || c2 === "FILE")
          return cb();
        if (Array.isArray(c2))
          return cb(null, c2);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    }
  };
  function readdirCb(self2, abs, cb) {
    return function(er, entries) {
      er ? self2._readdirError(abs, er, cb) : self2._readdirEntries(abs, entries, cb);
    };
  }
  return Glob2.prototype._readdirEntries = function(abs, entries, cb) {
    if (!this.aborted) {
      if (!this.mark && !this.stat)
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          abs === "/" ? e = abs + e : e = abs + "/" + e, this.cache[e] = !0;
        }
      return this.cache[abs] = entries, cb(null, entries);
    }
  }, Glob2.prototype._readdirError = function(f, er, cb) {
    if (!this.aborted) {
      switch (er.code) {
        case "ENOTSUP":
        // https://github.com/isaacs/node-glob/issues/205
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          if (this.cache[abs] = "FILE", abs === this.cwdAbs) {
            var error2 = new Error(er.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd, error2.code = er.code, this.emit("error", error2), this.abort();
          }
          break;
        case "ENOENT":
        // not terribly unusual
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = !1;
          break;
        default:
          this.cache[this._makeAbs(f)] = !1, this.strict && (this.emit("error", er), this.abort()), this.silent || console.error("glob error", er);
          break;
      }
      return cb();
    }
  }, Glob2.prototype._processGlobStar = function(prefix, read2, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      self2._processGlobStar2(prefix, read2, abs, remain, index, inGlobStar, entries, cb);
    });
  }, Glob2.prototype._processGlobStar2 = function(prefix, read2, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1), gspref = prefix ? [prefix] : [], noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, !1, cb);
    var isSym = this.symlinks[abs], len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (!(e.charAt(0) === "." && !this.dot)) {
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, !0, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, !0, cb);
      }
    }
    cb();
  }, Glob2.prototype._processSimple = function(prefix, index, cb) {
    var self2 = this;
    this._stat(prefix, function(er, exists) {
      self2._processSimple2(prefix, index, er, exists, cb);
    });
  }, Glob2.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
    if (this.matches[index] || (this.matches[index] = /* @__PURE__ */ Object.create(null)), !exists)
      return cb();
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      prefix.charAt(0) === "/" ? prefix = path2.join(this.root, prefix) : (prefix = path2.resolve(this.root, prefix), trail && (prefix += "/"));
    }
    process.platform === "win32" && (prefix = prefix.replace(/\\/g, "/")), this._emitMatch(index, prefix), cb();
  }, Glob2.prototype._stat = function(f, cb) {
    var abs = this._makeAbs(f), needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (Array.isArray(c2) && (c2 = "DIR"), !needDir || c2 === "DIR")
        return cb(null, c2);
      if (needDir && c2 === "FILE")
        return cb();
    }
    var stat2 = this.statCache[abs];
    if (stat2 !== void 0) {
      if (stat2 === !1)
        return cb(null, stat2);
      var type2 = stat2.isDirectory() ? "DIR" : "FILE";
      return needDir && type2 === "FILE" ? cb() : cb(null, type2, stat2);
    }
    var self2 = this, statcb = inflight("stat\0" + abs, lstatcb_);
    statcb && self2.fs.lstat(abs, statcb);
    function lstatcb_(er, lstat2) {
      if (lstat2 && lstat2.isSymbolicLink())
        return self2.fs.stat(abs, function(er2, stat3) {
          er2 ? self2._stat2(f, abs, null, lstat2, cb) : self2._stat2(f, abs, er2, stat3, cb);
        });
      self2._stat2(f, abs, er, lstat2, cb);
    }
  }, Glob2.prototype._stat2 = function(f, abs, er, stat2, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR"))
      return this.statCache[abs] = !1, cb();
    var needDir = f.slice(-1) === "/";
    if (this.statCache[abs] = stat2, abs.slice(-1) === "/" && stat2 && !stat2.isDirectory())
      return cb(null, !1, stat2);
    var c2 = !0;
    return stat2 && (c2 = stat2.isDirectory() ? "DIR" : "FILE"), this.cache[abs] = this.cache[abs] || c2, needDir && c2 === "FILE" ? cb() : cb(null, c2, stat2);
  }, glob_1;
}
var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/, unicode$1 = {
  Space_Separator,
  ID_Start,
  ID_Continue
}, util$2 = {
  isSpaceSeparator(c2) {
    return typeof c2 == "string" && unicode$1.Space_Separator.test(c2);
  },
  isIdStartChar(c2) {
    return typeof c2 == "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode$1.ID_Start.test(c2));
  },
  isIdContinueChar(c2) {
    return typeof c2 == "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "\u200C" || c2 === "\u200D" || unicode$1.ID_Continue.test(c2));
  },
  isDigit(c2) {
    return typeof c2 == "string" && /[0-9]/.test(c2);
  },
  isHexDigit(c2) {
    return typeof c2 == "string" && /[0-9A-Fa-f]/.test(c2);
  }
};
let source, parseState, stack, pos, line$1, column, token, key, root;
var parse$1 = function parse2(text, reviver) {
  source = String(text), parseState = "start", stack = [], pos = 0, line$1 = 1, column = 0, token = void 0, key = void 0, root = void 0;
  do
    token = lex(), parseStates[parseState]();
  while (token.type !== "eof");
  return typeof reviver == "function" ? internalize({ "": root }, "", reviver) : root;
};
function internalize(holder, name, reviver) {
  const value = holder[name];
  if (value != null && typeof value == "object")
    if (Array.isArray(value))
      for (let i = 0; i < value.length; i++) {
        const key2 = String(i), replacement = internalize(value, key2, reviver);
        replacement === void 0 ? delete value[key2] : Object.defineProperty(value, key2, {
          value: replacement,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
    else
      for (const key2 in value) {
        const replacement = internalize(value, key2, reviver);
        replacement === void 0 ? delete value[key2] : Object.defineProperty(value, key2, {
          value: replacement,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
  return reviver.call(holder, name, value);
}
let lexState, buffer$1, doubleQuote, sign, c;
function lex() {
  for (lexState = "default", buffer$1 = "", doubleQuote = !1, sign = 1; ; ) {
    c = peek();
    const token2 = lexStates[lexState]();
    if (token2)
      return token2;
  }
}
function peek() {
  if (source[pos])
    return String.fromCodePoint(source.codePointAt(pos));
}
function read() {
  const c2 = peek();
  return c2 === `
` ? (line$1++, column = 0) : c2 ? column += c2.length : column++, c2 && (pos += c2.length), c2;
}
const lexStates = {
  default() {
    switch (c) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case "\xA0":
      case "\uFEFF":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        return;
      case "/":
        read(), lexState = "comment";
        return;
      case void 0:
        return read(), newToken("eof");
    }
    if (util$2.isSpaceSeparator(c)) {
      read();
      return;
    }
    return lexStates[parseState]();
  },
  comment() {
    switch (c) {
      case "*":
        read(), lexState = "multiLineComment";
        return;
      case "/":
        read(), lexState = "singleLineComment";
        return;
    }
    throw invalidChar(read());
  },
  multiLineComment() {
    switch (c) {
      case "*":
        read(), lexState = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
  },
  multiLineCommentAsterisk() {
    switch (c) {
      case "*":
        read();
        return;
      case "/":
        read(), lexState = "default";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read(), lexState = "multiLineComment";
  },
  singleLineComment() {
    switch (c) {
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        read(), lexState = "default";
        return;
      case void 0:
        return read(), newToken("eof");
    }
    read();
  },
  value() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
      case "n":
        return read(), literal("ull"), newToken("null", null);
      case "t":
        return read(), literal("rue"), newToken("boolean", !0);
      case "f":
        return read(), literal("alse"), newToken("boolean", !1);
      case "-":
      case "+":
        read() === "-" && (sign = -1), lexState = "sign";
        return;
      case ".":
        buffer$1 = read(), lexState = "decimalPointLeading";
        return;
      case "0":
        buffer$1 = read(), lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer$1 = read(), lexState = "decimalInteger";
        return;
      case "I":
        return read(), literal("nfinity"), newToken("numeric", 1 / 0);
      case "N":
        return read(), literal("aN"), newToken("numeric", NaN);
      case '"':
      case "'":
        doubleQuote = read() === '"', buffer$1 = "", lexState = "string";
        return;
    }
    throw invalidChar(read());
  },
  identifierNameStartEscape() {
    if (c !== "u")
      throw invalidChar(read());
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
        break;
      default:
        if (!util$2.isIdStartChar(u))
          throw invalidIdentifier();
        break;
    }
    buffer$1 += u, lexState = "identifierName";
  },
  identifierName() {
    switch (c) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        buffer$1 += read();
        return;
      case "\\":
        read(), lexState = "identifierNameEscape";
        return;
    }
    if (util$2.isIdContinueChar(c)) {
      buffer$1 += read();
      return;
    }
    return newToken("identifier", buffer$1);
  },
  identifierNameEscape() {
    if (c !== "u")
      throw invalidChar(read());
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        break;
      default:
        if (!util$2.isIdContinueChar(u))
          throw invalidIdentifier();
        break;
    }
    buffer$1 += u, lexState = "identifierName";
  },
  sign() {
    switch (c) {
      case ".":
        buffer$1 = read(), lexState = "decimalPointLeading";
        return;
      case "0":
        buffer$1 = read(), lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer$1 = read(), lexState = "decimalInteger";
        return;
      case "I":
        return read(), literal("nfinity"), newToken("numeric", sign * (1 / 0));
      case "N":
        return read(), literal("aN"), newToken("numeric", NaN);
    }
    throw invalidChar(read());
  },
  zero() {
    switch (c) {
      case ".":
        buffer$1 += read(), lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer$1 += read(), lexState = "decimalExponent";
        return;
      case "x":
      case "X":
        buffer$1 += read(), lexState = "hexadecimal";
        return;
    }
    return newToken("numeric", sign * 0);
  },
  decimalInteger() {
    switch (c) {
      case ".":
        buffer$1 += read(), lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer$1 += read(), lexState = "decimalExponent";
        return;
    }
    if (util$2.isDigit(c)) {
      buffer$1 += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer$1));
  },
  decimalPointLeading() {
    if (util$2.isDigit(c)) {
      buffer$1 += read(), lexState = "decimalFraction";
      return;
    }
    throw invalidChar(read());
  },
  decimalPoint() {
    switch (c) {
      case "e":
      case "E":
        buffer$1 += read(), lexState = "decimalExponent";
        return;
    }
    if (util$2.isDigit(c)) {
      buffer$1 += read(), lexState = "decimalFraction";
      return;
    }
    return newToken("numeric", sign * Number(buffer$1));
  },
  decimalFraction() {
    switch (c) {
      case "e":
      case "E":
        buffer$1 += read(), lexState = "decimalExponent";
        return;
    }
    if (util$2.isDigit(c)) {
      buffer$1 += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer$1));
  },
  decimalExponent() {
    switch (c) {
      case "+":
      case "-":
        buffer$1 += read(), lexState = "decimalExponentSign";
        return;
    }
    if (util$2.isDigit(c)) {
      buffer$1 += read(), lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentSign() {
    if (util$2.isDigit(c)) {
      buffer$1 += read(), lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentInteger() {
    if (util$2.isDigit(c)) {
      buffer$1 += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer$1));
  },
  hexadecimal() {
    if (util$2.isHexDigit(c)) {
      buffer$1 += read(), lexState = "hexadecimalInteger";
      return;
    }
    throw invalidChar(read());
  },
  hexadecimalInteger() {
    if (util$2.isHexDigit(c)) {
      buffer$1 += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer$1));
  },
  string() {
    switch (c) {
      case "\\":
        read(), buffer$1 += escape$1();
        return;
      case '"':
        if (doubleQuote)
          return read(), newToken("string", buffer$1);
        buffer$1 += read();
        return;
      case "'":
        if (!doubleQuote)
          return read(), newToken("string", buffer$1);
        buffer$1 += read();
        return;
      case `
`:
      case "\r":
        throw invalidChar(read());
      case "\u2028":
      case "\u2029":
        separatorChar(c);
        break;
      case void 0:
        throw invalidChar(read());
    }
    buffer$1 += read();
  },
  start() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
    }
    lexState = "value";
  },
  beforePropertyName() {
    switch (c) {
      case "$":
      case "_":
        buffer$1 = read(), lexState = "identifierName";
        return;
      case "\\":
        read(), lexState = "identifierNameStartEscape";
        return;
      case "}":
        return newToken("punctuator", read());
      case '"':
      case "'":
        doubleQuote = read() === '"', lexState = "string";
        return;
    }
    if (util$2.isIdStartChar(c)) {
      buffer$1 += read(), lexState = "identifierName";
      return;
    }
    throw invalidChar(read());
  },
  afterPropertyName() {
    if (c === ":")
      return newToken("punctuator", read());
    throw invalidChar(read());
  },
  beforePropertyValue() {
    lexState = "value";
  },
  afterPropertyValue() {
    switch (c) {
      case ",":
      case "}":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforeArrayValue() {
    if (c === "]")
      return newToken("punctuator", read());
    lexState = "value";
  },
  afterArrayValue() {
    switch (c) {
      case ",":
      case "]":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  end() {
    throw invalidChar(read());
  }
};
function newToken(type2, value) {
  return {
    type: type2,
    value,
    line: line$1,
    column
  };
}
function literal(s) {
  for (const c2 of s) {
    if (peek() !== c2)
      throw invalidChar(read());
    read();
  }
}
function escape$1() {
  switch (peek()) {
    case "b":
      return read(), "\b";
    case "f":
      return read(), "\f";
    case "n":
      return read(), `
`;
    case "r":
      return read(), "\r";
    case "t":
      return read(), "	";
    case "v":
      return read(), "\v";
    case "0":
      if (read(), util$2.isDigit(peek()))
        throw invalidChar(read());
      return "\0";
    case "x":
      return read(), hexEscape();
    case "u":
      return read(), unicodeEscape();
    case `
`:
    case "\u2028":
    case "\u2029":
      return read(), "";
    case "\r":
      return read(), peek() === `
` && read(), "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw invalidChar(read());
    case void 0:
      throw invalidChar(read());
  }
  return read();
}
function hexEscape() {
  let buffer2 = "", c2 = peek();
  if (!util$2.isHexDigit(c2) || (buffer2 += read(), c2 = peek(), !util$2.isHexDigit(c2)))
    throw invalidChar(read());
  return buffer2 += read(), String.fromCodePoint(parseInt(buffer2, 16));
}
function unicodeEscape() {
  let buffer2 = "", count2 = 4;
  for (; count2-- > 0; ) {
    const c2 = peek();
    if (!util$2.isHexDigit(c2))
      throw invalidChar(read());
    buffer2 += read();
  }
  return String.fromCodePoint(parseInt(buffer2, 16));
}
const parseStates = {
  start() {
    if (token.type === "eof")
      throw invalidEOF();
    push();
  },
  beforePropertyName() {
    switch (token.type) {
      case "identifier":
      case "string":
        key = token.value, parseState = "afterPropertyName";
        return;
      case "punctuator":
        pop();
        return;
      case "eof":
        throw invalidEOF();
    }
  },
  afterPropertyName() {
    if (token.type === "eof")
      throw invalidEOF();
    parseState = "beforePropertyValue";
  },
  beforePropertyValue() {
    if (token.type === "eof")
      throw invalidEOF();
    push();
  },
  beforeArrayValue() {
    if (token.type === "eof")
      throw invalidEOF();
    if (token.type === "punctuator" && token.value === "]") {
      pop();
      return;
    }
    push();
  },
  afterPropertyValue() {
    if (token.type === "eof")
      throw invalidEOF();
    switch (token.value) {
      case ",":
        parseState = "beforePropertyName";
        return;
      case "}":
        pop();
    }
  },
  afterArrayValue() {
    if (token.type === "eof")
      throw invalidEOF();
    switch (token.value) {
      case ",":
        parseState = "beforeArrayValue";
        return;
      case "]":
        pop();
    }
  },
  end() {
  }
};
function push() {
  let value;
  switch (token.type) {
    case "punctuator":
      switch (token.value) {
        case "{":
          value = {};
          break;
        case "[":
          value = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      value = token.value;
      break;
  }
  if (root === void 0)
    root = value;
  else {
    const parent = stack[stack.length - 1];
    Array.isArray(parent) ? parent.push(value) : Object.defineProperty(parent, key, {
      value,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  }
  if (value !== null && typeof value == "object")
    stack.push(value), Array.isArray(value) ? parseState = "beforeArrayValue" : parseState = "beforePropertyName";
  else {
    const current = stack[stack.length - 1];
    current == null ? parseState = "end" : Array.isArray(current) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
  }
}
function pop() {
  stack.pop();
  const current = stack[stack.length - 1];
  current == null ? parseState = "end" : Array.isArray(current) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
}
function invalidChar(c2) {
  return syntaxError(c2 === void 0 ? `JSON5: invalid end of input at ${line$1}:${column}` : `JSON5: invalid character '${formatChar(c2)}' at ${line$1}:${column}`);
}
function invalidEOF() {
  return syntaxError(`JSON5: invalid end of input at ${line$1}:${column}`);
}
function invalidIdentifier() {
  return column -= 5, syntaxError(`JSON5: invalid identifier character at ${line$1}:${column}`);
}
function separatorChar(c2) {
  console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
}
function formatChar(c2) {
  const replacements = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (replacements[c2])
    return replacements[c2];
  if (c2 < " ") {
    const hexString = c2.charCodeAt(0).toString(16);
    return "\\x" + ("00" + hexString).substring(hexString.length);
  }
  return c2;
}
function syntaxError(message) {
  const err = new SyntaxError(message);
  return err.lineNumber = line$1, err.columnNumber = column, err;
}
var stringify$1 = function stringify2(value, replacer, space) {
  const stack2 = [];
  let indent = "", propertyList, replacerFunc, gap = "", quote;
  if (replacer != null && typeof replacer == "object" && !Array.isArray(replacer) && (space = replacer.space, quote = replacer.quote, replacer = replacer.replacer), typeof replacer == "function")
    replacerFunc = replacer;
  else if (Array.isArray(replacer)) {
    propertyList = [];
    for (const v of replacer) {
      let item;
      typeof v == "string" ? item = v : (typeof v == "number" || v instanceof String || v instanceof Number) && (item = String(v)), item !== void 0 && propertyList.indexOf(item) < 0 && propertyList.push(item);
    }
  }
  return space instanceof Number ? space = Number(space) : space instanceof String && (space = String(space)), typeof space == "number" ? space > 0 && (space = Math.min(10, Math.floor(space)), gap = "          ".substr(0, space)) : typeof space == "string" && (gap = space.substr(0, 10)), serializeProperty("", { "": value });
  function serializeProperty(key2, holder) {
    let value2 = holder[key2];
    switch (value2 != null && (typeof value2.toJSON5 == "function" ? value2 = value2.toJSON5(key2) : typeof value2.toJSON == "function" && (value2 = value2.toJSON(key2))), replacerFunc && (value2 = replacerFunc.call(holder, key2, value2)), value2 instanceof Number ? value2 = Number(value2) : value2 instanceof String ? value2 = String(value2) : value2 instanceof Boolean && (value2 = value2.valueOf()), value2) {
      case null:
        return "null";
      case !0:
        return "true";
      case !1:
        return "false";
    }
    if (typeof value2 == "string")
      return quoteString(value2);
    if (typeof value2 == "number")
      return String(value2);
    if (typeof value2 == "object")
      return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
  }
  function quoteString(value2) {
    const quotes = {
      "'": 0.1,
      '"': 0.2
    }, replacements = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    let product = "";
    for (let i = 0; i < value2.length; i++) {
      const c2 = value2[i];
      switch (c2) {
        case "'":
        case '"':
          quotes[c2]++, product += c2;
          continue;
        case "\0":
          if (util$2.isDigit(value2[i + 1])) {
            product += "\\x00";
            continue;
          }
      }
      if (replacements[c2]) {
        product += replacements[c2];
        continue;
      }
      if (c2 < " ") {
        let hexString = c2.charCodeAt(0).toString(16);
        product += "\\x" + ("00" + hexString).substring(hexString.length);
        continue;
      }
      product += c2;
    }
    const quoteChar = quote || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);
    return product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]), quoteChar + product + quoteChar;
  }
  function serializeObject(value2) {
    if (stack2.indexOf(value2) >= 0)
      throw TypeError("Converting circular structure to JSON5");
    stack2.push(value2);
    let stepback = indent;
    indent = indent + gap;
    let keys = propertyList || Object.keys(value2), partial = [];
    for (const key2 of keys) {
      const propertyString = serializeProperty(key2, value2);
      if (propertyString !== void 0) {
        let member = serializeKey(key2) + ":";
        gap !== "" && (member += " "), member += propertyString, partial.push(member);
      }
    }
    let final;
    if (partial.length === 0)
      final = "{}";
    else {
      let properties;
      if (gap === "")
        properties = partial.join(","), final = "{" + properties + "}";
      else {
        let separator2 = `,
` + indent;
        properties = partial.join(separator2), final = `{
` + indent + properties + `,
` + stepback + "}";
      }
    }
    return stack2.pop(), indent = stepback, final;
  }
  function serializeKey(key2) {
    if (key2.length === 0)
      return quoteString(key2);
    const firstChar = String.fromCodePoint(key2.codePointAt(0));
    if (!util$2.isIdStartChar(firstChar))
      return quoteString(key2);
    for (let i = firstChar.length; i < key2.length; i++)
      if (!util$2.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i))))
        return quoteString(key2);
    return key2;
  }
  function serializeArray(value2) {
    if (stack2.indexOf(value2) >= 0)
      throw TypeError("Converting circular structure to JSON5");
    stack2.push(value2);
    let stepback = indent;
    indent = indent + gap;
    let partial = [];
    for (let i = 0; i < value2.length; i++) {
      const propertyString = serializeProperty(String(i), value2);
      partial.push(propertyString !== void 0 ? propertyString : "null");
    }
    let final;
    if (partial.length === 0)
      final = "[]";
    else if (gap === "")
      final = "[" + partial.join(",") + "]";
    else {
      let separator2 = `,
` + indent, properties = partial.join(separator2);
      final = `[
` + indent + properties + `,
` + stepback + "]";
    }
    return stack2.pop(), indent = stepback, final;
  }
};
const JSON5 = {
  parse: parse$1,
  stringify: stringify$1
};
var lib$2 = JSON5, dist = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: lib$2
}), require$$4$2 = /* @__PURE__ */ loadEnv.getAugmentedNamespace(dist), getGlobFs = {}, hasRequiredGetGlobFs;
function requireGetGlobFs() {
  if (hasRequiredGetGlobFs) return getGlobFs;
  hasRequiredGetGlobFs = 1;
  var __importDefault2 = getGlobFs && getGlobFs.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(getGlobFs, "__esModule", { value: !0 }), getGlobFs.getGlobFs = void 0;
  const fs_1 = __importDefault2(require$$0__default.default);
  function removeWindowsPrefix(path2) {
    return path2.replace(/^[a-zA-Z]:/, "");
  }
  function getGlobFs$1(_fs) {
    const readdir2 = (path2, callback) => {
      _fs.readdir(removeWindowsPrefix(String(path2))).then((stats) => callback(null, stats.map((stat3) => stat3.name))).catch((err) => callback(err, []));
    }, stat2 = (path2, callback) => {
      _fs.isFile(removeWindowsPrefix(String(path2))).then((isPathAFile) => {
        callback(null, {
          ino: 0,
          mode: 0,
          nlink: 0,
          uid: 0,
          gid: 0,
          rdev: 0,
          size: 0,
          blksize: 0,
          blocks: 0,
          atimeMs: 0,
          mtimeMs: 0,
          ctimeMs: 0,
          birthtimeMs: 0,
          atime: /* @__PURE__ */ new Date(),
          mtime: /* @__PURE__ */ new Date(),
          ctime: /* @__PURE__ */ new Date(),
          birthtime: /* @__PURE__ */ new Date(),
          dev: 0,
          isBlockDevice: () => !1,
          isCharacterDevice: () => !1,
          isDirectory: () => !isPathAFile,
          isFIFO: () => !1,
          isFile: () => isPathAFile,
          isSocket: () => !1,
          isSymbolicLink: () => !1
        });
      }).catch((err) => callback(err, null));
    };
    return new Proxy(fs_1.default, {
      get(_target, prop) {
        switch (prop) {
          case "readdir":
            return readdir2;
          case "lstat":
          case "stat":
            return stat2;
          default:
            throw new Error("Not Implemented");
        }
      }
    });
  }
  return getGlobFs.getGlobFs = getGlobFs$1, getGlobFs;
}
var hasRequiredGetWorkspacePackagePaths;
function requireGetWorkspacePackagePaths() {
  if (hasRequiredGetWorkspacePackagePaths) return getWorkspacePackagePaths;
  hasRequiredGetWorkspacePackagePaths = 1;
  var __importDefault2 = getWorkspacePackagePaths && getWorkspacePackagePaths.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(getWorkspacePackagePaths, "__esModule", { value: !0 }), getWorkspacePackagePaths.getWorkspacePackagePaths = void 0;
  const path_1 = __importDefault2(require$$0__default$1.default), js_yaml_1 = __importDefault2(requireJsYaml$2()), glob_12 = __importDefault2(requireGlob()), json5_1 = __importDefault2(require$$4$2), get_glob_fs_1 = requireGetGlobFs(), posixPath = path_1.default.posix;
  async function getWorkspacePackagePaths$1({ fs: fs2, workspace }) {
    const { type: type2, rootPath } = workspace, workspaceFs = fs2.chdir(rootPath);
    let results = [];
    switch (type2) {
      case "yarn":
      case "npm":
        results = await getPackageJsonWorkspacePackagePaths({ fs: workspaceFs });
        break;
      case "pnpm":
        results = await getPnpmWorkspacePackagePaths({ fs: workspaceFs });
        break;
      case "nx":
        results = await getNxWorkspacePackagePaths({ fs: workspaceFs });
        break;
      case "rush":
        results = await getRushWorkspacePackagePaths({ fs: workspaceFs });
        break;
      default:
        throw new Error(`Unknown workspace implementation: ${type2}`);
    }
    return results.map((packagePath) => posixPath.join(rootPath, posixPath.dirname(packagePath)));
  }
  getWorkspacePackagePaths.getWorkspacePackagePaths = getWorkspacePackagePaths$1;
  const isWin = process.platform === "win32", normalizePath = (p) => isWin ? p.replace(/\\/g, "/") : p;
  async function getPackagePaths(packages, fs2) {
    return (await Promise.all(packages.map((packageGlob) => new Promise((resolve, reject) => {
      (0, glob_12.default)(normalizePath(posixPath.join(packageGlob, "package.json")), {
        cwd: "/",
        fs: (0, get_glob_fs_1.getGlobFs)(fs2)
      }, (err, matches) => {
        err ? reject(err) : resolve(matches);
      });
    })))).flat();
  }
  async function getPackageJsonWorkspacePackagePaths({ fs: fs2 }) {
    const packageJsonAsBuffer = await fs2.readFile("package.json"), { workspaces } = JSON.parse(packageJsonAsBuffer.toString());
    let packages = [];
    return Array.isArray(workspaces) ? packages = workspaces : packages = workspaces?.packages ?? [], getPackagePaths(packages, fs2);
  }
  async function getNxWorkspacePackagePaths({ fs: fs2 }) {
    const nxWorkspaceJsonAsBuffer = await fs2.readFile("workspace.json"), { projects } = JSON.parse(nxWorkspaceJsonAsBuffer.toString()), packages = Object.values(projects);
    return getPackagePaths(packages, fs2);
  }
  async function getPnpmWorkspacePackagePaths({ fs: fs2 }) {
    const pnpmWorkspaceAsBuffer = await fs2.readFile("pnpm-workspace.yaml"), { packages = [] } = js_yaml_1.default.load(pnpmWorkspaceAsBuffer.toString());
    return getPackagePaths(packages, fs2);
  }
  async function getRushWorkspacePackagePaths({ fs: fs2 }) {
    const rushWorkspaceAsBuffer = await fs2.readFile("rush.json"), { projects = [] } = json5_1.default.parse(rushWorkspaceAsBuffer.toString());
    if (Array.isArray(projects)) {
      const packages = projects.filter((proj) => proj.projectFolder).map((project) => project.projectFolder);
      return getPackagePaths(packages, fs2);
    } else
      return [];
  }
  return getWorkspacePackagePaths;
}
var monorepoManagers = {}, hasRequiredMonorepoManagers;
function requireMonorepoManagers() {
  return hasRequiredMonorepoManagers || (hasRequiredMonorepoManagers = 1, function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.monorepoManagers = void 0, exports2.monorepoManagers = [
      {
        name: "Turborepo",
        slug: "turbo",
        logo: "https://api-frameworks.vercel.sh/monorepo-logos/turborepo.svg",
        darkModeLogo: "https://api-frameworks.vercel.sh/monorepo-logos/turborepo-dark.svg",
        detectors: {
          some: [
            {
              path: "turbo.json"
            },
            {
              path: "package.json",
              matchContent: '"turbo":\\s*{[^}]*.+[^}]*}'
            }
          ]
        },
        settings: {
          buildCommand: {
            placeholder: "Turborepo default",
            value: null
          },
          outputDirectory: {
            value: null
          },
          installCommand: {
            value: null
          },
          devCommand: {
            value: null
          }
        }
      },
      {
        name: "Nx",
        slug: "nx",
        logo: "https://api-frameworks.vercel.sh/monorepo-logos/nx.svg",
        detectors: {
          every: [
            {
              path: "nx.json"
            }
          ]
        },
        settings: {
          buildCommand: {
            placeholder: "Nx default",
            value: null
          },
          outputDirectory: {
            value: null
          },
          installCommand: {
            value: null
          },
          devCommand: {
            value: null
          }
        }
      },
      {
        name: "Rush",
        slug: "rush",
        logo: "https://api-frameworks.vercel.sh/monorepo-logos/rush.svg",
        detectors: {
          every: [
            {
              path: "rush.json"
            }
          ]
        },
        settings: {
          buildCommand: {
            placeholder: "Rush default",
            value: null
          },
          outputDirectory: {
            value: null
          },
          installCommand: {
            placeholder: "Rush default"
          },
          devCommand: {
            value: null
          }
        }
      }
    ], exports2.default = exports2.monorepoManagers;
  }(monorepoManagers)), monorepoManagers;
}
var packageManagers = {}, hasRequiredPackageManagers;
function requirePackageManagers() {
  return hasRequiredPackageManagers || (hasRequiredPackageManagers = 1, Object.defineProperty(packageManagers, "__esModule", { value: !0 }), packageManagers.packageManagers = void 0, packageManagers.packageManagers = [
    {
      name: "npm",
      slug: "npm",
      logo: "",
      darkModeLogo: "",
      detectors: {
        some: [
          {
            path: "package-lock.json"
          },
          {
            path: "package.json",
            matchContent: '"packageManager":\\s*"npm@.*"'
          }
        ]
      }
    },
    {
      name: "pnpm",
      slug: "pnpm",
      logo: "",
      darkModeLogo: "",
      detectors: {
        some: [
          {
            path: "pnpm-lock.yaml"
          },
          {
            path: "package.json",
            matchContent: '"packageManager":\\s*"pnpm@.*"'
          }
        ]
      }
    },
    {
      name: "yarn",
      slug: "yarn",
      logo: "",
      darkModeLogo: "",
      detectors: {
        some: [
          {
            path: "yarn.lock"
          },
          {
            path: "package.json",
            matchContent: '"packageManager":\\s*"yarn@.*"'
          },
          {
            path: "package.json"
          }
        ]
      }
    }
  ]), packageManagers;
}
var getMonorepoDefaultSettings = {}, hasRequiredGetMonorepoDefaultSettings;
function requireGetMonorepoDefaultSettings() {
  if (hasRequiredGetMonorepoDefaultSettings) return getMonorepoDefaultSettings;
  hasRequiredGetMonorepoDefaultSettings = 1;
  var __importDefault2 = getMonorepoDefaultSettings && getMonorepoDefaultSettings.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(getMonorepoDefaultSettings, "__esModule", { value: !0 }), getMonorepoDefaultSettings.getMonorepoDefaultSettings = getMonorepoDefaultSettings.MissingBuildTarget = getMonorepoDefaultSettings.MissingBuildPipeline = void 0;
  const path_1 = require$$0__default$1.default, monorepo_managers_1 = requireMonorepoManagers(), package_managers_1 = requirePackageManagers(), detect_framework_1 = requireDetectFramework(), json5_1 = __importDefault2(require$$4$2), semver_1 = __importDefault2(semver__default.default);
  class MissingBuildPipeline extends Error {
    constructor() {
      super("Missing required `build` pipeline in turbo.json or package.json Turbo configuration.");
    }
  }
  getMonorepoDefaultSettings.MissingBuildPipeline = MissingBuildPipeline;
  class MissingBuildTarget extends Error {
    constructor() {
      super("Missing required `build` target in either nx.json, project.json, or package.json Nx configuration.");
    }
  }
  getMonorepoDefaultSettings.MissingBuildTarget = MissingBuildTarget;
  function supportsRootCommand(turboSemVer) {
    return !turboSemVer || !semver_1.default.validRange(turboSemVer) ? !1 : !semver_1.default.intersects(turboSemVer, "<1.8.0");
  }
  async function getMonorepoDefaultSettings$1(projectName, projectPath, relativeToRoot, detectorFilesystem) {
    const [monorepoManager, packageManager] = await Promise.all([
      (0, detect_framework_1.detectFramework)({
        fs: detectorFilesystem,
        frameworkList: monorepo_managers_1.monorepoManagers
      }),
      (0, detect_framework_1.detectFramework)({
        fs: detectorFilesystem,
        frameworkList: package_managers_1.packageManagers
      })
    ]);
    if (monorepoManager === "turbo") {
      const [turboJSONBuf, packageJSONBuf] = await Promise.all([
        detectorFilesystem.readFile("turbo.json").catch(() => null),
        detectorFilesystem.readFile("package.json").catch(() => null)
      ]);
      let hasBuildPipeline = !1, turboSemVer = null;
      if (turboJSONBuf !== null && json5_1.default.parse(turboJSONBuf.toString("utf-8"))?.pipeline?.build && (hasBuildPipeline = !0), packageJSONBuf !== null) {
        const packageJSON = JSON.parse(packageJSONBuf.toString("utf-8"));
        packageJSON?.turbo?.pipeline?.build && (hasBuildPipeline = !0), turboSemVer = packageJSON?.dependencies?.turbo || packageJSON?.devDependencies?.turbo || null;
      }
      if (!hasBuildPipeline)
        throw new MissingBuildPipeline();
      if (projectPath === "/")
        return {
          monorepoManager: "turbo",
          buildCommand: "turbo run build",
          installCommand: packageManager ? `${packageManager} install` : null,
          commandForIgnoringBuildStep: "npx turbo-ignore"
        };
      let buildCommand = null;
      return projectPath && (supportsRootCommand(turboSemVer) ? buildCommand = "turbo run build" : buildCommand = `cd ${relativeToRoot} && turbo run build --filter={${projectPath}}...`), {
        monorepoManager: "turbo",
        buildCommand,
        installCommand: packageManager === "npm" ? `${packageManager} install --prefix=${relativeToRoot}` : packageManager ? `${packageManager} install` : null,
        commandForIgnoringBuildStep: "npx turbo-ignore"
      };
    } else if (monorepoManager === "nx") {
      const nxJSONBuf = await detectorFilesystem.readFile("nx.json");
      if (!json5_1.default.parse(nxJSONBuf.toString("utf-8"))?.targetDefaults?.build) {
        const [projectJSONBuf, packageJSONBuf] = await Promise.all([
          detectorFilesystem.readFile((0, path_1.join)(projectPath, "project.json")).catch(() => null),
          detectorFilesystem.readFile((0, path_1.join)(projectPath, "package.json")).catch(() => null)
        ]);
        let hasBuildTarget = !1;
        if (projectJSONBuf && json5_1.default.parse(projectJSONBuf.toString("utf-8"))?.targets?.build && (hasBuildTarget = !0), packageJSONBuf) {
          const packageJSON = json5_1.default.parse(packageJSONBuf.toString("utf-8"));
          packageJSON?.nx && packageJSON.nx.targets?.build && (hasBuildTarget = !0);
        }
        if (!hasBuildTarget)
          throw new MissingBuildTarget();
      }
      return projectPath === "/" ? {
        monorepoManager: "nx",
        buildCommand: "npx nx build",
        installCommand: packageManager ? `${packageManager} install` : null
      } : {
        monorepoManager: "nx",
        buildCommand: projectName ? `cd ${relativeToRoot} && npx nx build ${projectName}` : null,
        installCommand: packageManager === "npm" ? `${packageManager} install --prefix=${relativeToRoot}` : packageManager ? `${packageManager} install` : null
      };
    }
    return null;
  }
  return getMonorepoDefaultSettings.getMonorepoDefaultSettings = getMonorepoDefaultSettings$1, getMonorepoDefaultSettings;
}
var hasRequiredDist;
function requireDist() {
  return hasRequiredDist || (hasRequiredDist = 1, function(exports2) {
    var __createBinding2 = dist$1 && dist$1.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar2 = dist$1 && dist$1.__exportStar || function(m, exports3) {
      for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p) && __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.packageManagers = exports2.isStaticRuntime = exports2.isOfficialRuntime = exports2.monorepoManagers = exports2.getWorkspacePackagePaths = exports2.getWorkspaces = exports2.workspaceManagers = exports2.LocalFileSystemDetector = exports2.DetectorFilesystem = exports2.getProjectPaths = exports2.detectFrameworkVersion = exports2.detectFrameworkRecord = exports2.detectFrameworks = exports2.detectFramework = exports2.detectFileSystemAPI = exports2.detectApiExtensions = exports2.detectApiDirectory = exports2.detectOutputDirectory = exports2.detectBuilders = void 0;
    var detect_builders_1 = requireDetectBuilders();
    Object.defineProperty(exports2, "detectBuilders", { enumerable: !0, get: function() {
      return detect_builders_1.detectBuilders;
    } }), Object.defineProperty(exports2, "detectOutputDirectory", { enumerable: !0, get: function() {
      return detect_builders_1.detectOutputDirectory;
    } }), Object.defineProperty(exports2, "detectApiDirectory", { enumerable: !0, get: function() {
      return detect_builders_1.detectApiDirectory;
    } }), Object.defineProperty(exports2, "detectApiExtensions", { enumerable: !0, get: function() {
      return detect_builders_1.detectApiExtensions;
    } });
    var detect_file_system_api_1 = requireDetectFileSystemApi();
    Object.defineProperty(exports2, "detectFileSystemAPI", { enumerable: !0, get: function() {
      return detect_file_system_api_1.detectFileSystemAPI;
    } });
    var detect_framework_1 = requireDetectFramework();
    Object.defineProperty(exports2, "detectFramework", { enumerable: !0, get: function() {
      return detect_framework_1.detectFramework;
    } }), Object.defineProperty(exports2, "detectFrameworks", { enumerable: !0, get: function() {
      return detect_framework_1.detectFrameworks;
    } }), Object.defineProperty(exports2, "detectFrameworkRecord", { enumerable: !0, get: function() {
      return detect_framework_1.detectFrameworkRecord;
    } }), Object.defineProperty(exports2, "detectFrameworkVersion", { enumerable: !0, get: function() {
      return detect_framework_1.detectFrameworkVersion;
    } });
    var get_project_paths_1 = requireGetProjectPaths();
    Object.defineProperty(exports2, "getProjectPaths", { enumerable: !0, get: function() {
      return get_project_paths_1.getProjectPaths;
    } });
    var filesystem_1 = requireFilesystem();
    Object.defineProperty(exports2, "DetectorFilesystem", { enumerable: !0, get: function() {
      return filesystem_1.DetectorFilesystem;
    } });
    var local_file_system_detector_1 = requireLocalFileSystemDetector();
    Object.defineProperty(exports2, "LocalFileSystemDetector", { enumerable: !0, get: function() {
      return local_file_system_detector_1.LocalFileSystemDetector;
    } });
    var workspace_managers_1 = requireWorkspaceManagers();
    Object.defineProperty(exports2, "workspaceManagers", { enumerable: !0, get: function() {
      return workspace_managers_1.workspaceManagers;
    } });
    var get_workspaces_1 = requireGetWorkspaces();
    Object.defineProperty(exports2, "getWorkspaces", { enumerable: !0, get: function() {
      return get_workspaces_1.getWorkspaces;
    } });
    var get_workspace_package_paths_1 = requireGetWorkspacePackagePaths();
    Object.defineProperty(exports2, "getWorkspacePackagePaths", { enumerable: !0, get: function() {
      return get_workspace_package_paths_1.getWorkspacePackagePaths;
    } });
    var monorepo_managers_1 = requireMonorepoManagers();
    Object.defineProperty(exports2, "monorepoManagers", { enumerable: !0, get: function() {
      return monorepo_managers_1.monorepoManagers;
    } });
    var is_official_runtime_1 = requireIsOfficialRuntime();
    Object.defineProperty(exports2, "isOfficialRuntime", { enumerable: !0, get: function() {
      return is_official_runtime_1.isOfficialRuntime;
    } }), Object.defineProperty(exports2, "isStaticRuntime", { enumerable: !0, get: function() {
      return is_official_runtime_1.isStaticRuntime;
    } });
    var package_managers_1 = requirePackageManagers();
    Object.defineProperty(exports2, "packageManagers", { enumerable: !0, get: function() {
      return package_managers_1.packageManagers;
    } }), __exportStar2(requireGetMonorepoDefaultSettings(), exports2);
  }(dist$1)), dist$1;
}
var distExports = requireDist(), execa$1 = { exports: {} }, crossSpawn = { exports: {} }, windows$1, hasRequiredWindows;
function requireWindows() {
  if (hasRequiredWindows) return windows$1;
  hasRequiredWindows = 1, windows$1 = isexe, isexe.sync = sync2;
  var fs2 = require$$0__default.default;
  function checkPathExt(path2, options2) {
    var pathext = options2.pathExt !== void 0 ? options2.pathExt : process.env.PATHEXT;
    if (!pathext || (pathext = pathext.split(";"), pathext.indexOf("") !== -1))
      return !0;
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path2.substr(-p.length).toLowerCase() === p)
        return !0;
    }
    return !1;
  }
  function checkStat(stat2, path2, options2) {
    return !stat2.isSymbolicLink() && !stat2.isFile() ? !1 : checkPathExt(path2, options2);
  }
  function isexe(path2, options2, cb) {
    fs2.stat(path2, function(er, stat2) {
      cb(er, er ? !1 : checkStat(stat2, path2, options2));
    });
  }
  function sync2(path2, options2) {
    return checkStat(fs2.statSync(path2), path2, options2);
  }
  return windows$1;
}
var mode, hasRequiredMode;
function requireMode() {
  if (hasRequiredMode) return mode;
  hasRequiredMode = 1, mode = isexe, isexe.sync = sync2;
  var fs2 = require$$0__default.default;
  function isexe(path2, options2, cb) {
    fs2.stat(path2, function(er, stat2) {
      cb(er, er ? !1 : checkStat(stat2, options2));
    });
  }
  function sync2(path2, options2) {
    return checkStat(fs2.statSync(path2), options2);
  }
  function checkStat(stat2, options2) {
    return stat2.isFile() && checkMode(stat2, options2);
  }
  function checkMode(stat2, options2) {
    var mod = stat2.mode, uid = stat2.uid, gid = stat2.gid, myUid = options2.uid !== void 0 ? options2.uid : process.getuid && process.getuid(), myGid = options2.gid !== void 0 ? options2.gid : process.getgid && process.getgid(), u = parseInt("100", 8), g = parseInt("010", 8), o = parseInt("001", 8), ug = u | g, ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
  return mode;
}
var isexe_1, hasRequiredIsexe;
function requireIsexe() {
  if (hasRequiredIsexe) return isexe_1;
  hasRequiredIsexe = 1;
  var core2;
  process.platform === "win32" || loadEnv.commonjsGlobal.TESTING_WINDOWS ? core2 = requireWindows() : core2 = requireMode(), isexe_1 = isexe, isexe.sync = sync2;
  function isexe(path2, options2, cb) {
    if (typeof options2 == "function" && (cb = options2, options2 = {}), !cb) {
      if (typeof Promise != "function")
        throw new TypeError("callback not provided");
      return new Promise(function(resolve, reject) {
        isexe(path2, options2 || {}, function(er, is) {
          er ? reject(er) : resolve(is);
        });
      });
    }
    core2(path2, options2 || {}, function(er, is) {
      er && (er.code === "EACCES" || options2 && options2.ignoreErrors) && (er = null, is = !1), cb(er, is);
    });
  }
  function sync2(path2, options2) {
    try {
      return core2.sync(path2, options2 || {});
    } catch (er) {
      if (options2 && options2.ignoreErrors || er.code === "EACCES")
        return !1;
      throw er;
    }
  }
  return isexe_1;
}
var which_1, hasRequiredWhich;
function requireWhich() {
  if (hasRequiredWhich) return which_1;
  hasRequiredWhich = 1;
  const isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", path2 = require$$0__default$1.default, COLON = isWindows ? ";" : ":", isexe = requireIsexe(), getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" }), getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON, pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
      // windows always checks the cwd first
      ...isWindows ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
      "").split(colon)
    ], pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", pathExt = isWindows ? pathExtExe.split(colon) : [""];
    return isWindows && cmd.indexOf(".") !== -1 && pathExt[0] !== "" && pathExt.unshift(""), {
      pathEnv,
      pathExt,
      pathExtExe
    };
  }, which2 = (cmd, opt, cb) => {
    typeof opt == "function" && (cb = opt, opt = {}), opt || (opt = {});
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt), found = [], step = (i) => new Promise((resolve, reject) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path2.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve(subStep(p, i, 0));
    }), subStep = (p, i, ii) => new Promise((resolve, reject) => {
      if (ii === pathExt.length)
        return resolve(step(i + 1));
      const ext2 = pathExt[ii];
      isexe(p + ext2, { pathExt: pathExtExe }, (er, is) => {
        if (!er && is)
          if (opt.all)
            found.push(p + ext2);
          else
            return resolve(p + ext2);
        return resolve(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  }, whichSync = (cmd, opt) => {
    opt = opt || {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt), found = [];
    for (let i = 0; i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path2.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0; j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          if (isexe.sync(cur, { pathExt: pathExtExe }))
            if (opt.all)
              found.push(cur);
            else
              return cur;
        } catch {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  return which_1 = which2, which2.sync = whichSync, which_1;
}
var pathKey = { exports: {} }, hasRequiredPathKey;
function requirePathKey() {
  if (hasRequiredPathKey) return pathKey.exports;
  hasRequiredPathKey = 1;
  const pathKey$1 = (options2 = {}) => {
    const environment = options2.env || process.env;
    return (options2.platform || process.platform) !== "win32" ? "PATH" : Object.keys(environment).reverse().find((key2) => key2.toUpperCase() === "PATH") || "Path";
  };
  return pathKey.exports = pathKey$1, pathKey.exports.default = pathKey$1, pathKey.exports;
}
var resolveCommand_1, hasRequiredResolveCommand;
function requireResolveCommand() {
  if (hasRequiredResolveCommand) return resolveCommand_1;
  hasRequiredResolveCommand = 1;
  const path2 = require$$0__default$1.default, which2 = requireWhich(), getPathKey = requirePathKey();
  function resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env, cwd = process.cwd(), hasCustomCwd = parsed.options.cwd != null, shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
    if (shouldSwitchCwd)
      try {
        process.chdir(parsed.options.cwd);
      } catch {
      }
    let resolved;
    try {
      resolved = which2.sync(parsed.command, {
        path: env[getPathKey({ env })],
        pathExt: withoutPathExt ? path2.delimiter : void 0
      });
    } catch {
    } finally {
      shouldSwitchCwd && process.chdir(cwd);
    }
    return resolved && (resolved = path2.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved)), resolved;
  }
  function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, !0);
  }
  return resolveCommand_1 = resolveCommand, resolveCommand_1;
}
var _escape = {}, hasRequired_escape;
function require_escape() {
  if (hasRequired_escape) return _escape;
  hasRequired_escape = 1;
  const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
  function escapeCommand(arg) {
    return arg = arg.replace(metaCharsRegExp, "^$1"), arg;
  }
  function escapeArgument(arg, doubleEscapeMetaChars) {
    return arg = `${arg}`, arg = arg.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"'), arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1"), arg = `"${arg}"`, arg = arg.replace(metaCharsRegExp, "^$1"), doubleEscapeMetaChars && (arg = arg.replace(metaCharsRegExp, "^$1")), arg;
  }
  return _escape.command = escapeCommand, _escape.argument = escapeArgument, _escape;
}
var shebangRegex, hasRequiredShebangRegex;
function requireShebangRegex() {
  return hasRequiredShebangRegex || (hasRequiredShebangRegex = 1, shebangRegex = /^#!(.*)/), shebangRegex;
}
var shebangCommand, hasRequiredShebangCommand;
function requireShebangCommand() {
  if (hasRequiredShebangCommand) return shebangCommand;
  hasRequiredShebangCommand = 1;
  const shebangRegex2 = requireShebangRegex();
  return shebangCommand = (string = "") => {
    const match2 = string.match(shebangRegex2);
    if (!match2)
      return null;
    const [path2, argument] = match2[0].replace(/#! ?/, "").split(" "), binary2 = path2.split("/").pop();
    return binary2 === "env" ? argument : argument ? `${binary2} ${argument}` : binary2;
  }, shebangCommand;
}
var readShebang_1, hasRequiredReadShebang;
function requireReadShebang() {
  if (hasRequiredReadShebang) return readShebang_1;
  hasRequiredReadShebang = 1;
  const fs2 = require$$0__default.default, shebangCommand2 = requireShebangCommand();
  function readShebang(command2) {
    const buffer2 = Buffer.alloc(150);
    let fd;
    try {
      fd = fs2.openSync(command2, "r"), fs2.readSync(fd, buffer2, 0, 150, 0), fs2.closeSync(fd);
    } catch {
    }
    return shebangCommand2(buffer2.toString());
  }
  return readShebang_1 = readShebang, readShebang_1;
}
var parse_1$2, hasRequiredParse$3;
function requireParse$3() {
  if (hasRequiredParse$3) return parse_1$2;
  hasRequiredParse$3 = 1;
  const path2 = require$$0__default$1.default, resolveCommand = requireResolveCommand(), escape2 = require_escape(), readShebang = requireReadShebang(), isWin = process.platform === "win32", isExecutableRegExp = /\.(?:com|exe)$/i, isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    return shebang ? (parsed.args.unshift(parsed.file), parsed.command = shebang, resolveCommand(parsed)) : parsed.file;
  }
  function parseNonShell(parsed) {
    if (!isWin)
      return parsed;
    const commandFile = detectShebang(parsed), needsShell = !isExecutableRegExp.test(commandFile);
    if (parsed.options.forceShell || needsShell) {
      const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
      parsed.command = path2.normalize(parsed.command), parsed.command = escape2.command(parsed.command), parsed.args = parsed.args.map((arg) => escape2.argument(arg, needsDoubleEscapeMetaChars));
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`], parsed.command = process.env.comspec || "cmd.exe", parsed.options.windowsVerbatimArguments = !0;
    }
    return parsed;
  }
  function parse3(command2, args, options2) {
    args && !Array.isArray(args) && (options2 = args, args = null), args = args ? args.slice(0) : [], options2 = Object.assign({}, options2);
    const parsed = {
      command: command2,
      args,
      options: options2,
      file: void 0,
      original: {
        command: command2,
        args
      }
    };
    return options2.shell ? parsed : parseNonShell(parsed);
  }
  return parse_1$2 = parse3, parse_1$2;
}
var enoent, hasRequiredEnoent;
function requireEnoent() {
  if (hasRequiredEnoent) return enoent;
  hasRequiredEnoent = 1;
  const isWin = process.platform === "win32";
  function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${syscall} ${original.command}`,
      path: original.command,
      spawnargs: original.args
    });
  }
  function hookChildProcess(cp, parsed) {
    if (!isWin)
      return;
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
      if (name === "exit") {
        const err = verifyENOENT(arg1, parsed);
        if (err)
          return originalEmit.call(cp, "error", err);
      }
      return originalEmit.apply(cp, arguments);
    };
  }
  function verifyENOENT(status, parsed) {
    return isWin && status === 1 && !parsed.file ? notFoundError(parsed.original, "spawn") : null;
  }
  function verifyENOENTSync(status, parsed) {
    return isWin && status === 1 && !parsed.file ? notFoundError(parsed.original, "spawnSync") : null;
  }
  return enoent = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
  }, enoent;
}
var hasRequiredCrossSpawn;
function requireCrossSpawn() {
  if (hasRequiredCrossSpawn) return crossSpawn.exports;
  hasRequiredCrossSpawn = 1;
  const cp = require$$1__default$2.default, parse3 = requireParse$3(), enoent2 = requireEnoent();
  function spawn(command2, args, options2) {
    const parsed = parse3(command2, args, options2), spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    return enoent2.hookChildProcess(spawned, parsed), spawned;
  }
  function spawnSync(command2, args, options2) {
    const parsed = parse3(command2, args, options2), result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    return result.error = result.error || enoent2.verifyENOENTSync(result.status, parsed), result;
  }
  return crossSpawn.exports = spawn, crossSpawn.exports.spawn = spawn, crossSpawn.exports.sync = spawnSync, crossSpawn.exports._parse = parse3, crossSpawn.exports._enoent = enoent2, crossSpawn.exports;
}
var stripFinalNewline, hasRequiredStripFinalNewline;
function requireStripFinalNewline() {
  return hasRequiredStripFinalNewline || (hasRequiredStripFinalNewline = 1, stripFinalNewline = (input2) => {
    const LF = typeof input2 == "string" ? `
` : 10, CR = typeof input2 == "string" ? "\r" : 13;
    return input2[input2.length - 1] === LF && (input2 = input2.slice(0, input2.length - 1)), input2[input2.length - 1] === CR && (input2 = input2.slice(0, input2.length - 1)), input2;
  }), stripFinalNewline;
}
var npmRunPath = { exports: {} }, hasRequiredNpmRunPath;
function requireNpmRunPath() {
  return hasRequiredNpmRunPath || (hasRequiredNpmRunPath = 1, function(module2) {
    const path2 = require$$0__default$1.default, pathKey2 = requirePathKey(), npmRunPath2 = (options2) => {
      options2 = {
        cwd: process.cwd(),
        path: process.env[pathKey2()],
        ...options2
      };
      let previous, cwdPath = path2.resolve(options2.cwd);
      const result = [];
      for (; previous !== cwdPath; )
        result.push(path2.join(cwdPath, "node_modules/.bin")), previous = cwdPath, cwdPath = path2.resolve(cwdPath, "..");
      return result.push(path2.dirname(process.execPath)), result.concat(options2.path).join(path2.delimiter);
    };
    module2.exports = npmRunPath2, module2.exports.default = npmRunPath2, module2.exports.env = (options2) => {
      options2 = {
        env: process.env,
        ...options2
      };
      const env = { ...options2.env }, path3 = pathKey2({ env });
      return options2.path = env[path3], env[path3] = module2.exports(options2), env;
    };
  }(npmRunPath)), npmRunPath.exports;
}
var onetime$2 = { exports: {} }, mimicFn$1 = { exports: {} }, hasRequiredMimicFn$1;
function requireMimicFn$1() {
  if (hasRequiredMimicFn$1) return mimicFn$1.exports;
  hasRequiredMimicFn$1 = 1;
  const mimicFn2 = (to, from2) => {
    for (const prop of Reflect.ownKeys(from2))
      Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from2, prop));
    return to;
  };
  return mimicFn$1.exports = mimicFn2, mimicFn$1.exports.default = mimicFn2, mimicFn$1.exports;
}
var hasRequiredOnetime$1;
function requireOnetime$1() {
  if (hasRequiredOnetime$1) return onetime$2.exports;
  hasRequiredOnetime$1 = 1;
  const mimicFn2 = requireMimicFn$1(), calledFunctions2 = /* @__PURE__ */ new WeakMap(), onetime2 = (function_, options2 = {}) => {
    if (typeof function_ != "function")
      throw new TypeError("Expected a function");
    let returnValue, callCount = 0;
    const functionName = function_.displayName || function_.name || "<anonymous>", onetime3 = function(...arguments_) {
      if (calledFunctions2.set(onetime3, ++callCount), callCount === 1)
        returnValue = function_.apply(this, arguments_), function_ = null;
      else if (options2.throw === !0)
        throw new Error(`Function \`${functionName}\` can only be called once`);
      return returnValue;
    };
    return mimicFn2(onetime3, function_), calledFunctions2.set(onetime3, callCount), onetime3;
  };
  return onetime$2.exports = onetime2, onetime$2.exports.default = onetime2, onetime$2.exports.callCount = (function_) => {
    if (!calledFunctions2.has(function_))
      throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
    return calledFunctions2.get(function_);
  }, onetime$2.exports;
}
var error, hasRequiredError;
function requireError() {
  if (hasRequiredError) return error;
  hasRequiredError = 1;
  const os2 = require$$0__default$2.default, util2 = require$$0__default$5.default, getCode = (error2, code) => error2 && error2.code ? [error2.code, os2.constants.errno[error2.code]] : Number.isInteger(code) ? [util2.getSystemErrorName(-code), code] : [], getErrorPrefix = ({ timedOut, timeout: timeout2, signal, exitCodeName, exitCode, isCanceled }) => timedOut ? `timed out after ${timeout2} milliseconds` : isCanceled ? "was canceled" : signal ? `was killed with ${signal}` : exitCode !== void 0 ? `failed with exit code ${exitCode} (${exitCodeName})` : "failed";
  return error = ({
    stdout,
    stderr,
    all,
    error: error2,
    signal,
    code,
    command: command2,
    timedOut,
    isCanceled,
    killed,
    parsed: { options: { timeout: timeout2 } }
  }) => {
    const [exitCodeName, exitCode] = getCode(error2, code), message = `Command ${getErrorPrefix({ timedOut, timeout: timeout2, signal, exitCodeName, exitCode, isCanceled })}: ${command2}`;
    return error2 instanceof Error ? (error2.originalMessage = error2.message, error2.message = `${message}
${error2.message}`) : error2 = new Error(message), error2.command = command2, delete error2.code, error2.exitCode = exitCode, error2.exitCodeName = exitCodeName, error2.stdout = stdout, error2.stderr = stderr, all !== void 0 && (error2.all = all), "bufferedData" in error2 && delete error2.bufferedData, error2.failed = !0, error2.timedOut = !!timedOut, error2.isCanceled = isCanceled, error2.killed = killed && !timedOut, error2.signal = signal || void 0, error2;
  }, error;
}
var stdio = { exports: {} }, hasRequiredStdio;
function requireStdio() {
  if (hasRequiredStdio) return stdio.exports;
  hasRequiredStdio = 1;
  const aliases = ["stdin", "stdout", "stderr"], hasAlias = (opts) => aliases.some((alias) => opts[alias] !== void 0), normalizeStdio = (opts) => {
    if (!opts)
      return;
    const { stdio: stdio2 } = opts;
    if (stdio2 === void 0)
      return aliases.map((alias) => opts[alias]);
    if (hasAlias(opts))
      throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
    if (typeof stdio2 == "string")
      return stdio2;
    if (!Array.isArray(stdio2))
      throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio2}\``);
    const length = Math.max(stdio2.length, aliases.length);
    return Array.from({ length }, (value, index) => stdio2[index]);
  };
  return stdio.exports = normalizeStdio, stdio.exports.node = (opts) => {
    const stdio2 = normalizeStdio(opts);
    return stdio2 === "ipc" ? "ipc" : stdio2 === void 0 || typeof stdio2 == "string" ? [stdio2, stdio2, stdio2, "ipc"] : stdio2.includes("ipc") ? stdio2 : [...stdio2, "ipc"];
  }, stdio.exports;
}
var pFinally, hasRequiredPFinally;
function requirePFinally() {
  return hasRequiredPFinally || (hasRequiredPFinally = 1, pFinally = async (promise2, onFinally = () => {
  }) => {
    let value;
    try {
      value = await promise2;
    } catch (error2) {
      throw await onFinally(), error2;
    }
    return await onFinally(), value;
  }), pFinally;
}
var kill, hasRequiredKill;
function requireKill() {
  if (hasRequiredKill) return kill;
  hasRequiredKill = 1;
  const os2 = require$$0__default$2.default, onExit2 = requireSignalExit(), pFinally2 = requirePFinally(), DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5, spawnedKill = (kill2, signal = "SIGTERM", options2 = {}) => {
    const killResult = kill2(signal);
    return setKillTimeout(kill2, signal, options2, killResult), killResult;
  }, setKillTimeout = (kill2, signal, options2, killResult) => {
    if (!shouldForceKill(signal, options2, killResult))
      return;
    const timeout2 = getForceKillAfterTimeout(options2);
    setTimeout(() => {
      kill2("SIGKILL");
    }, timeout2).unref();
  }, shouldForceKill = (signal, { forceKillAfterTimeout }, killResult) => isSigterm(signal) && forceKillAfterTimeout !== !1 && killResult, isSigterm = (signal) => signal === os2.constants.signals.SIGTERM || typeof signal == "string" && signal.toUpperCase() === "SIGTERM", getForceKillAfterTimeout = ({ forceKillAfterTimeout = !0 }) => {
    if (forceKillAfterTimeout === !0)
      return DEFAULT_FORCE_KILL_TIMEOUT;
    if (!Number.isInteger(forceKillAfterTimeout) || forceKillAfterTimeout < 0)
      throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
    return forceKillAfterTimeout;
  }, spawnedCancel = (spawned, context) => {
    spawned.kill() && (context.isCanceled = !0);
  }, timeoutKill = (spawned, signal, reject) => {
    spawned.kill(signal), reject(Object.assign(new Error("Timed out"), { timedOut: !0, signal }));
  };
  return kill = {
    spawnedKill,
    spawnedCancel,
    setupTimeout: (spawned, { timeout: timeout2, killSignal = "SIGTERM" }, spawnedPromise) => {
      if (timeout2 === 0 || timeout2 === void 0)
        return spawnedPromise;
      if (!Number.isInteger(timeout2) || timeout2 < 0)
        throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout2}\` (${typeof timeout2})`);
      let timeoutId;
      const timeoutPromise = new Promise((resolve, reject) => {
        timeoutId = setTimeout(() => {
          timeoutKill(spawned, killSignal, reject);
        }, timeout2);
      }), safeSpawnedPromise = pFinally2(spawnedPromise, () => {
        clearTimeout(timeoutId);
      });
      return Promise.race([timeoutPromise, safeSpawnedPromise]);
    },
    setExitHandler: (spawned, { cleanup, detached }, timedPromise) => {
      if (!cleanup || detached)
        return timedPromise;
      const removeExitHandler = onExit2(() => {
        spawned.kill();
      });
      return pFinally2(timedPromise, removeExitHandler);
    }
  }, kill;
}
var isStream_1, hasRequiredIsStream;
function requireIsStream() {
  if (hasRequiredIsStream) return isStream_1;
  hasRequiredIsStream = 1;
  const isStream2 = (stream2) => stream2 !== null && typeof stream2 == "object" && typeof stream2.pipe == "function";
  return isStream2.writable = (stream2) => isStream2(stream2) && stream2.writable !== !1 && typeof stream2._write == "function" && typeof stream2._writableState == "object", isStream2.readable = (stream2) => isStream2(stream2) && stream2.readable !== !1 && typeof stream2._read == "function" && typeof stream2._readableState == "object", isStream2.duplex = (stream2) => isStream2.writable(stream2) && isStream2.readable(stream2), isStream2.transform = (stream2) => isStream2.duplex(stream2) && typeof stream2._transform == "function", isStream_1 = isStream2, isStream_1;
}
var getStream = { exports: {} }, endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var once2 = requireOnce(), noop2 = function() {
  }, qnt = loadEnv.commonjsGlobal.Bare ? queueMicrotask : process.nextTick.bind(process), isRequest = function(stream2) {
    return stream2.setHeader && typeof stream2.abort == "function";
  }, isChildProcess = function(stream2) {
    return stream2.stdio && Array.isArray(stream2.stdio) && stream2.stdio.length === 3;
  }, eos = function(stream2, opts, callback) {
    if (typeof opts == "function") return eos(stream2, null, opts);
    opts || (opts = {}), callback = once2(callback || noop2);
    var ws = stream2._writableState, rs = stream2._readableState, readable = opts.readable || opts.readable !== !1 && stream2.readable, writable = opts.writable || opts.writable !== !1 && stream2.writable, cancelled = !1, onlegacyfinish = function() {
      stream2.writable || onfinish();
    }, onfinish = function() {
      writable = !1, readable || callback.call(stream2);
    }, onend = function() {
      readable = !1, writable || callback.call(stream2);
    }, onexit = function(exitCode) {
      callback.call(stream2, exitCode ? new Error("exited with error code: " + exitCode) : null);
    }, onerror = function(err) {
      callback.call(stream2, err);
    }, onclose = function() {
      qnt(onclosenexttick);
    }, onclosenexttick = function() {
      if (!cancelled) {
        if (readable && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream2, new Error("premature close"));
        if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream2, new Error("premature close"));
      }
    }, onrequest = function() {
      stream2.req.on("finish", onfinish);
    };
    return isRequest(stream2) ? (stream2.on("complete", onfinish), stream2.on("abort", onclose), stream2.req ? onrequest() : stream2.on("request", onrequest)) : writable && !ws && (stream2.on("end", onlegacyfinish), stream2.on("close", onlegacyfinish)), isChildProcess(stream2) && stream2.on("exit", onexit), stream2.on("end", onend), stream2.on("finish", onfinish), opts.error !== !1 && stream2.on("error", onerror), stream2.on("close", onclose), function() {
      cancelled = !0, stream2.removeListener("complete", onfinish), stream2.removeListener("abort", onclose), stream2.removeListener("request", onrequest), stream2.req && stream2.req.removeListener("finish", onfinish), stream2.removeListener("end", onlegacyfinish), stream2.removeListener("close", onlegacyfinish), stream2.removeListener("finish", onfinish), stream2.removeListener("exit", onexit), stream2.removeListener("end", onend), stream2.removeListener("error", onerror), stream2.removeListener("close", onclose);
    };
  };
  return endOfStream = eos, endOfStream;
}
var pump_1, hasRequiredPump;
function requirePump() {
  if (hasRequiredPump) return pump_1;
  hasRequiredPump = 1;
  var once2 = requireOnce(), eos = requireEndOfStream(), fs2;
  try {
    fs2 = require("fs");
  } catch {
  }
  var noop2 = function() {
  }, ancient = typeof process > "u" ? !1 : /^v?\.0/.test(process.version), isFn = function(fn) {
    return typeof fn == "function";
  }, isFS = function(stream2) {
    return !ancient || !fs2 ? !1 : (stream2 instanceof (fs2.ReadStream || noop2) || stream2 instanceof (fs2.WriteStream || noop2)) && isFn(stream2.close);
  }, isRequest = function(stream2) {
    return stream2.setHeader && isFn(stream2.abort);
  }, destroyer = function(stream2, reading, writing, callback) {
    callback = once2(callback);
    var closed = !1;
    stream2.on("close", function() {
      closed = !0;
    }), eos(stream2, { readable: reading, writable: writing }, function(err) {
      if (err) return callback(err);
      closed = !0, callback();
    });
    var destroyed = !1;
    return function(err) {
      if (!closed && !destroyed) {
        if (destroyed = !0, isFS(stream2)) return stream2.close(noop2);
        if (isRequest(stream2)) return stream2.abort();
        if (isFn(stream2.destroy)) return stream2.destroy();
        callback(err || new Error("stream was destroyed"));
      }
    };
  }, call = function(fn) {
    fn();
  }, pipe2 = function(from2, to) {
    return from2.pipe(to);
  }, pump = function() {
    var streams2 = Array.prototype.slice.call(arguments), callback = isFn(streams2[streams2.length - 1] || noop2) && streams2.pop() || noop2;
    if (Array.isArray(streams2[0]) && (streams2 = streams2[0]), streams2.length < 2) throw new Error("pump requires two streams per minimum");
    var error2, destroys = streams2.map(function(stream2, i) {
      var reading = i < streams2.length - 1, writing = i > 0;
      return destroyer(stream2, reading, writing, function(err) {
        error2 || (error2 = err), err && destroys.forEach(call), !reading && (destroys.forEach(call), callback(error2));
      });
    });
    return streams2.reduce(pipe2);
  };
  return pump_1 = pump, pump_1;
}
var bufferStream, hasRequiredBufferStream;
function requireBufferStream() {
  if (hasRequiredBufferStream) return bufferStream;
  hasRequiredBufferStream = 1;
  const { PassThrough: PassThroughStream } = require$$0__default$4.default;
  return bufferStream = (options2) => {
    options2 = { ...options2 };
    const { array } = options2;
    let { encoding } = options2;
    const isBuffer = encoding === "buffer";
    let objectMode = !1;
    array ? objectMode = !(encoding || isBuffer) : encoding = encoding || "utf8", isBuffer && (encoding = null);
    const stream2 = new PassThroughStream({ objectMode });
    encoding && stream2.setEncoding(encoding);
    let length = 0;
    const chunks = [];
    return stream2.on("data", (chunk) => {
      chunks.push(chunk), objectMode ? length = chunks.length : length += chunk.length;
    }), stream2.getBufferedValue = () => array ? chunks : isBuffer ? Buffer.concat(chunks, length) : chunks.join(""), stream2.getBufferedLength = () => length, stream2;
  }, bufferStream;
}
var hasRequiredGetStream;
function requireGetStream() {
  if (hasRequiredGetStream) return getStream.exports;
  hasRequiredGetStream = 1;
  const { constants: BufferConstants } = require$$0__default$9.default, pump = requirePump(), bufferStream2 = requireBufferStream();
  class MaxBufferError extends Error {
    constructor() {
      super("maxBuffer exceeded"), this.name = "MaxBufferError";
    }
  }
  async function getStream$1(inputStream, options2) {
    if (!inputStream)
      return Promise.reject(new Error("Expected a stream"));
    options2 = {
      maxBuffer: 1 / 0,
      ...options2
    };
    const { maxBuffer } = options2;
    let stream2;
    return await new Promise((resolve, reject) => {
      const rejectPromise = (error2) => {
        error2 && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH && (error2.bufferedData = stream2.getBufferedValue()), reject(error2);
      };
      stream2 = pump(inputStream, bufferStream2(options2), (error2) => {
        if (error2) {
          rejectPromise(error2);
          return;
        }
        resolve();
      }), stream2.on("data", () => {
        stream2.getBufferedLength() > maxBuffer && rejectPromise(new MaxBufferError());
      });
    }), stream2.getBufferedValue();
  }
  return getStream.exports = getStream$1, getStream.exports.default = getStream$1, getStream.exports.buffer = (stream2, options2) => getStream$1(stream2, { ...options2, encoding: "buffer" }), getStream.exports.array = (stream2, options2) => getStream$1(stream2, { ...options2, array: !0 }), getStream.exports.MaxBufferError = MaxBufferError, getStream.exports;
}
var mergeStream, hasRequiredMergeStream;
function requireMergeStream() {
  if (hasRequiredMergeStream) return mergeStream;
  hasRequiredMergeStream = 1;
  const { PassThrough } = require$$0__default$4.default;
  return mergeStream = function() {
    var sources = [], output = new PassThrough({ objectMode: !0 });
    return output.setMaxListeners(0), output.add = add, output.isEmpty = isEmpty2, output.on("unpipe", remove), Array.prototype.slice.call(arguments).forEach(add), output;
    function add(source2) {
      return Array.isArray(source2) ? (source2.forEach(add), this) : (sources.push(source2), source2.once("end", remove.bind(null, source2)), source2.once("error", output.emit.bind(output, "error")), source2.pipe(output, { end: !1 }), this);
    }
    function isEmpty2() {
      return sources.length == 0;
    }
    function remove(source2) {
      sources = sources.filter(function(it) {
        return it !== source2;
      }), !sources.length && output.readable && output.end();
    }
  }, mergeStream;
}
var stream$1, hasRequiredStream;
function requireStream() {
  if (hasRequiredStream) return stream$1;
  hasRequiredStream = 1;
  const isStream2 = requireIsStream(), getStream2 = requireGetStream(), mergeStream2 = requireMergeStream(), handleInput = (spawned, input2) => {
    input2 === void 0 || spawned.stdin === void 0 || (isStream2(input2) ? input2.pipe(spawned.stdin) : spawned.stdin.end(input2));
  }, makeAllStream = (spawned) => {
    if (!spawned.stdout && !spawned.stderr)
      return;
    const mixed = mergeStream2();
    return spawned.stdout && mixed.add(spawned.stdout), spawned.stderr && mixed.add(spawned.stderr), mixed;
  }, getBufferedData = async (stream2, streamPromise) => {
    if (stream2) {
      stream2.destroy();
      try {
        return await streamPromise;
      } catch (error2) {
        return error2.bufferedData;
      }
    }
  }, getStreamPromise = (stream2, { encoding, buffer: buffer2, maxBuffer }) => {
    if (stream2)
      return buffer2 ? encoding ? getStream2(stream2, { encoding, maxBuffer }) : getStream2.buffer(stream2, { maxBuffer }) : new Promise((resolve, reject) => {
        stream2.once("end", resolve).once("error", reject);
      });
  };
  return stream$1 = {
    handleInput,
    makeAllStream,
    getSpawnedResult: async ({ stdout, stderr, all }, { encoding, buffer: buffer2, maxBuffer }, processDone) => {
      const stdoutPromise = getStreamPromise(stdout, { encoding, buffer: buffer2, maxBuffer }), stderrPromise = getStreamPromise(stderr, { encoding, buffer: buffer2, maxBuffer }), allPromise = getStreamPromise(all, { encoding, buffer: buffer2, maxBuffer: maxBuffer * 2 });
      try {
        return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
      } catch (error2) {
        return Promise.all([
          { error: error2, code: error2.code, signal: error2.signal, timedOut: error2.timedOut },
          getBufferedData(stdout, stdoutPromise),
          getBufferedData(stderr, stderrPromise),
          getBufferedData(all, allPromise)
        ]);
      }
    },
    validateInputSync: ({ input: input2 }) => {
      if (isStream2(input2))
        throw new TypeError("The `input` option cannot be a stream in sync mode");
    }
  }, stream$1;
}
var promise, hasRequiredPromise;
function requirePromise() {
  if (hasRequiredPromise) return promise;
  hasRequiredPromise = 1;
  const mergePromiseProperty = (spawned, promise2, property) => {
    const value = typeof promise2 == "function" ? (...args) => promise2()[property](...args) : promise2[property].bind(promise2);
    Object.defineProperty(spawned, property, {
      value,
      writable: !0,
      enumerable: !1,
      configurable: !0
    });
  };
  return promise = {
    mergePromise: (spawned, promise2) => (mergePromiseProperty(spawned, promise2, "then"), mergePromiseProperty(spawned, promise2, "catch"), Promise.prototype.finally && mergePromiseProperty(spawned, promise2, "finally"), spawned),
    getSpawnedPromise: (spawned) => new Promise((resolve, reject) => {
      spawned.on("exit", (code, signal) => {
        resolve({ code, signal });
      }), spawned.on("error", (error2) => {
        reject(error2);
      }), spawned.stdin && spawned.stdin.on("error", (error2) => {
        reject(error2);
      });
    })
  }, promise;
}
var command, hasRequiredCommand;
function requireCommand() {
  if (hasRequiredCommand) return command;
  hasRequiredCommand = 1;
  const SPACES_REGEXP = / +/g, joinCommand = (file, args = []) => Array.isArray(args) ? [file, ...args].join(" ") : file, handleEscaping = (tokens, token2, index) => {
    if (index === 0)
      return [token2];
    const previousToken = tokens[tokens.length - 1];
    return previousToken.endsWith("\\") ? [...tokens.slice(0, -1), `${previousToken.slice(0, -1)} ${token2}`] : [...tokens, token2];
  };
  return command = {
    joinCommand,
    parseCommand: (command2) => command2.trim().split(SPACES_REGEXP).reduce(handleEscaping, [])
  }, command;
}
var hasRequiredExeca;
function requireExeca() {
  if (hasRequiredExeca) return execa$1.exports;
  hasRequiredExeca = 1;
  const path2 = require$$0__default$1.default, childProcess2 = require$$1__default$2.default, crossSpawn2 = requireCrossSpawn(), stripFinalNewline2 = requireStripFinalNewline(), npmRunPath2 = requireNpmRunPath(), onetime2 = requireOnetime$1(), makeError = requireError(), normalizeStdio = requireStdio(), { spawnedKill, spawnedCancel, setupTimeout, setExitHandler } = requireKill(), { handleInput, getSpawnedResult, makeAllStream, validateInputSync } = requireStream(), { mergePromise, getSpawnedPromise } = requirePromise(), { joinCommand, parseCommand } = requireCommand(), DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100, getEnv = ({ env: envOption, extendEnv, preferLocal, localDir }) => {
    const env = extendEnv ? { ...process.env, ...envOption } : envOption;
    return preferLocal ? npmRunPath2.env({ env, cwd: localDir }) : env;
  }, handleArgs = (file, args, options2 = {}) => {
    const parsed = crossSpawn2._parse(file, args, options2);
    return file = parsed.command, args = parsed.args, options2 = parsed.options, options2 = {
      maxBuffer: DEFAULT_MAX_BUFFER,
      buffer: !0,
      stripFinalNewline: !0,
      extendEnv: !0,
      preferLocal: !1,
      localDir: options2.cwd || process.cwd(),
      encoding: "utf8",
      reject: !0,
      cleanup: !0,
      ...options2,
      windowsHide: !0
    }, options2.env = getEnv(options2), options2.stdio = normalizeStdio(options2), process.platform === "win32" && path2.basename(file, ".exe") === "cmd" && args.unshift("/q"), { file, args, options: options2, parsed };
  }, handleOutput = (options2, value, error2) => typeof value != "string" && !Buffer.isBuffer(value) ? error2 === void 0 ? void 0 : "" : options2.stripFinalNewline ? stripFinalNewline2(value) : value, execa2 = (file, args, options2) => {
    const parsed = handleArgs(file, args, options2), command2 = joinCommand(file, args);
    let spawned;
    try {
      spawned = childProcess2.spawn(parsed.file, parsed.args, parsed.options);
    } catch (error2) {
      const dummySpawned = new childProcess2.ChildProcess(), errorPromise = Promise.reject(makeError({
        error: error2,
        stdout: "",
        stderr: "",
        all: "",
        command: command2,
        parsed,
        timedOut: !1,
        isCanceled: !1,
        killed: !1
      }));
      return mergePromise(dummySpawned, errorPromise);
    }
    const spawnedPromise = getSpawnedPromise(spawned), timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise), processDone = setExitHandler(spawned, parsed.options, timedPromise), context = { isCanceled: !1 };
    spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned)), spawned.cancel = spawnedCancel.bind(null, spawned, context);
    const handlePromiseOnce = onetime2(async () => {
      const [{ error: error2, code, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone), stdout = handleOutput(parsed.options, stdoutResult), stderr = handleOutput(parsed.options, stderrResult), all = handleOutput(parsed.options, allResult);
      if (error2 || code !== 0 || signal !== null) {
        const returnedError = makeError({
          error: error2,
          code,
          signal,
          stdout,
          stderr,
          all,
          command: command2,
          parsed,
          timedOut,
          isCanceled: context.isCanceled,
          killed: spawned.killed
        });
        if (!parsed.options.reject)
          return returnedError;
        throw returnedError;
      }
      return {
        command: command2,
        exitCode: 0,
        exitCodeName: "SUCCESS",
        stdout,
        stderr,
        all,
        failed: !1,
        timedOut: !1,
        isCanceled: !1,
        killed: !1
      };
    });
    return crossSpawn2._enoent.hookChildProcess(spawned, parsed.parsed), handleInput(spawned, parsed.options.input), spawned.all = makeAllStream(spawned), mergePromise(spawned, handlePromiseOnce);
  };
  return execa$1.exports = execa2, execa$1.exports.sync = (file, args, options2) => {
    const parsed = handleArgs(file, args, options2), command2 = joinCommand(file, args);
    validateInputSync(parsed.options);
    let result;
    try {
      result = childProcess2.spawnSync(parsed.file, parsed.args, parsed.options);
    } catch (error2) {
      throw makeError({
        error: error2,
        stdout: "",
        stderr: "",
        all: "",
        command: command2,
        parsed,
        timedOut: !1,
        isCanceled: !1,
        killed: !1
      });
    }
    if (result.stdout = handleOutput(parsed.options, result.stdout, result.error), result.stderr = handleOutput(parsed.options, result.stderr, result.error), result.error || result.status !== 0 || result.signal !== null) {
      const error2 = makeError({
        ...result,
        code: result.status,
        command: command2,
        parsed,
        timedOut: result.error && result.error.code === "ETIMEDOUT",
        isCanceled: !1,
        killed: result.signal !== null
      });
      if (!parsed.options.reject)
        return error2;
      throw error2;
    }
    return {
      command: command2,
      exitCode: 0,
      exitCodeName: "SUCCESS",
      stdout: result.stdout,
      stderr: result.stderr,
      failed: !1,
      timedOut: !1,
      isCanceled: !1,
      killed: !1
    };
  }, execa$1.exports.command = (command2, options2) => {
    const [file, ...args] = parseCommand(command2);
    return execa2(file, args, options2);
  }, execa$1.exports.commandSync = (command2, options2) => {
    const [file, ...args] = parseCommand(command2);
    return execa2.sync(file, args, options2);
  }, execa$1.exports.node = (scriptPath, args, options2 = {}) => {
    args && !Array.isArray(args) && typeof args == "object" && (options2 = args, args = []);
    const stdio2 = normalizeStdio.node(options2), { nodePath: nodePath2 = process.execPath, nodeOptions = process.execArgv } = options2;
    return execa2(
      nodePath2,
      [
        ...nodeOptions,
        scriptPath,
        ...Array.isArray(args) ? args : []
      ],
      {
        ...options2,
        stdin: void 0,
        stdout: void 0,
        stderr: void 0,
        stdio: stdio2,
        shell: !1
      }
    );
  }, execa$1.exports;
}
var execaExports = requireExeca(), execa = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(execaExports), indentString, hasRequiredIndentString;
function requireIndentString() {
  return hasRequiredIndentString || (hasRequiredIndentString = 1, indentString = (string, count2 = 1, options2) => {
    if (options2 = {
      indent: " ",
      includeEmptyLines: !1,
      ...options2
    }, typeof string != "string")
      throw new TypeError(
        `Expected \`input\` to be a \`string\`, got \`${typeof string}\``
      );
    if (typeof count2 != "number")
      throw new TypeError(
        `Expected \`count\` to be a \`number\`, got \`${typeof count2}\``
      );
    if (typeof options2.indent != "string")
      throw new TypeError(
        `Expected \`options.indent\` to be a \`string\`, got \`${typeof options2.indent}\``
      );
    if (count2 === 0)
      return string;
    const regex2 = options2.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
    return string.replace(regex2, options2.indent.repeat(count2));
  }), indentString;
}
var cleanStack$2, hasRequiredCleanStack$1;
function requireCleanStack$1() {
  if (hasRequiredCleanStack$1) return cleanStack$2;
  hasRequiredCleanStack$1 = 1;
  const os2 = require$$0__default$2.default, extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/, pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/, homeDir = typeof os2.homedir > "u" ? "" : os2.homedir();
  return cleanStack$2 = (stack2, options2) => (options2 = Object.assign({ pretty: !1 }, options2), stack2.replace(/\\/g, "/").split(`
`).filter((line3) => {
    const pathMatches = line3.match(extractPathRegex);
    if (pathMatches === null || !pathMatches[1])
      return !0;
    const match2 = pathMatches[1];
    return match2.includes(".app/Contents/Resources/electron.asar") || match2.includes(".app/Contents/Resources/default_app.asar") ? !1 : !pathRegex.test(match2);
  }).filter((line3) => line3.trim() !== "").map((line3) => options2.pretty ? line3.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, "~"))) : line3).join(`
`)), cleanStack$2;
}
var aggregateError, hasRequiredAggregateError;
function requireAggregateError() {
  if (hasRequiredAggregateError) return aggregateError;
  hasRequiredAggregateError = 1;
  const indentString2 = requireIndentString(), cleanStack2 = requireCleanStack$1(), cleanInternalStack = (stack2) => stack2.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");
  class AggregateError extends Error {
    constructor(errors) {
      if (!Array.isArray(errors))
        throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
      errors = [...errors].map((error2) => error2 instanceof Error ? error2 : error2 !== null && typeof error2 == "object" ? Object.assign(new Error(error2.message), error2) : new Error(error2));
      let message = errors.map((error2) => typeof error2.stack == "string" ? cleanInternalStack(cleanStack2(error2.stack)) : String(error2)).join(`
`);
      message = `
` + indentString2(message, 4), super(message), this.name = "AggregateError", Object.defineProperty(this, "_errors", { value: errors });
    }
    *[Symbol.iterator]() {
      for (const error2 of this._errors)
        yield error2;
    }
  }
  return aggregateError = AggregateError, aggregateError;
}
var pMap$1, hasRequiredPMap;
function requirePMap() {
  if (hasRequiredPMap) return pMap$1;
  hasRequiredPMap = 1;
  const AggregateError = requireAggregateError();
  return pMap$1 = async (iterable, mapper, {
    concurrency = 1 / 0,
    stopOnError = !0
  } = {}) => new Promise((resolve, reject) => {
    if (typeof mapper != "function")
      throw new TypeError("Mapper function is required");
    if (!((Number.isSafeInteger(concurrency) || concurrency === 1 / 0) && concurrency >= 1))
      throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
    const result = [], errors = [], iterator2 = iterable[Symbol.iterator]();
    let isRejected = !1, isIterableDone = !1, resolvingCount = 0, currentIndex = 0;
    const next = () => {
      if (isRejected)
        return;
      const nextItem = iterator2.next(), index = currentIndex;
      if (currentIndex++, nextItem.done) {
        isIterableDone = !0, resolvingCount === 0 && (!stopOnError && errors.length !== 0 ? reject(new AggregateError(errors)) : resolve(result));
        return;
      }
      resolvingCount++, (async () => {
        try {
          const element = await nextItem.value;
          result[index] = await mapper(element, index), resolvingCount--, next();
        } catch (error2) {
          stopOnError ? (isRejected = !0, reject(error2)) : (errors.push(error2), resolvingCount--, next());
        }
      })();
    };
    for (let i = 0; i < concurrency && (next(), !isIterableDone); i++)
      ;
  }), pMap$1;
}
var pMapExports = requirePMap(), pMap = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(pMapExports);
const CLIInitStepCompleted = telemetry.defineTrace({
  name: "CLI Init Step Completed",
  version: 1,
  description: "User completed a step in the CLI init flow"
});
var core$3 = {}, utils$2 = {}, hasRequiredUtils$2;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function(exports2) {
    exports2.isInteger = (num) => typeof num == "number" ? Number.isInteger(num) : typeof num == "string" && num.trim() !== "" ? Number.isInteger(Number(num)) : !1, exports2.find = (node, type2) => node.nodes.find((node2) => node2.type === type2), exports2.exceedsLimit = (min2, max2, step = 1, limit) => limit === !1 || !exports2.isInteger(min2) || !exports2.isInteger(max2) ? !1 : (Number(max2) - Number(min2)) / Number(step) >= limit, exports2.escapeNode = (block, n = 0, type2) => {
      const node = block.nodes[n];
      node && (type2 && node.type === type2 || node.type === "open" || node.type === "close") && node.escaped !== !0 && (node.value = "\\" + node.value, node.escaped = !0);
    }, exports2.encloseBrace = (node) => node.type !== "brace" || node.commas >> 0 + node.ranges >> 0 ? !1 : (node.invalid = !0, !0), exports2.isInvalidBrace = (block) => block.type !== "brace" ? !1 : block.invalid === !0 || block.dollar ? !0 : !(block.commas >> 0 + block.ranges >> 0) || block.open !== !0 || block.close !== !0 ? (block.invalid = !0, !0) : !1, exports2.isOpenOrClose = (node) => node.type === "open" || node.type === "close" ? !0 : node.open === !0 || node.close === !0, exports2.reduce = (nodes) => nodes.reduce((acc, node) => (node.type === "text" && acc.push(node.value), node.type === "range" && (node.type = "text"), acc), []), exports2.flatten = (...args) => {
      const result = [], flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          const ele = arr[i];
          if (Array.isArray(ele)) {
            flat(ele);
            continue;
          }
          ele !== void 0 && result.push(ele);
        }
        return result;
      };
      return flat(args), result;
    };
  }(utils$2)), utils$2;
}
var stringify, hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify;
  hasRequiredStringify = 1;
  const utils2 = requireUtils$2();
  return stringify = (ast, options2 = {}) => {
    const stringify3 = (node, parent = {}) => {
      const invalidBlock = options2.escapeInvalid && utils2.isInvalidBrace(parent), invalidNode = node.invalid === !0 && options2.escapeInvalid === !0;
      let output = "";
      if (node.value)
        return (invalidBlock || invalidNode) && utils2.isOpenOrClose(node) ? "\\" + node.value : node.value;
      if (node.value)
        return node.value;
      if (node.nodes)
        for (const child of node.nodes)
          output += stringify3(child);
      return output;
    };
    return stringify3(ast);
  }, stringify;
}
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
var isNumber, hasRequiredIsNumber;
function requireIsNumber() {
  return hasRequiredIsNumber || (hasRequiredIsNumber = 1, isNumber = function(num) {
    return typeof num == "number" ? num - num === 0 : typeof num == "string" && num.trim() !== "" ? Number.isFinite ? Number.isFinite(+num) : isFinite(+num) : !1;
  }), isNumber;
}
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
var toRegexRange_1, hasRequiredToRegexRange;
function requireToRegexRange() {
  if (hasRequiredToRegexRange) return toRegexRange_1;
  hasRequiredToRegexRange = 1;
  const isNumber2 = requireIsNumber(), toRegexRange = (min2, max2, options2) => {
    if (isNumber2(min2) === !1)
      throw new TypeError("toRegexRange: expected the first argument to be a number");
    if (max2 === void 0 || min2 === max2)
      return String(min2);
    if (isNumber2(max2) === !1)
      throw new TypeError("toRegexRange: expected the second argument to be a number.");
    let opts = { relaxZeros: !0, ...options2 };
    typeof opts.strictZeros == "boolean" && (opts.relaxZeros = opts.strictZeros === !1);
    let relax = String(opts.relaxZeros), shorthand = String(opts.shorthand), capture = String(opts.capture), wrap2 = String(opts.wrap), cacheKey = min2 + ":" + max2 + "=" + relax + shorthand + capture + wrap2;
    if (toRegexRange.cache.hasOwnProperty(cacheKey))
      return toRegexRange.cache[cacheKey].result;
    let a = Math.min(min2, max2), b = Math.max(min2, max2);
    if (Math.abs(a - b) === 1) {
      let result = min2 + "|" + max2;
      return opts.capture ? `(${result})` : opts.wrap === !1 ? result : `(?:${result})`;
    }
    let isPadded = hasPadding(min2) || hasPadding(max2), state = { min: min2, max: max2, a, b }, positives = [], negatives = [];
    if (isPadded && (state.isPadded = isPadded, state.maxLen = String(state.max).length), a < 0) {
      let newMin = b < 0 ? Math.abs(b) : 1;
      negatives = splitToPatterns(newMin, Math.abs(a), state, opts), a = state.a = 0;
    }
    return b >= 0 && (positives = splitToPatterns(a, b, state, opts)), state.negatives = negatives, state.positives = positives, state.result = collatePatterns(negatives, positives), opts.capture === !0 ? state.result = `(${state.result})` : opts.wrap !== !1 && positives.length + negatives.length > 1 && (state.result = `(?:${state.result})`), toRegexRange.cache[cacheKey] = state, state.result;
  };
  function collatePatterns(neg, pos2, options2) {
    let onlyNegative = filterPatterns(neg, pos2, "-", !1) || [], onlyPositive = filterPatterns(pos2, neg, "", !1) || [], intersected = filterPatterns(neg, pos2, "-?", !0) || [];
    return onlyNegative.concat(intersected).concat(onlyPositive).join("|");
  }
  function splitToRanges(min2, max2) {
    let nines = 1, zeros = 1, stop = countNines(min2, nines), stops = /* @__PURE__ */ new Set([max2]);
    for (; min2 <= stop && stop <= max2; )
      stops.add(stop), nines += 1, stop = countNines(min2, nines);
    for (stop = countZeros(max2 + 1, zeros) - 1; min2 < stop && stop <= max2; )
      stops.add(stop), zeros += 1, stop = countZeros(max2 + 1, zeros) - 1;
    return stops = [...stops], stops.sort(compare), stops;
  }
  function rangeToPattern(start, stop, options2) {
    if (start === stop)
      return { pattern: start, count: [], digits: 0 };
    let zipped = zip2(start, stop), digits = zipped.length, pattern = "", count2 = 0;
    for (let i = 0; i < digits; i++) {
      let [startDigit, stopDigit] = zipped[i];
      startDigit === stopDigit ? pattern += startDigit : startDigit !== "0" || stopDigit !== "9" ? pattern += toCharacterClass(startDigit, stopDigit) : count2++;
    }
    return count2 && (pattern += options2.shorthand === !0 ? "\\d" : "[0-9]"), { pattern, count: [count2], digits };
  }
  function splitToPatterns(min2, max2, tok, options2) {
    let ranges = splitToRanges(min2, max2), tokens = [], start = min2, prev;
    for (let i = 0; i < ranges.length; i++) {
      let max3 = ranges[i], obj = rangeToPattern(String(start), String(max3), options2), zeros = "";
      if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
        prev.count.length > 1 && prev.count.pop(), prev.count.push(obj.count[0]), prev.string = prev.pattern + toQuantifier(prev.count), start = max3 + 1;
        continue;
      }
      tok.isPadded && (zeros = padZeros(max3, tok, options2)), obj.string = zeros + obj.pattern + toQuantifier(obj.count), tokens.push(obj), start = max3 + 1, prev = obj;
    }
    return tokens;
  }
  function filterPatterns(arr, comparison, prefix, intersection, options2) {
    let result = [];
    for (let ele of arr) {
      let { string } = ele;
      !intersection && !contains(comparison, "string", string) && result.push(prefix + string), intersection && contains(comparison, "string", string) && result.push(prefix + string);
    }
    return result;
  }
  function zip2(a, b) {
    let arr = [];
    for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
    return arr;
  }
  function compare(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
  }
  function contains(arr, key2, val) {
    return arr.some((ele) => ele[key2] === val);
  }
  function countNines(min2, len) {
    return Number(String(min2).slice(0, -len) + "9".repeat(len));
  }
  function countZeros(integer, zeros) {
    return integer - integer % Math.pow(10, zeros);
  }
  function toQuantifier(digits) {
    let [start = 0, stop = ""] = digits;
    return stop || start > 1 ? `{${start + (stop ? "," + stop : "")}}` : "";
  }
  function toCharacterClass(a, b, options2) {
    return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
  }
  function hasPadding(str2) {
    return /^-?(0+)\d/.test(str2);
  }
  function padZeros(value, tok, options2) {
    if (!tok.isPadded)
      return value;
    let diff = Math.abs(tok.maxLen - String(value).length), relax = options2.relaxZeros !== !1;
    switch (diff) {
      case 0:
        return "";
      case 1:
        return relax ? "0?" : "0";
      case 2:
        return relax ? "0{0,2}" : "00";
      default:
        return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
  return toRegexRange.cache = {}, toRegexRange.clearCache = () => toRegexRange.cache = {}, toRegexRange_1 = toRegexRange, toRegexRange_1;
}
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var fillRange, hasRequiredFillRange;
function requireFillRange() {
  if (hasRequiredFillRange) return fillRange;
  hasRequiredFillRange = 1;
  const util2 = require$$0__default$5.default, toRegexRange = requireToRegexRange(), isObject2 = (val) => val !== null && typeof val == "object" && !Array.isArray(val), transform = (toNumber) => (value) => toNumber === !0 ? Number(value) : String(value), isValidValue = (value) => typeof value == "number" || typeof value == "string" && value !== "", isNumber2 = (num) => Number.isInteger(+num), zeros = (input2) => {
    let value = `${input2}`, index = -1;
    if (value[0] === "-" && (value = value.slice(1)), value === "0") return !1;
    for (; value[++index] === "0"; ) ;
    return index > 0;
  }, stringify3 = (start, end, options2) => typeof start == "string" || typeof end == "string" ? !0 : options2.stringify === !0, pad = (input2, maxLength, toNumber) => {
    if (maxLength > 0) {
      let dash = input2[0] === "-" ? "-" : "";
      dash && (input2 = input2.slice(1)), input2 = dash + input2.padStart(dash ? maxLength - 1 : maxLength, "0");
    }
    return toNumber === !1 ? String(input2) : input2;
  }, toMaxLen = (input2, maxLength) => {
    let negative = input2[0] === "-" ? "-" : "";
    for (negative && (input2 = input2.slice(1), maxLength--); input2.length < maxLength; ) input2 = "0" + input2;
    return negative ? "-" + input2 : input2;
  }, toSequence = (parts, options2, maxLen) => {
    parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0), parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    let prefix = options2.capture ? "" : "?:", positives = "", negatives = "", result;
    return parts.positives.length && (positives = parts.positives.map((v) => toMaxLen(String(v), maxLen)).join("|")), parts.negatives.length && (negatives = `-(${prefix}${parts.negatives.map((v) => toMaxLen(String(v), maxLen)).join("|")})`), positives && negatives ? result = `${positives}|${negatives}` : result = positives || negatives, options2.wrap ? `(${prefix}${result})` : result;
  }, toRange = (a, b, isNumbers, options2) => {
    if (isNumbers)
      return toRegexRange(a, b, { wrap: !1, ...options2 });
    let start = String.fromCharCode(a);
    if (a === b) return start;
    let stop = String.fromCharCode(b);
    return `[${start}-${stop}]`;
  }, toRegex = (start, end, options2) => {
    if (Array.isArray(start)) {
      let wrap2 = options2.wrap === !0, prefix = options2.capture ? "" : "?:";
      return wrap2 ? `(${prefix}${start.join("|")})` : start.join("|");
    }
    return toRegexRange(start, end, options2);
  }, rangeError = (...args) => new RangeError("Invalid range arguments: " + util2.inspect(...args)), invalidRange = (start, end, options2) => {
    if (options2.strictRanges === !0) throw rangeError([start, end]);
    return [];
  }, invalidStep = (step, options2) => {
    if (options2.strictRanges === !0)
      throw new TypeError(`Expected step "${step}" to be a number`);
    return [];
  }, fillNumbers = (start, end, step = 1, options2 = {}) => {
    let a = Number(start), b = Number(end);
    if (!Number.isInteger(a) || !Number.isInteger(b)) {
      if (options2.strictRanges === !0) throw rangeError([start, end]);
      return [];
    }
    a === 0 && (a = 0), b === 0 && (b = 0);
    let descending = a > b, startString = String(start), endString = String(end), stepString = String(step);
    step = Math.max(Math.abs(step), 1);
    let padded = zeros(startString) || zeros(endString) || zeros(stepString), maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0, toNumber = padded === !1 && stringify3(start, end, options2) === !1, format = options2.transform || transform(toNumber);
    if (options2.toRegex && step === 1)
      return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), !0, options2);
    let parts = { negatives: [], positives: [] }, push2 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num)), range2 = [], index = 0;
    for (; descending ? a >= b : a <= b; )
      options2.toRegex === !0 && step > 1 ? push2(a) : range2.push(pad(format(a, index), maxLen, toNumber)), a = descending ? a - step : a + step, index++;
    return options2.toRegex === !0 ? step > 1 ? toSequence(parts, options2, maxLen) : toRegex(range2, null, { wrap: !1, ...options2 }) : range2;
  }, fillLetters = (start, end, step = 1, options2 = {}) => {
    if (!isNumber2(start) && start.length > 1 || !isNumber2(end) && end.length > 1)
      return invalidRange(start, end, options2);
    let format = options2.transform || ((val) => String.fromCharCode(val)), a = `${start}`.charCodeAt(0), b = `${end}`.charCodeAt(0), descending = a > b, min2 = Math.min(a, b), max2 = Math.max(a, b);
    if (options2.toRegex && step === 1)
      return toRange(min2, max2, !1, options2);
    let range2 = [], index = 0;
    for (; descending ? a >= b : a <= b; )
      range2.push(format(a, index)), a = descending ? a - step : a + step, index++;
    return options2.toRegex === !0 ? toRegex(range2, null, { wrap: !1, options: options2 }) : range2;
  }, fill = (start, end, step, options2 = {}) => {
    if (end == null && isValidValue(start))
      return [start];
    if (!isValidValue(start) || !isValidValue(end))
      return invalidRange(start, end, options2);
    if (typeof step == "function")
      return fill(start, end, 1, { transform: step });
    if (isObject2(step))
      return fill(start, end, 0, step);
    let opts = { ...options2 };
    return opts.capture === !0 && (opts.wrap = !0), step = step || opts.step || 1, isNumber2(step) ? isNumber2(start) && isNumber2(end) ? fillNumbers(start, end, step, opts) : fillLetters(start, end, Math.max(Math.abs(step), 1), opts) : step != null && !isObject2(step) ? invalidStep(step, opts) : fill(start, end, 1, step);
  };
  return fillRange = fill, fillRange;
}
var compile_1, hasRequiredCompile;
function requireCompile() {
  if (hasRequiredCompile) return compile_1;
  hasRequiredCompile = 1;
  const fill = requireFillRange(), utils2 = requireUtils$2();
  return compile_1 = (ast, options2 = {}) => {
    const walk = (node, parent = {}) => {
      const invalidBlock = utils2.isInvalidBrace(parent), invalidNode = node.invalid === !0 && options2.escapeInvalid === !0, invalid = invalidBlock === !0 || invalidNode === !0, prefix = options2.escapeInvalid === !0 ? "\\" : "";
      let output = "";
      if (node.isOpen === !0)
        return prefix + node.value;
      if (node.isClose === !0)
        return console.log("node.isClose", prefix, node.value), prefix + node.value;
      if (node.type === "open")
        return invalid ? prefix + node.value : "(";
      if (node.type === "close")
        return invalid ? prefix + node.value : ")";
      if (node.type === "comma")
        return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
      if (node.value)
        return node.value;
      if (node.nodes && node.ranges > 0) {
        const args = utils2.reduce(node.nodes), range2 = fill(...args, { ...options2, wrap: !1, toRegex: !0, strictZeros: !0 });
        if (range2.length !== 0)
          return args.length > 1 && range2.length > 1 ? `(${range2})` : range2;
      }
      if (node.nodes)
        for (const child of node.nodes)
          output += walk(child, node);
      return output;
    };
    return walk(ast);
  }, compile_1;
}
var expand_1, hasRequiredExpand$1;
function requireExpand$1() {
  if (hasRequiredExpand$1) return expand_1;
  hasRequiredExpand$1 = 1;
  const fill = requireFillRange(), stringify3 = requireStringify(), utils2 = requireUtils$2(), append = (queue2 = "", stash = "", enclose = !1) => {
    const result = [];
    if (queue2 = [].concat(queue2), stash = [].concat(stash), !stash.length) return queue2;
    if (!queue2.length)
      return enclose ? utils2.flatten(stash).map((ele) => `{${ele}}`) : stash;
    for (const item of queue2)
      if (Array.isArray(item))
        for (const value of item)
          result.push(append(value, stash, enclose));
      else
        for (let ele of stash)
          enclose === !0 && typeof ele == "string" && (ele = `{${ele}}`), result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
    return utils2.flatten(result);
  };
  return expand_1 = (ast, options2 = {}) => {
    const rangeLimit = options2.rangeLimit === void 0 ? 1e3 : options2.rangeLimit, walk = (node, parent = {}) => {
      node.queue = [];
      let p = parent, q = parent.queue;
      for (; p.type !== "brace" && p.type !== "root" && p.parent; )
        p = p.parent, q = p.queue;
      if (node.invalid || node.dollar) {
        q.push(append(q.pop(), stringify3(node, options2)));
        return;
      }
      if (node.type === "brace" && node.invalid !== !0 && node.nodes.length === 2) {
        q.push(append(q.pop(), ["{}"]));
        return;
      }
      if (node.nodes && node.ranges > 0) {
        const args = utils2.reduce(node.nodes);
        if (utils2.exceedsLimit(...args, options2.step, rangeLimit))
          throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
        let range2 = fill(...args, options2);
        range2.length === 0 && (range2 = stringify3(node, options2)), q.push(append(q.pop(), range2)), node.nodes = [];
        return;
      }
      const enclose = utils2.encloseBrace(node);
      let queue2 = node.queue, block = node;
      for (; block.type !== "brace" && block.type !== "root" && block.parent; )
        block = block.parent, queue2 = block.queue;
      for (let i = 0; i < node.nodes.length; i++) {
        const child = node.nodes[i];
        if (child.type === "comma" && node.type === "brace") {
          i === 1 && queue2.push(""), queue2.push("");
          continue;
        }
        if (child.type === "close") {
          q.push(append(q.pop(), queue2, enclose));
          continue;
        }
        if (child.value && child.type !== "open") {
          queue2.push(append(queue2.pop(), child.value));
          continue;
        }
        child.nodes && walk(child, node);
      }
      return queue2;
    };
    return utils2.flatten(walk(ast));
  }, expand_1;
}
var constants$2, hasRequiredConstants$2;
function requireConstants$2() {
  return hasRequiredConstants$2 || (hasRequiredConstants$2 = 1, constants$2 = {
    MAX_LENGTH: 1e4,
    // Digits
    CHAR_0: "0",
    /* 0 */
    CHAR_9: "9",
    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: "A",
    /* A */
    CHAR_LOWERCASE_A: "a",
    /* a */
    CHAR_UPPERCASE_Z: "Z",
    /* Z */
    CHAR_LOWERCASE_Z: "z",
    /* z */
    CHAR_LEFT_PARENTHESES: "(",
    /* ( */
    CHAR_RIGHT_PARENTHESES: ")",
    /* ) */
    CHAR_ASTERISK: "*",
    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: "&",
    /* & */
    CHAR_AT: "@",
    /* @ */
    CHAR_BACKSLASH: "\\",
    /* \ */
    CHAR_BACKTICK: "`",
    /* ` */
    CHAR_CARRIAGE_RETURN: "\r",
    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: "^",
    /* ^ */
    CHAR_COLON: ":",
    /* : */
    CHAR_COMMA: ",",
    /* , */
    CHAR_DOLLAR: "$",
    /* . */
    CHAR_DOT: ".",
    /* . */
    CHAR_DOUBLE_QUOTE: '"',
    /* " */
    CHAR_EQUAL: "=",
    /* = */
    CHAR_EXCLAMATION_MARK: "!",
    /* ! */
    CHAR_FORM_FEED: "\f",
    /* \f */
    CHAR_FORWARD_SLASH: "/",
    /* / */
    CHAR_HASH: "#",
    /* # */
    CHAR_HYPHEN_MINUS: "-",
    /* - */
    CHAR_LEFT_ANGLE_BRACKET: "<",
    /* < */
    CHAR_LEFT_CURLY_BRACE: "{",
    /* { */
    CHAR_LEFT_SQUARE_BRACKET: "[",
    /* [ */
    CHAR_LINE_FEED: `
`,
    /* \n */
    CHAR_NO_BREAK_SPACE: "\xA0",
    /* \u00A0 */
    CHAR_PERCENT: "%",
    /* % */
    CHAR_PLUS: "+",
    /* + */
    CHAR_QUESTION_MARK: "?",
    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: ">",
    /* > */
    CHAR_RIGHT_CURLY_BRACE: "}",
    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: "]",
    /* ] */
    CHAR_SEMICOLON: ";",
    /* ; */
    CHAR_SINGLE_QUOTE: "'",
    /* ' */
    CHAR_SPACE: " ",
    /*   */
    CHAR_TAB: "	",
    /* \t */
    CHAR_UNDERSCORE: "_",
    /* _ */
    CHAR_VERTICAL_LINE: "|",
    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    /* \uFEFF */
  }), constants$2;
}
var parse_1$1, hasRequiredParse$2;
function requireParse$2() {
  if (hasRequiredParse$2) return parse_1$1;
  hasRequiredParse$2 = 1;
  const stringify3 = requireStringify(), {
    MAX_LENGTH,
    CHAR_BACKSLASH,
    /* \ */
    CHAR_BACKTICK,
    /* ` */
    CHAR_COMMA: CHAR_COMMA2,
    /* , */
    CHAR_DOT,
    /* . */
    CHAR_LEFT_PARENTHESES,
    /* ( */
    CHAR_RIGHT_PARENTHESES,
    /* ) */
    CHAR_LEFT_CURLY_BRACE,
    /* { */
    CHAR_RIGHT_CURLY_BRACE,
    /* } */
    CHAR_LEFT_SQUARE_BRACKET,
    /* [ */
    CHAR_RIGHT_SQUARE_BRACKET,
    /* ] */
    CHAR_DOUBLE_QUOTE,
    /* " */
    CHAR_SINGLE_QUOTE,
    /* ' */
    CHAR_NO_BREAK_SPACE,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE
  } = requireConstants$2();
  return parse_1$1 = (input2, options2 = {}) => {
    if (typeof input2 != "string")
      throw new TypeError("Expected a string");
    const opts = options2 || {}, max2 = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    if (input2.length > max2)
      throw new SyntaxError(`Input length (${input2.length}), exceeds max characters (${max2})`);
    const ast = { type: "root", input: input2, nodes: [] }, stack2 = [ast];
    let block = ast, prev = ast, brackets = 0;
    const length = input2.length;
    let index = 0, depth = 0, value;
    const advance = () => input2[index++], push2 = (node) => {
      if (node.type === "text" && prev.type === "dot" && (prev.type = "text"), prev && prev.type === "text" && node.type === "text") {
        prev.value += node.value;
        return;
      }
      return block.nodes.push(node), node.parent = block, node.prev = prev, prev = node, node;
    };
    for (push2({ type: "bos" }); index < length; )
      if (block = stack2[stack2.length - 1], value = advance(), !(value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE)) {
        if (value === CHAR_BACKSLASH) {
          push2({ type: "text", value: (options2.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push2({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let next;
          for (; index < length && (next = advance()); ) {
            if (value += next, next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET && (brackets--, brackets === 0))
              break;
          }
          push2({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push2({ type: "paren", nodes: [] }), stack2.push(block), push2({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push2({ type: "text", value });
            continue;
          }
          block = stack2.pop(), push2({ type: "text", value }), block = stack2[stack2.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          const open2 = value;
          let next;
          for (options2.keepQuotes !== !0 && (value = ""); index < length && (next = advance()); ) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open2) {
              options2.keepQuotes === !0 && (value += next);
              break;
            }
            value += next;
          }
          push2({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          const brace = {
            type: "brace",
            open: !0,
            close: !1,
            dollar: prev.value && prev.value.slice(-1) === "$" || block.dollar === !0,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push2(brace), stack2.push(block), push2({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push2({ type: "text", value });
            continue;
          }
          const type2 = "close";
          block = stack2.pop(), block.close = !0, push2({ type: type2, value }), depth--, block = stack2[stack2.length - 1];
          continue;
        }
        if (value === CHAR_COMMA2 && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            const open2 = block.nodes.shift();
            block.nodes = [open2, { type: "text", value: stringify3(block) }];
          }
          push2({ type: "comma", value }), block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          const siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push2({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            if (block.range = [], prev.value += value, prev.type = "range", block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = !0, block.ranges = 0, prev.type = "text";
              continue;
            }
            block.ranges++, block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            const before = siblings[siblings.length - 1];
            before.value += prev.value + value, prev = before, block.ranges--;
            continue;
          }
          push2({ type: "dot", value });
          continue;
        }
        push2({ type: "text", value });
      }
    do
      if (block = stack2.pop(), block.type !== "root") {
        block.nodes.forEach((node) => {
          node.nodes || (node.type === "open" && (node.isOpen = !0), node.type === "close" && (node.isClose = !0), node.nodes || (node.type = "text"), node.invalid = !0);
        });
        const parent = stack2[stack2.length - 1], index2 = parent.nodes.indexOf(block);
        parent.nodes.splice(index2, 1, ...block.nodes);
      }
    while (stack2.length > 0);
    return push2({ type: "eos" }), ast;
  }, parse_1$1;
}
var braces_1, hasRequiredBraces;
function requireBraces() {
  if (hasRequiredBraces) return braces_1;
  hasRequiredBraces = 1;
  const stringify3 = requireStringify(), compile = requireCompile(), expand2 = requireExpand$1(), parse3 = requireParse$2(), braces = (input2, options2 = {}) => {
    let output = [];
    if (Array.isArray(input2))
      for (const pattern of input2) {
        const result = braces.create(pattern, options2);
        Array.isArray(result) ? output.push(...result) : output.push(result);
      }
    else
      output = [].concat(braces.create(input2, options2));
    return options2 && options2.expand === !0 && options2.nodupes === !0 && (output = [...new Set(output)]), output;
  };
  return braces.parse = (input2, options2 = {}) => parse3(input2, options2), braces.stringify = (input2, options2 = {}) => stringify3(typeof input2 == "string" ? braces.parse(input2, options2) : input2, options2), braces.compile = (input2, options2 = {}) => (typeof input2 == "string" && (input2 = braces.parse(input2, options2)), compile(input2, options2)), braces.expand = (input2, options2 = {}) => {
    typeof input2 == "string" && (input2 = braces.parse(input2, options2));
    let result = expand2(input2, options2);
    return options2.noempty === !0 && (result = result.filter(Boolean)), options2.nodupes === !0 && (result = [...new Set(result)]), result;
  }, braces.create = (input2, options2 = {}) => input2 === "" || input2.length < 3 ? [input2] : options2.expand !== !0 ? braces.compile(input2, options2) : braces.expand(input2, options2), braces_1 = braces, braces_1;
}
var utils$1 = {}, constants$1, hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1) return constants$1;
  hasRequiredConstants$1 = 1;
  const path2 = require$$0__default$1.default, WIN_SLASH = "\\\\/", WIN_NO_SLASH = `[^${WIN_SLASH}]`, DOT_LITERAL = "\\.", PLUS_LITERAL = "\\+", QMARK_LITERAL = "\\?", SLASH_LITERAL = "\\/", ONE_CHAR = "(?=.)", QMARK = "[^/]", END_ANCHOR = `(?:${SLASH_LITERAL}|$)`, START_ANCHOR = `(?:^|${SLASH_LITERAL})`, DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`, NO_DOT = `(?!${DOT_LITERAL})`, NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`, NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`, NO_DOTS_SLASH = `(?!${DOTS_SLASH})`, QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`, STAR = `${QMARK}*?`, POSIX_CHARS = {
    DOT_LITERAL,
    PLUS_LITERAL,
    QMARK_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    QMARK,
    END_ANCHOR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  }, WINDOWS_CHARS = {
    ...POSIX_CHARS,
    SLASH_LITERAL: `[${WIN_SLASH}]`,
    QMARK: WIN_NO_SLASH,
    STAR: `${WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
    NO_DOT: `(?!${DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
    END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
  }, POSIX_REGEX_SOURCE = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  return constants$1 = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    // Digits
    CHAR_0: 48,
    /* 0 */
    CHAR_9: 57,
    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: 65,
    /* A */
    CHAR_LOWERCASE_A: 97,
    /* a */
    CHAR_UPPERCASE_Z: 90,
    /* Z */
    CHAR_LOWERCASE_Z: 122,
    /* z */
    CHAR_LEFT_PARENTHESES: 40,
    /* ( */
    CHAR_RIGHT_PARENTHESES: 41,
    /* ) */
    CHAR_ASTERISK: 42,
    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,
    /* & */
    CHAR_AT: 64,
    /* @ */
    CHAR_BACKWARD_SLASH: 92,
    /* \ */
    CHAR_CARRIAGE_RETURN: 13,
    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: 94,
    /* ^ */
    CHAR_COLON: 58,
    /* : */
    CHAR_COMMA: 44,
    /* , */
    CHAR_DOT: 46,
    /* . */
    CHAR_DOUBLE_QUOTE: 34,
    /* " */
    CHAR_EQUAL: 61,
    /* = */
    CHAR_EXCLAMATION_MARK: 33,
    /* ! */
    CHAR_FORM_FEED: 12,
    /* \f */
    CHAR_FORWARD_SLASH: 47,
    /* / */
    CHAR_GRAVE_ACCENT: 96,
    /* ` */
    CHAR_HASH: 35,
    /* # */
    CHAR_HYPHEN_MINUS: 45,
    /* - */
    CHAR_LEFT_ANGLE_BRACKET: 60,
    /* < */
    CHAR_LEFT_CURLY_BRACE: 123,
    /* { */
    CHAR_LEFT_SQUARE_BRACKET: 91,
    /* [ */
    CHAR_LINE_FEED: 10,
    /* \n */
    CHAR_NO_BREAK_SPACE: 160,
    /* \u00A0 */
    CHAR_PERCENT: 37,
    /* % */
    CHAR_PLUS: 43,
    /* + */
    CHAR_QUESTION_MARK: 63,
    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    /* > */
    CHAR_RIGHT_CURLY_BRACE: 125,
    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    /* ] */
    CHAR_SEMICOLON: 59,
    /* ; */
    CHAR_SINGLE_QUOTE: 39,
    /* ' */
    CHAR_SPACE: 32,
    /*   */
    CHAR_TAB: 9,
    /* \t */
    CHAR_UNDERSCORE: 95,
    /* _ */
    CHAR_VERTICAL_LINE: 124,
    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    /* \uFEFF */
    SEP: path2.sep,
    /**
     * Create EXTGLOB_CHARS
     */
    extglobChars(chars) {
      return {
        "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
        "?": { type: "qmark", open: "(?:", close: ")?" },
        "+": { type: "plus", open: "(?:", close: ")+" },
        "*": { type: "star", open: "(?:", close: ")*" },
        "@": { type: "at", open: "(?:", close: ")" }
      };
    },
    /**
     * Create GLOB_CHARS
     */
    globChars(win32) {
      return win32 === !0 ? WINDOWS_CHARS : POSIX_CHARS;
    }
  }, constants$1;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(exports2) {
    const path2 = require$$0__default$1.default, win32 = process.platform === "win32", {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = requireConstants$1();
    exports2.isObject = (val) => val !== null && typeof val == "object" && !Array.isArray(val), exports2.hasRegexChars = (str2) => REGEX_SPECIAL_CHARS.test(str2), exports2.isRegexChar = (str2) => str2.length === 1 && exports2.hasRegexChars(str2), exports2.escapeRegex = (str2) => str2.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1"), exports2.toPosixSlashes = (str2) => str2.replace(REGEX_BACKSLASH, "/"), exports2.removeBackslashes = (str2) => str2.replace(REGEX_REMOVE_BACKSLASH, (match2) => match2 === "\\" ? "" : match2), exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      return segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10;
    }, exports2.isWindows = (options2) => options2 && typeof options2.windows == "boolean" ? options2.windows : win32 === !0 || path2.sep === "\\", exports2.escapeLast = (input2, char, lastIdx) => {
      const idx = input2.lastIndexOf(char, lastIdx);
      return idx === -1 ? input2 : input2[idx - 1] === "\\" ? exports2.escapeLast(input2, char, idx - 1) : `${input2.slice(0, idx)}\\${input2.slice(idx)}`;
    }, exports2.removePrefix = (input2, state = {}) => {
      let output = input2;
      return output.startsWith("./") && (output = output.slice(2), state.prefix = "./"), output;
    }, exports2.wrapOutput = (input2, state = {}, options2 = {}) => {
      const prepend = options2.contains ? "" : "^", append = options2.contains ? "" : "$";
      let output = `${prepend}(?:${input2})${append}`;
      return state.negated === !0 && (output = `(?:^(?!${output}).*$)`), output;
    };
  }(utils$1)), utils$1;
}
var scan_1, hasRequiredScan;
function requireScan() {
  if (hasRequiredScan) return scan_1;
  hasRequiredScan = 1;
  const utils2 = requireUtils$1(), {
    CHAR_ASTERISK,
    /* * */
    CHAR_AT,
    /* @ */
    CHAR_BACKWARD_SLASH,
    /* \ */
    CHAR_COMMA: CHAR_COMMA2,
    /* , */
    CHAR_DOT,
    /* . */
    CHAR_EXCLAMATION_MARK,
    /* ! */
    CHAR_FORWARD_SLASH,
    /* / */
    CHAR_LEFT_CURLY_BRACE,
    /* { */
    CHAR_LEFT_PARENTHESES,
    /* ( */
    CHAR_LEFT_SQUARE_BRACKET,
    /* [ */
    CHAR_PLUS: CHAR_PLUS2,
    /* + */
    CHAR_QUESTION_MARK,
    /* ? */
    CHAR_RIGHT_CURLY_BRACE,
    /* } */
    CHAR_RIGHT_PARENTHESES,
    /* ) */
    CHAR_RIGHT_SQUARE_BRACKET
    /* ] */
  } = requireConstants$1(), isPathSeparator = (code) => code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH, depth = (token2) => {
    token2.isPrefix !== !0 && (token2.depth = token2.isGlobstar ? 1 / 0 : 1);
  };
  return scan_1 = (input2, options2) => {
    const opts = options2 || {}, length = input2.length - 1, scanToEnd = opts.parts === !0 || opts.scanToEnd === !0, slashes = [], tokens = [], parts = [];
    let str2 = input2, index = -1, start = 0, lastIndex = 0, isBrace = !1, isBracket = !1, isGlob = !1, isExtglob = !1, isGlobstar = !1, braceEscaped = !1, backslashes = !1, negated = !1, negatedExtglob = !1, finished = !1, braces = 0, prev, code, token2 = { value: "", depth: 0, isGlob: !1 };
    const eos = () => index >= length, peek2 = () => str2.charCodeAt(index + 1), advance = () => (prev = code, str2.charCodeAt(++index));
    for (; index < length; ) {
      code = advance();
      let next;
      if (code === CHAR_BACKWARD_SLASH) {
        backslashes = token2.backslashes = !0, code = advance(), code === CHAR_LEFT_CURLY_BRACE && (braceEscaped = !0);
        continue;
      }
      if (braceEscaped === !0 || code === CHAR_LEFT_CURLY_BRACE) {
        for (braces++; eos() !== !0 && (code = advance()); ) {
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token2.backslashes = !0, advance();
            continue;
          }
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            continue;
          }
          if (braceEscaped !== !0 && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
            if (isBrace = token2.isBrace = !0, isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
              continue;
            break;
          }
          if (braceEscaped !== !0 && code === CHAR_COMMA2) {
            if (isBrace = token2.isBrace = !0, isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
              continue;
            break;
          }
          if (code === CHAR_RIGHT_CURLY_BRACE && (braces--, braces === 0)) {
            braceEscaped = !1, isBrace = token2.isBrace = !0, finished = !0;
            break;
          }
        }
        if (scanToEnd === !0)
          continue;
        break;
      }
      if (code === CHAR_FORWARD_SLASH) {
        if (slashes.push(index), tokens.push(token2), token2 = { value: "", depth: 0, isGlob: !1 }, finished === !0) continue;
        if (prev === CHAR_DOT && index === start + 1) {
          start += 2;
          continue;
        }
        lastIndex = index + 1;
        continue;
      }
      if (opts.noext !== !0 && (code === CHAR_PLUS2 || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK) === !0 && peek2() === CHAR_LEFT_PARENTHESES) {
        if (isGlob = token2.isGlob = !0, isExtglob = token2.isExtglob = !0, finished = !0, code === CHAR_EXCLAMATION_MARK && index === start && (negatedExtglob = !0), scanToEnd === !0) {
          for (; eos() !== !0 && (code = advance()); ) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = !0, code = advance();
              continue;
            }
            if (code === CHAR_RIGHT_PARENTHESES) {
              isGlob = token2.isGlob = !0, finished = !0;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (code === CHAR_ASTERISK) {
        if (prev === CHAR_ASTERISK && (isGlobstar = token2.isGlobstar = !0), isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
          continue;
        break;
      }
      if (code === CHAR_QUESTION_MARK) {
        if (isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
          continue;
        break;
      }
      if (code === CHAR_LEFT_SQUARE_BRACKET) {
        for (; eos() !== !0 && (next = advance()); ) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = token2.backslashes = !0, advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            isBracket = token2.isBracket = !0, isGlob = token2.isGlob = !0, finished = !0;
            break;
          }
        }
        if (scanToEnd === !0)
          continue;
        break;
      }
      if (opts.nonegate !== !0 && code === CHAR_EXCLAMATION_MARK && index === start) {
        negated = token2.negated = !0, start++;
        continue;
      }
      if (opts.noparen !== !0 && code === CHAR_LEFT_PARENTHESES) {
        if (isGlob = token2.isGlob = !0, scanToEnd === !0) {
          for (; eos() !== !0 && (code = advance()); ) {
            if (code === CHAR_LEFT_PARENTHESES) {
              backslashes = token2.backslashes = !0, code = advance();
              continue;
            }
            if (code === CHAR_RIGHT_PARENTHESES) {
              finished = !0;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (isGlob === !0) {
        if (finished = !0, scanToEnd === !0)
          continue;
        break;
      }
    }
    opts.noext === !0 && (isExtglob = !1, isGlob = !1);
    let base2 = str2, prefix = "", glob2 = "";
    start > 0 && (prefix = str2.slice(0, start), str2 = str2.slice(start), lastIndex -= start), base2 && isGlob === !0 && lastIndex > 0 ? (base2 = str2.slice(0, lastIndex), glob2 = str2.slice(lastIndex)) : isGlob === !0 ? (base2 = "", glob2 = str2) : base2 = str2, base2 && base2 !== "" && base2 !== "/" && base2 !== str2 && isPathSeparator(base2.charCodeAt(base2.length - 1)) && (base2 = base2.slice(0, -1)), opts.unescape === !0 && (glob2 && (glob2 = utils2.removeBackslashes(glob2)), base2 && backslashes === !0 && (base2 = utils2.removeBackslashes(base2)));
    const state = {
      prefix,
      input: input2,
      start,
      base: base2,
      glob: glob2,
      isBrace,
      isBracket,
      isGlob,
      isExtglob,
      isGlobstar,
      negated,
      negatedExtglob
    };
    if (opts.tokens === !0 && (state.maxDepth = 0, isPathSeparator(code) || tokens.push(token2), state.tokens = tokens), opts.parts === !0 || opts.tokens === !0) {
      let prevIndex;
      for (let idx = 0; idx < slashes.length; idx++) {
        const n = prevIndex ? prevIndex + 1 : start, i = slashes[idx], value = input2.slice(n, i);
        opts.tokens && (idx === 0 && start !== 0 ? (tokens[idx].isPrefix = !0, tokens[idx].value = prefix) : tokens[idx].value = value, depth(tokens[idx]), state.maxDepth += tokens[idx].depth), (idx !== 0 || value !== "") && parts.push(value), prevIndex = i;
      }
      if (prevIndex && prevIndex + 1 < input2.length) {
        const value = input2.slice(prevIndex + 1);
        parts.push(value), opts.tokens && (tokens[tokens.length - 1].value = value, depth(tokens[tokens.length - 1]), state.maxDepth += tokens[tokens.length - 1].depth);
      }
      state.slashes = slashes, state.parts = parts;
    }
    return state;
  }, scan_1;
}
var parse_1, hasRequiredParse$1;
function requireParse$1() {
  if (hasRequiredParse$1) return parse_1;
  hasRequiredParse$1 = 1;
  const constants2 = requireConstants$1(), utils2 = requireUtils$1(), {
    MAX_LENGTH,
    POSIX_REGEX_SOURCE,
    REGEX_NON_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_BACKREF,
    REPLACEMENTS
  } = constants2, expandRange = (args, options2) => {
    if (typeof options2.expandRange == "function")
      return options2.expandRange(...args, options2);
    args.sort();
    const value = `[${args.join("-")}]`;
    try {
      new RegExp(value);
    } catch {
      return args.map((v) => utils2.escapeRegex(v)).join("..");
    }
    return value;
  }, syntaxError2 = (type2, char) => `Missing ${type2}: "${char}" - use "\\\\${char}" to match literal characters`, parse3 = (input2, options2) => {
    if (typeof input2 != "string")
      throw new TypeError("Expected a string");
    input2 = REPLACEMENTS[input2] || input2;
    const opts = { ...options2 }, max2 = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    let len = input2.length;
    if (len > max2)
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
    const bos = { type: "bos", value: "", output: opts.prepend || "" }, tokens = [bos], capture = opts.capture ? "" : "?:", win32 = utils2.isWindows(options2), PLATFORM_CHARS = constants2.globChars(win32), EXTGLOB_CHARS = constants2.extglobChars(PLATFORM_CHARS), {
      DOT_LITERAL,
      PLUS_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    } = PLATFORM_CHARS, globstar = (opts2) => `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`, nodot = opts.dot ? "" : NO_DOT, qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star3 = opts.bash === !0 ? globstar(opts) : STAR;
    opts.capture && (star3 = `(${star3})`), typeof opts.noext == "boolean" && (opts.noextglob = opts.noext);
    const state = {
      input: input2,
      index: -1,
      start: 0,
      dot: opts.dot === !0,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: !1,
      negated: !1,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: !1,
      tokens
    };
    input2 = utils2.removePrefix(input2, state), len = input2.length;
    const extglobs = [], braces = [], stack2 = [];
    let prev = bos, value;
    const eos = () => state.index === len - 1, peek2 = state.peek = (n = 1) => input2[state.index + n], advance = state.advance = () => input2[++state.index] || "", remaining = () => input2.slice(state.index + 1), consume = (value2 = "", num = 0) => {
      state.consumed += value2, state.index += num;
    }, append = (token2) => {
      state.output += token2.output != null ? token2.output : token2.value, consume(token2.value);
    }, negate = () => {
      let count2 = 1;
      for (; peek2() === "!" && (peek2(2) !== "(" || peek2(3) === "?"); )
        advance(), state.start++, count2++;
      return count2 % 2 === 0 ? !1 : (state.negated = !0, state.start++, !0);
    }, increment = (type2) => {
      state[type2]++, stack2.push(type2);
    }, decrement = (type2) => {
      state[type2]--, stack2.pop();
    }, push2 = (tok) => {
      if (prev.type === "globstar") {
        const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace"), isExtglob = tok.extglob === !0 || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
        tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob && (state.output = state.output.slice(0, -prev.output.length), prev.type = "star", prev.value = "*", prev.output = star3, state.output += prev.output);
      }
      if (extglobs.length && tok.type !== "paren" && (extglobs[extglobs.length - 1].inner += tok.value), (tok.value || tok.output) && append(tok), prev && prev.type === "text" && tok.type === "text") {
        prev.value += tok.value, prev.output = (prev.output || "") + tok.value;
        return;
      }
      tok.prev = prev, tokens.push(tok), prev = tok;
    }, extglobOpen = (type2, value2) => {
      const token2 = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
      token2.prev = prev, token2.parens = state.parens, token2.output = state.output;
      const output = (opts.capture ? "(" : "") + token2.open;
      increment("parens"), push2({ type: type2, value: value2, output: state.output ? "" : ONE_CHAR }), push2({ type: "paren", extglob: !0, value: advance(), output }), extglobs.push(token2);
    }, extglobClose = (token2) => {
      let output = token2.close + (opts.capture ? ")" : ""), rest;
      if (token2.type === "negate") {
        let extglobStar = star3;
        if (token2.inner && token2.inner.length > 1 && token2.inner.includes("/") && (extglobStar = globstar(opts)), (extglobStar !== star3 || eos() || /^\)+$/.test(remaining())) && (output = token2.close = `)$))${extglobStar}`), token2.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
          const expression = parse3(rest, { ...options2, fastpaths: !1 }).output;
          output = token2.close = `)${expression})${extglobStar})`;
        }
        token2.prev.type === "bos" && (state.negatedExtglob = !0);
      }
      push2({ type: "paren", extglob: !0, value, output }), decrement("parens");
    };
    if (opts.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(input2)) {
      let backslashes = !1, output = input2.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first2, rest, index) => first2 === "\\" ? (backslashes = !0, m) : first2 === "?" ? esc ? esc + first2 + (rest ? QMARK.repeat(rest.length) : "") : index === 0 ? qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "") : QMARK.repeat(chars.length) : first2 === "." ? DOT_LITERAL.repeat(chars.length) : first2 === "*" ? esc ? esc + first2 + (rest ? star3 : "") : star3 : esc ? m : `\\${m}`);
      return backslashes === !0 && (opts.unescape === !0 ? output = output.replace(/\\/g, "") : output = output.replace(/\\+/g, (m) => m.length % 2 === 0 ? "\\\\" : m ? "\\" : "")), output === input2 && opts.contains === !0 ? (state.output = input2, state) : (state.output = utils2.wrapOutput(output, state, options2), state);
    }
    for (; !eos(); ) {
      if (value = advance(), value === "\0")
        continue;
      if (value === "\\") {
        const next = peek2();
        if (next === "/" && opts.bash !== !0 || next === "." || next === ";")
          continue;
        if (!next) {
          value += "\\", push2({ type: "text", value });
          continue;
        }
        const match2 = /^\\+/.exec(remaining());
        let slashes = 0;
        if (match2 && match2[0].length > 2 && (slashes = match2[0].length, state.index += slashes, slashes % 2 !== 0 && (value += "\\")), opts.unescape === !0 ? value = advance() : value += advance(), state.brackets === 0) {
          push2({ type: "text", value });
          continue;
        }
      }
      if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
        if (opts.posix !== !1 && value === ":") {
          const inner = prev.value.slice(1);
          if (inner.includes("[") && (prev.posix = !0, inner.includes(":"))) {
            const idx = prev.value.lastIndexOf("["), pre = prev.value.slice(0, idx), rest2 = prev.value.slice(idx + 2), posix2 = POSIX_REGEX_SOURCE[rest2];
            if (posix2) {
              prev.value = pre + posix2, state.backtrack = !0, advance(), !bos.output && tokens.indexOf(prev) === 1 && (bos.output = ONE_CHAR);
              continue;
            }
          }
        }
        (value === "[" && peek2() !== ":" || value === "-" && peek2() === "]") && (value = `\\${value}`), value === "]" && (prev.value === "[" || prev.value === "[^") && (value = `\\${value}`), opts.posix === !0 && value === "!" && prev.value === "[" && (value = "^"), prev.value += value, append({ value });
        continue;
      }
      if (state.quotes === 1 && value !== '"') {
        value = utils2.escapeRegex(value), prev.value += value, append({ value });
        continue;
      }
      if (value === '"') {
        state.quotes = state.quotes === 1 ? 0 : 1, opts.keepQuotes === !0 && push2({ type: "text", value });
        continue;
      }
      if (value === "(") {
        increment("parens"), push2({ type: "paren", value });
        continue;
      }
      if (value === ")") {
        if (state.parens === 0 && opts.strictBrackets === !0)
          throw new SyntaxError(syntaxError2("opening", "("));
        const extglob = extglobs[extglobs.length - 1];
        if (extglob && state.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }
        push2({ type: "paren", value, output: state.parens ? ")" : "\\)" }), decrement("parens");
        continue;
      }
      if (value === "[") {
        if (opts.nobracket === !0 || !remaining().includes("]")) {
          if (opts.nobracket !== !0 && opts.strictBrackets === !0)
            throw new SyntaxError(syntaxError2("closing", "]"));
          value = `\\${value}`;
        } else
          increment("brackets");
        push2({ type: "bracket", value });
        continue;
      }
      if (value === "]") {
        if (opts.nobracket === !0 || prev && prev.type === "bracket" && prev.value.length === 1) {
          push2({ type: "text", value, output: `\\${value}` });
          continue;
        }
        if (state.brackets === 0) {
          if (opts.strictBrackets === !0)
            throw new SyntaxError(syntaxError2("opening", "["));
          push2({ type: "text", value, output: `\\${value}` });
          continue;
        }
        decrement("brackets");
        const prevValue = prev.value.slice(1);
        if (prev.posix !== !0 && prevValue[0] === "^" && !prevValue.includes("/") && (value = `/${value}`), prev.value += value, append({ value }), opts.literalBrackets === !1 || utils2.hasRegexChars(prevValue))
          continue;
        const escaped = utils2.escapeRegex(prev.value);
        if (state.output = state.output.slice(0, -prev.value.length), opts.literalBrackets === !0) {
          state.output += escaped, prev.value = escaped;
          continue;
        }
        prev.value = `(${capture}${escaped}|${prev.value})`, state.output += prev.value;
        continue;
      }
      if (value === "{" && opts.nobrace !== !0) {
        increment("braces");
        const open2 = {
          type: "brace",
          value,
          output: "(",
          outputIndex: state.output.length,
          tokensIndex: state.tokens.length
        };
        braces.push(open2), push2(open2);
        continue;
      }
      if (value === "}") {
        const brace = braces[braces.length - 1];
        if (opts.nobrace === !0 || !brace) {
          push2({ type: "text", value, output: value });
          continue;
        }
        let output = ")";
        if (brace.dots === !0) {
          const arr = tokens.slice(), range2 = [];
          for (let i = arr.length - 1; i >= 0 && (tokens.pop(), arr[i].type !== "brace"); i--)
            arr[i].type !== "dots" && range2.unshift(arr[i].value);
          output = expandRange(range2, opts), state.backtrack = !0;
        }
        if (brace.comma !== !0 && brace.dots !== !0) {
          const out = state.output.slice(0, brace.outputIndex), toks = state.tokens.slice(brace.tokensIndex);
          brace.value = brace.output = "\\{", value = output = "\\}", state.output = out;
          for (const t of toks)
            state.output += t.output || t.value;
        }
        push2({ type: "brace", value, output }), decrement("braces"), braces.pop();
        continue;
      }
      if (value === "|") {
        extglobs.length > 0 && extglobs[extglobs.length - 1].conditions++, push2({ type: "text", value });
        continue;
      }
      if (value === ",") {
        let output = value;
        const brace = braces[braces.length - 1];
        brace && stack2[stack2.length - 1] === "braces" && (brace.comma = !0, output = "|"), push2({ type: "comma", value, output });
        continue;
      }
      if (value === "/") {
        if (prev.type === "dot" && state.index === state.start + 1) {
          state.start = state.index + 1, state.consumed = "", state.output = "", tokens.pop(), prev = bos;
          continue;
        }
        push2({ type: "slash", value, output: SLASH_LITERAL });
        continue;
      }
      if (value === ".") {
        if (state.braces > 0 && prev.type === "dot") {
          prev.value === "." && (prev.output = DOT_LITERAL);
          const brace = braces[braces.length - 1];
          prev.type = "dots", prev.output += value, prev.value += value, brace.dots = !0;
          continue;
        }
        if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
          push2({ type: "text", value, output: DOT_LITERAL });
          continue;
        }
        push2({ type: "dot", value, output: DOT_LITERAL });
        continue;
      }
      if (value === "?") {
        if (!(prev && prev.value === "(") && opts.noextglob !== !0 && peek2() === "(" && peek2(2) !== "?") {
          extglobOpen("qmark", value);
          continue;
        }
        if (prev && prev.type === "paren") {
          const next = peek2();
          let output = value;
          if (next === "<" && !utils2.supportsLookbehinds())
            throw new Error("Node.js v10 or higher is required for regex lookbehinds");
          (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) && (output = `\\${value}`), push2({ type: "text", value, output });
          continue;
        }
        if (opts.dot !== !0 && (prev.type === "slash" || prev.type === "bos")) {
          push2({ type: "qmark", value, output: QMARK_NO_DOT });
          continue;
        }
        push2({ type: "qmark", value, output: QMARK });
        continue;
      }
      if (value === "!") {
        if (opts.noextglob !== !0 && peek2() === "(" && (peek2(2) !== "?" || !/[!=<:]/.test(peek2(3)))) {
          extglobOpen("negate", value);
          continue;
        }
        if (opts.nonegate !== !0 && state.index === 0) {
          negate();
          continue;
        }
      }
      if (value === "+") {
        if (opts.noextglob !== !0 && peek2() === "(" && peek2(2) !== "?") {
          extglobOpen("plus", value);
          continue;
        }
        if (prev && prev.value === "(" || opts.regex === !1) {
          push2({ type: "plus", value, output: PLUS_LITERAL });
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
          push2({ type: "plus", value });
          continue;
        }
        push2({ type: "plus", value: PLUS_LITERAL });
        continue;
      }
      if (value === "@") {
        if (opts.noextglob !== !0 && peek2() === "(" && peek2(2) !== "?") {
          push2({ type: "at", extglob: !0, value, output: "" });
          continue;
        }
        push2({ type: "text", value });
        continue;
      }
      if (value !== "*") {
        (value === "$" || value === "^") && (value = `\\${value}`);
        const match2 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
        match2 && (value += match2[0], state.index += match2[0].length), push2({ type: "text", value });
        continue;
      }
      if (prev && (prev.type === "globstar" || prev.star === !0)) {
        prev.type = "star", prev.star = !0, prev.value += value, prev.output = star3, state.backtrack = !0, state.globstar = !0, consume(value);
        continue;
      }
      let rest = remaining();
      if (opts.noextglob !== !0 && /^\([^?]/.test(rest)) {
        extglobOpen("star", value);
        continue;
      }
      if (prev.type === "star") {
        if (opts.noglobstar === !0) {
          consume(value);
          continue;
        }
        const prior = prev.prev, before = prior.prev, isStart = prior.type === "slash" || prior.type === "bos", afterStar = before && (before.type === "star" || before.type === "globstar");
        if (opts.bash === !0 && (!isStart || rest[0] && rest[0] !== "/")) {
          push2({ type: "star", value, output: "" });
          continue;
        }
        const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace"), isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
        if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
          push2({ type: "star", value, output: "" });
          continue;
        }
        for (; rest.slice(0, 3) === "/**"; ) {
          const after = input2[state.index + 4];
          if (after && after !== "/")
            break;
          rest = rest.slice(3), consume("/**", 3);
        }
        if (prior.type === "bos" && eos()) {
          prev.type = "globstar", prev.value += value, prev.output = globstar(opts), state.output = prev.output, state.globstar = !0, consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
          state.output = state.output.slice(0, -(prior.output + prev.output).length), prior.output = `(?:${prior.output}`, prev.type = "globstar", prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)"), prev.value += value, state.globstar = !0, state.output += prior.output + prev.output, consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
          const end = rest[1] !== void 0 ? "|$" : "";
          state.output = state.output.slice(0, -(prior.output + prev.output).length), prior.output = `(?:${prior.output}`, prev.type = "globstar", prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`, prev.value += value, state.output += prior.output + prev.output, state.globstar = !0, consume(value + advance()), push2({ type: "slash", value: "/", output: "" });
          continue;
        }
        if (prior.type === "bos" && rest[0] === "/") {
          prev.type = "globstar", prev.value += value, prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`, state.output = prev.output, state.globstar = !0, consume(value + advance()), push2({ type: "slash", value: "/", output: "" });
          continue;
        }
        state.output = state.output.slice(0, -prev.output.length), prev.type = "globstar", prev.output = globstar(opts), prev.value += value, state.output += prev.output, state.globstar = !0, consume(value);
        continue;
      }
      const token2 = { type: "star", value, output: star3 };
      if (opts.bash === !0) {
        token2.output = ".*?", (prev.type === "bos" || prev.type === "slash") && (token2.output = nodot + token2.output), push2(token2);
        continue;
      }
      if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === !0) {
        token2.output = value, push2(token2);
        continue;
      }
      (state.index === state.start || prev.type === "slash" || prev.type === "dot") && (prev.type === "dot" ? (state.output += NO_DOT_SLASH, prev.output += NO_DOT_SLASH) : opts.dot === !0 ? (state.output += NO_DOTS_SLASH, prev.output += NO_DOTS_SLASH) : (state.output += nodot, prev.output += nodot), peek2() !== "*" && (state.output += ONE_CHAR, prev.output += ONE_CHAR)), push2(token2);
    }
    for (; state.brackets > 0; ) {
      if (opts.strictBrackets === !0) throw new SyntaxError(syntaxError2("closing", "]"));
      state.output = utils2.escapeLast(state.output, "["), decrement("brackets");
    }
    for (; state.parens > 0; ) {
      if (opts.strictBrackets === !0) throw new SyntaxError(syntaxError2("closing", ")"));
      state.output = utils2.escapeLast(state.output, "("), decrement("parens");
    }
    for (; state.braces > 0; ) {
      if (opts.strictBrackets === !0) throw new SyntaxError(syntaxError2("closing", "}"));
      state.output = utils2.escapeLast(state.output, "{"), decrement("braces");
    }
    if (opts.strictSlashes !== !0 && (prev.type === "star" || prev.type === "bracket") && push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` }), state.backtrack === !0) {
      state.output = "";
      for (const token2 of state.tokens)
        state.output += token2.output != null ? token2.output : token2.value, token2.suffix && (state.output += token2.suffix);
    }
    return state;
  };
  return parse3.fastpaths = (input2, options2) => {
    const opts = { ...options2 }, max2 = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH, len = input2.length;
    if (len > max2)
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
    input2 = REPLACEMENTS[input2] || input2;
    const win32 = utils2.isWindows(options2), {
      DOT_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOTS_SLASH,
      STAR,
      START_ANCHOR
    } = constants2.globChars(win32), nodot = opts.dot ? NO_DOTS : NO_DOT, slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT, capture = opts.capture ? "" : "?:", state = { negated: !1, prefix: "" };
    let star3 = opts.bash === !0 ? ".*?" : STAR;
    opts.capture && (star3 = `(${star3})`);
    const globstar = (opts2) => opts2.noglobstar === !0 ? star3 : `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`, create = (str2) => {
      switch (str2) {
        case "*":
          return `${nodot}${ONE_CHAR}${star3}`;
        case ".*":
          return `${DOT_LITERAL}${ONE_CHAR}${star3}`;
        case "*.*":
          return `${nodot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
        case "*/*":
          return `${nodot}${star3}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star3}`;
        case "**":
          return nodot + globstar(opts);
        case "**/*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star3}`;
        case "**/*.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
        case "**/.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star3}`;
        default: {
          const match2 = /^(.*?)\.(\w+)$/.exec(str2);
          if (!match2) return;
          const source3 = create(match2[1]);
          return source3 ? source3 + DOT_LITERAL + match2[2] : void 0;
        }
      }
    }, output = utils2.removePrefix(input2, state);
    let source2 = create(output);
    return source2 && opts.strictSlashes !== !0 && (source2 += `${SLASH_LITERAL}?`), source2;
  }, parse_1 = parse3, parse_1;
}
var picomatch_1, hasRequiredPicomatch$1;
function requirePicomatch$1() {
  if (hasRequiredPicomatch$1) return picomatch_1;
  hasRequiredPicomatch$1 = 1;
  const path2 = require$$0__default$1.default, scan2 = requireScan(), parse3 = requireParse$1(), utils2 = requireUtils$1(), constants2 = requireConstants$1(), isObject2 = (val) => val && typeof val == "object" && !Array.isArray(val), picomatch2 = (glob2, options2, returnState = !1) => {
    if (Array.isArray(glob2)) {
      const fns = glob2.map((input2) => picomatch2(input2, options2, returnState));
      return (str2) => {
        for (const isMatch of fns) {
          const state2 = isMatch(str2);
          if (state2) return state2;
        }
        return !1;
      };
    }
    const isState = isObject2(glob2) && glob2.tokens && glob2.input;
    if (glob2 === "" || typeof glob2 != "string" && !isState)
      throw new TypeError("Expected pattern to be a non-empty string");
    const opts = options2 || {}, posix2 = utils2.isWindows(options2), regex2 = isState ? picomatch2.compileRe(glob2, options2) : picomatch2.makeRe(glob2, options2, !1, !0), state = regex2.state;
    delete regex2.state;
    let isIgnored = () => !1;
    if (opts.ignore) {
      const ignoreOpts = { ...options2, ignore: null, onMatch: null, onResult: null };
      isIgnored = picomatch2(opts.ignore, ignoreOpts, returnState);
    }
    const matcher = (input2, returnObject = !1) => {
      const { isMatch, match: match2, output } = picomatch2.test(input2, regex2, options2, { glob: glob2, posix: posix2 }), result = { glob: glob2, state, regex: regex2, posix: posix2, input: input2, output, match: match2, isMatch };
      return typeof opts.onResult == "function" && opts.onResult(result), isMatch === !1 ? (result.isMatch = !1, returnObject ? result : !1) : isIgnored(input2) ? (typeof opts.onIgnore == "function" && opts.onIgnore(result), result.isMatch = !1, returnObject ? result : !1) : (typeof opts.onMatch == "function" && opts.onMatch(result), returnObject ? result : !0);
    };
    return returnState && (matcher.state = state), matcher;
  };
  return picomatch2.test = (input2, regex2, options2, { glob: glob2, posix: posix2 } = {}) => {
    if (typeof input2 != "string")
      throw new TypeError("Expected input to be a string");
    if (input2 === "")
      return { isMatch: !1, output: "" };
    const opts = options2 || {}, format = opts.format || (posix2 ? utils2.toPosixSlashes : null);
    let match2 = input2 === glob2, output = match2 && format ? format(input2) : input2;
    return match2 === !1 && (output = format ? format(input2) : input2, match2 = output === glob2), (match2 === !1 || opts.capture === !0) && (opts.matchBase === !0 || opts.basename === !0 ? match2 = picomatch2.matchBase(input2, regex2, options2, posix2) : match2 = regex2.exec(output)), { isMatch: !!match2, match: match2, output };
  }, picomatch2.matchBase = (input2, glob2, options2, posix2 = utils2.isWindows(options2)) => (glob2 instanceof RegExp ? glob2 : picomatch2.makeRe(glob2, options2)).test(path2.basename(input2)), picomatch2.isMatch = (str2, patterns, options2) => picomatch2(patterns, options2)(str2), picomatch2.parse = (pattern, options2) => Array.isArray(pattern) ? pattern.map((p) => picomatch2.parse(p, options2)) : parse3(pattern, { ...options2, fastpaths: !1 }), picomatch2.scan = (input2, options2) => scan2(input2, options2), picomatch2.compileRe = (state, options2, returnOutput = !1, returnState = !1) => {
    if (returnOutput === !0)
      return state.output;
    const opts = options2 || {}, prepend = opts.contains ? "" : "^", append = opts.contains ? "" : "$";
    let source2 = `${prepend}(?:${state.output})${append}`;
    state && state.negated === !0 && (source2 = `^(?!${source2}).*$`);
    const regex2 = picomatch2.toRegex(source2, options2);
    return returnState === !0 && (regex2.state = state), regex2;
  }, picomatch2.makeRe = (input2, options2 = {}, returnOutput = !1, returnState = !1) => {
    if (!input2 || typeof input2 != "string")
      throw new TypeError("Expected a non-empty string");
    let parsed = { negated: !1, fastpaths: !0 };
    return options2.fastpaths !== !1 && (input2[0] === "." || input2[0] === "*") && (parsed.output = parse3.fastpaths(input2, options2)), parsed.output || (parsed = parse3(input2, options2)), picomatch2.compileRe(parsed, options2, returnOutput, returnState);
  }, picomatch2.toRegex = (source2, options2) => {
    try {
      const opts = options2 || {};
      return new RegExp(source2, opts.flags || (opts.nocase ? "i" : ""));
    } catch (err) {
      if (options2 && options2.debug === !0) throw err;
      return /$^/;
    }
  }, picomatch2.constants = constants2, picomatch_1 = picomatch2, picomatch_1;
}
var picomatch, hasRequiredPicomatch;
function requirePicomatch() {
  return hasRequiredPicomatch || (hasRequiredPicomatch = 1, picomatch = requirePicomatch$1()), picomatch;
}
var micromatch_1, hasRequiredMicromatch;
function requireMicromatch() {
  if (hasRequiredMicromatch) return micromatch_1;
  hasRequiredMicromatch = 1;
  const util2 = require$$0__default$5.default, braces = requireBraces(), picomatch2 = requirePicomatch(), utils2 = requireUtils$1(), isEmptyString = (v) => v === "" || v === "./", hasBraces = (v) => {
    const index = v.indexOf("{");
    return index > -1 && v.indexOf("}", index) > -1;
  }, micromatch = (list2, patterns, options2) => {
    patterns = [].concat(patterns), list2 = [].concat(list2);
    let omit = /* @__PURE__ */ new Set(), keep = /* @__PURE__ */ new Set(), items = /* @__PURE__ */ new Set(), negatives = 0, onResult = (state) => {
      items.add(state.output), options2 && options2.onResult && options2.onResult(state);
    };
    for (let i = 0; i < patterns.length; i++) {
      let isMatch = picomatch2(String(patterns[i]), { ...options2, onResult }, !0), negated = isMatch.state.negated || isMatch.state.negatedExtglob;
      negated && negatives++;
      for (let item of list2) {
        let matched = isMatch(item, !0);
        (negated ? !matched.isMatch : matched.isMatch) && (negated ? omit.add(matched.output) : (omit.delete(matched.output), keep.add(matched.output)));
      }
    }
    let matches = (negatives === patterns.length ? [...items] : [...keep]).filter((item) => !omit.has(item));
    if (options2 && matches.length === 0) {
      if (options2.failglob === !0)
        throw new Error(`No matches found for "${patterns.join(", ")}"`);
      if (options2.nonull === !0 || options2.nullglob === !0)
        return options2.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
    }
    return matches;
  };
  return micromatch.match = micromatch, micromatch.matcher = (pattern, options2) => picomatch2(pattern, options2), micromatch.isMatch = (str2, patterns, options2) => picomatch2(patterns, options2)(str2), micromatch.any = micromatch.isMatch, micromatch.not = (list2, patterns, options2 = {}) => {
    patterns = [].concat(patterns).map(String);
    let result = /* @__PURE__ */ new Set(), items = [], onResult = (state) => {
      options2.onResult && options2.onResult(state), items.push(state.output);
    }, matches = new Set(micromatch(list2, patterns, { ...options2, onResult }));
    for (let item of items)
      matches.has(item) || result.add(item);
    return [...result];
  }, micromatch.contains = (str2, pattern, options2) => {
    if (typeof str2 != "string")
      throw new TypeError(`Expected a string: "${util2.inspect(str2)}"`);
    if (Array.isArray(pattern))
      return pattern.some((p) => micromatch.contains(str2, p, options2));
    if (typeof pattern == "string") {
      if (isEmptyString(str2) || isEmptyString(pattern))
        return !1;
      if (str2.includes(pattern) || str2.startsWith("./") && str2.slice(2).includes(pattern))
        return !0;
    }
    return micromatch.isMatch(str2, pattern, { ...options2, contains: !0 });
  }, micromatch.matchKeys = (obj, patterns, options2) => {
    if (!utils2.isObject(obj))
      throw new TypeError("Expected the first argument to be an object");
    let keys = micromatch(Object.keys(obj), patterns, options2), res = {};
    for (let key2 of keys) res[key2] = obj[key2];
    return res;
  }, micromatch.some = (list2, patterns, options2) => {
    let items = [].concat(list2);
    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch2(String(pattern), options2);
      if (items.some((item) => isMatch(item)))
        return !0;
    }
    return !1;
  }, micromatch.every = (list2, patterns, options2) => {
    let items = [].concat(list2);
    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch2(String(pattern), options2);
      if (!items.every((item) => isMatch(item)))
        return !1;
    }
    return !0;
  }, micromatch.all = (str2, patterns, options2) => {
    if (typeof str2 != "string")
      throw new TypeError(`Expected a string: "${util2.inspect(str2)}"`);
    return [].concat(patterns).every((p) => picomatch2(p, options2)(str2));
  }, micromatch.capture = (glob2, input2, options2) => {
    let posix2 = utils2.isWindows(options2), match2 = picomatch2.makeRe(String(glob2), { ...options2, capture: !0 }).exec(posix2 ? utils2.toPosixSlashes(input2) : input2);
    if (match2)
      return match2.slice(1).map((v) => v === void 0 ? "" : v);
  }, micromatch.makeRe = (...args) => picomatch2.makeRe(...args), micromatch.scan = (...args) => picomatch2.scan(...args), micromatch.parse = (patterns, options2) => {
    let res = [];
    for (let pattern of [].concat(patterns || []))
      for (let str2 of braces(String(pattern), options2))
        res.push(picomatch2.parse(str2, options2));
    return res;
  }, micromatch.braces = (pattern, options2) => {
    if (typeof pattern != "string") throw new TypeError("Expected a string");
    return options2 && options2.nobrace === !0 || !hasBraces(pattern) ? [pattern] : braces(pattern, options2);
  }, micromatch.braceExpand = (pattern, options2) => {
    if (typeof pattern != "string") throw new TypeError("Expected a string");
    return micromatch.braces(pattern, { ...options2, expand: !0 });
  }, micromatch.hasBraces = hasBraces, micromatch_1 = micromatch, micromatch_1;
}
var hasRequiredCore$3;
function requireCore$3() {
  if (hasRequiredCore$3) return core$3;
  hasRequiredCore$3 = 1;
  var __importDefault2 = core$3 && core$3.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(core$3, "__esModule", { value: !0 }), core$3.readPackageJSON = core$3.extractWorkspaces = core$3.isMatchWorkspaces = core$3.checkWorkspaces = core$3.findWorkspaceRoot = void 0;
  const path_1 = __importDefault2(require$$0__default$1.default), pkg_dir_1 = __importDefault2(pkgDir__default.default), fs_1 = require$$0__default.default, micromatch_12 = __importDefault2(requireMicromatch());
  function findWorkspaceRoot(initial) {
    initial || (initial = process.cwd());
    let _pkg = pkg_dir_1.default.sync(initial);
    if (!_pkg)
      return null;
    initial = path_1.default.normalize(_pkg);
    let previous = null, current = initial;
    do {
      const manifest = readPackageJSON(current);
      extractWorkspaces(manifest);
      let { done, found } = checkWorkspaces(current, initial);
      if (done)
        return found;
      previous = current, current = path_1.default.dirname(current);
    } while (current !== previous);
    return null;
  }
  core$3.findWorkspaceRoot = findWorkspaceRoot;
  function checkWorkspaces(current, initial) {
    const manifest = readPackageJSON(current), workspaces = extractWorkspaces(manifest);
    let done = !1, found, relativePath;
    return workspaces && (done = !0, relativePath = path_1.default.relative(current, initial), relativePath === "" || isMatchWorkspaces(relativePath, workspaces) ? found = current : found = null), {
      done,
      found,
      relativePath
    };
  }
  core$3.checkWorkspaces = checkWorkspaces;
  function isMatchWorkspaces(relativePath, workspaces) {
    return micromatch_12.default([relativePath], workspaces).length > 0;
  }
  core$3.isMatchWorkspaces = isMatchWorkspaces;
  function extractWorkspaces(manifest) {
    const workspaces = (manifest || {}).workspaces;
    return workspaces && workspaces.packages || (Array.isArray(workspaces) ? workspaces : null);
  }
  core$3.extractWorkspaces = extractWorkspaces;
  function readPackageJSON(dir) {
    const file = path_1.default.join(dir, "package.json");
    return fs_1.existsSync(file) ? JSON.parse(fs_1.readFileSync(file, "utf8")) : null;
  }
  return core$3.readPackageJSON = readPackageJSON, findWorkspaceRoot.findWorkspaceRoot = findWorkspaceRoot, findWorkspaceRoot.readPackageJSON = readPackageJSON, findWorkspaceRoot.extractWorkspaces = extractWorkspaces, findWorkspaceRoot.isMatchWorkspaces = isMatchWorkspaces, findWorkspaceRoot.default = findWorkspaceRoot, core$3.default = findWorkspaceRoot, core$3;
}
var findYarnWorkspaceRoot2, hasRequiredFindYarnWorkspaceRoot2;
function requireFindYarnWorkspaceRoot2() {
  return hasRequiredFindYarnWorkspaceRoot2 || (hasRequiredFindYarnWorkspaceRoot2 = 1, findYarnWorkspaceRoot2 = requireCore$3().findWorkspaceRoot), findYarnWorkspaceRoot2;
}
var findUp = { exports: {} }, locatePath = { exports: {} }, yoctoQueue, hasRequiredYoctoQueue;
function requireYoctoQueue() {
  if (hasRequiredYoctoQueue) return yoctoQueue;
  hasRequiredYoctoQueue = 1;
  class Node {
    /// value;
    /// next;
    constructor(value) {
      this.value = value, this.next = void 0;
    }
  }
  class Queue {
    // TODO: Use private class fields when targeting Node.js 12.
    // #_head;
    // #_tail;
    // #_size;
    constructor() {
      this.clear();
    }
    enqueue(value) {
      const node = new Node(value);
      this._head ? (this._tail.next = node, this._tail = node) : (this._head = node, this._tail = node), this._size++;
    }
    dequeue() {
      const current = this._head;
      if (current)
        return this._head = this._head.next, this._size--, current.value;
    }
    clear() {
      this._head = void 0, this._tail = void 0, this._size = 0;
    }
    get size() {
      return this._size;
    }
    *[Symbol.iterator]() {
      let current = this._head;
      for (; current; )
        yield current.value, current = current.next;
    }
  }
  return yoctoQueue = Queue, yoctoQueue;
}
var pLimit_1, hasRequiredPLimit;
function requirePLimit() {
  if (hasRequiredPLimit) return pLimit_1;
  hasRequiredPLimit = 1;
  const Queue = requireYoctoQueue();
  return pLimit_1 = (concurrency) => {
    if (!((Number.isInteger(concurrency) || concurrency === 1 / 0) && concurrency > 0))
      throw new TypeError("Expected `concurrency` to be a number from 1 and up");
    const queue2 = new Queue();
    let activeCount = 0;
    const next = () => {
      activeCount--, queue2.size > 0 && queue2.dequeue()();
    }, run = async (fn, resolve, ...args) => {
      activeCount++;
      const result = (async () => fn(...args))();
      resolve(result);
      try {
        await result;
      } catch {
      }
      next();
    }, enqueue = (fn, resolve, ...args) => {
      queue2.enqueue(run.bind(null, fn, resolve, ...args)), (async () => (await Promise.resolve(), activeCount < concurrency && queue2.size > 0 && queue2.dequeue()()))();
    }, generator = (fn, ...args) => new Promise((resolve) => {
      enqueue(fn, resolve, ...args);
    });
    return Object.defineProperties(generator, {
      activeCount: {
        get: () => activeCount
      },
      pendingCount: {
        get: () => queue2.size
      },
      clearQueue: {
        value: () => {
          queue2.clear();
        }
      }
    }), generator;
  }, pLimit_1;
}
var pLocate_1, hasRequiredPLocate;
function requirePLocate() {
  if (hasRequiredPLocate) return pLocate_1;
  hasRequiredPLocate = 1;
  const pLimit = requirePLimit();
  class EndError extends Error {
    constructor(value) {
      super(), this.value = value;
    }
  }
  const testElement = async (element, tester) => tester(await element), finder = async (element) => {
    const values = await Promise.all(element);
    if (values[1] === !0)
      throw new EndError(values[0]);
    return !1;
  };
  return pLocate_1 = async (iterable, tester, options2) => {
    options2 = {
      concurrency: 1 / 0,
      preserveOrder: !0,
      ...options2
    };
    const limit = pLimit(options2.concurrency), items = [...iterable].map((element) => [element, limit(testElement, element, tester)]), checkLimit = pLimit(options2.preserveOrder ? 1 : 1 / 0);
    try {
      await Promise.all(items.map((element) => checkLimit(finder, element)));
    } catch (error2) {
      if (error2 instanceof EndError)
        return error2.value;
      throw error2;
    }
  }, pLocate_1;
}
var hasRequiredLocatePath;
function requireLocatePath() {
  if (hasRequiredLocatePath) return locatePath.exports;
  hasRequiredLocatePath = 1;
  const path2 = require$$0__default$1.default, fs2 = require$$0__default.default, { promisify } = require$$0__default$5.default, pLocate = requirePLocate(), fsStat = promisify(fs2.stat), fsLStat = promisify(fs2.lstat), typeMappings = {
    directory: "isDirectory",
    file: "isFile"
  };
  function checkType({ type: type2 }) {
    if (!(type2 in typeMappings))
      throw new Error(`Invalid type specified: ${type2}`);
  }
  const matchType = (type2, stat2) => type2 === void 0 || stat2[typeMappings[type2]]();
  return locatePath.exports = async (paths, options2) => {
    options2 = {
      cwd: process.cwd(),
      type: "file",
      allowSymlinks: !0,
      ...options2
    }, checkType(options2);
    const statFn = options2.allowSymlinks ? fsStat : fsLStat;
    return pLocate(paths, async (path_) => {
      try {
        const stat2 = await statFn(path2.resolve(options2.cwd, path_));
        return matchType(options2.type, stat2);
      } catch {
        return !1;
      }
    }, options2);
  }, locatePath.exports.sync = (paths, options2) => {
    options2 = {
      cwd: process.cwd(),
      allowSymlinks: !0,
      type: "file",
      ...options2
    }, checkType(options2);
    const statFn = options2.allowSymlinks ? fs2.statSync : fs2.lstatSync;
    for (const path_ of paths)
      try {
        const stat2 = statFn(path2.resolve(options2.cwd, path_));
        if (matchType(options2.type, stat2))
          return path_;
      } catch {
      }
  }, locatePath.exports;
}
var pathExists = { exports: {} }, hasRequiredPathExists;
function requirePathExists() {
  if (hasRequiredPathExists) return pathExists.exports;
  hasRequiredPathExists = 1;
  const fs2 = require$$0__default.default, { promisify } = require$$0__default$5.default, pAccess = promisify(fs2.access);
  return pathExists.exports = async (path2) => {
    try {
      return await pAccess(path2), !0;
    } catch {
      return !1;
    }
  }, pathExists.exports.sync = (path2) => {
    try {
      return fs2.accessSync(path2), !0;
    } catch {
      return !1;
    }
  }, pathExists.exports;
}
var hasRequiredFindUp;
function requireFindUp() {
  return hasRequiredFindUp || (hasRequiredFindUp = 1, function(module2) {
    const path2 = require$$0__default$1.default, locatePath2 = requireLocatePath(), pathExists2 = requirePathExists(), stop = Symbol("findUp.stop");
    module2.exports = async (name, options2 = {}) => {
      let directory = path2.resolve(options2.cwd || "");
      const { root: root2 } = path2.parse(directory), paths = [].concat(name), runMatcher = async (locateOptions) => {
        if (typeof name != "function")
          return locatePath2(paths, locateOptions);
        const foundPath = await name(locateOptions.cwd);
        return typeof foundPath == "string" ? locatePath2([foundPath], locateOptions) : foundPath;
      };
      for (; ; ) {
        const foundPath = await runMatcher({ ...options2, cwd: directory });
        if (foundPath === stop)
          return;
        if (foundPath)
          return path2.resolve(directory, foundPath);
        if (directory === root2)
          return;
        directory = path2.dirname(directory);
      }
    }, module2.exports.sync = (name, options2 = {}) => {
      let directory = path2.resolve(options2.cwd || "");
      const { root: root2 } = path2.parse(directory), paths = [].concat(name), runMatcher = (locateOptions) => {
        if (typeof name != "function")
          return locatePath2.sync(paths, locateOptions);
        const foundPath = name(locateOptions.cwd);
        return typeof foundPath == "string" ? locatePath2.sync([foundPath], locateOptions) : foundPath;
      };
      for (; ; ) {
        const foundPath = runMatcher({ ...options2, cwd: directory });
        if (foundPath === stop)
          return;
        if (foundPath)
          return path2.resolve(directory, foundPath);
        if (directory === root2)
          return;
        directory = path2.dirname(directory);
      }
    }, module2.exports.exists = pathExists2, module2.exports.sync.exists = pathExists2.sync, module2.exports.stop = stop;
  }(findUp)), findUp.exports;
}
var loadYamlFile = { exports: {} }, pify, hasRequiredPify;
function requirePify() {
  if (hasRequiredPify) return pify;
  hasRequiredPify = 1;
  const processFn = (fn, options2) => function(...args) {
    const P = options2.promiseModule;
    return new P((resolve, reject) => {
      options2.multiArgs ? args.push((...result) => {
        options2.errorFirst ? result[0] ? reject(result) : (result.shift(), resolve(result)) : resolve(result);
      }) : options2.errorFirst ? args.push((error2, result) => {
        error2 ? reject(error2) : resolve(result);
      }) : args.push(resolve), fn.apply(this, args);
    });
  };
  return pify = (input2, options2) => {
    options2 = Object.assign({
      exclude: [/.+(Sync|Stream)$/],
      errorFirst: !0,
      promiseModule: Promise
    }, options2);
    const objType = typeof input2;
    if (!(input2 !== null && (objType === "object" || objType === "function")))
      throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input2 === null ? "null" : objType}\``);
    const filter2 = (key2) => {
      const match2 = (pattern) => typeof pattern == "string" ? key2 === pattern : pattern.test(key2);
      return options2.include ? options2.include.some(match2) : !options2.exclude.some(match2);
    };
    let ret;
    objType === "function" ? ret = function(...args) {
      return options2.excludeMain ? input2(...args) : processFn(input2, options2).apply(this, args);
    } : ret = Object.create(Object.getPrototypeOf(input2));
    for (const key2 in input2) {
      const property = input2[key2];
      ret[key2] = typeof property == "function" && filter2(key2) ? processFn(property, options2) : property;
    }
    return ret;
  }, pify;
}
var stripBom, hasRequiredStripBom;
function requireStripBom() {
  return hasRequiredStripBom || (hasRequiredStripBom = 1, stripBom = (x) => {
    if (typeof x != "string")
      throw new TypeError("Expected a string, got " + typeof x);
    return x.charCodeAt(0) === 65279 ? x.slice(1) : x;
  }), stripBom;
}
var jsYaml$1 = {}, loader = {}, common = {}, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function isNothing(subject) {
    return typeof subject > "u" || subject === null;
  }
  function isObject2(subject) {
    return typeof subject == "object" && subject !== null;
  }
  function toArray2(sequence) {
    return Array.isArray(sequence) ? sequence : isNothing(sequence) ? [] : [sequence];
  }
  function extend(target, source2) {
    var index, length, key2, sourceKeys;
    if (source2)
      for (sourceKeys = Object.keys(source2), index = 0, length = sourceKeys.length; index < length; index += 1)
        key2 = sourceKeys[index], target[key2] = source2[key2];
    return target;
  }
  function repeat2(string, count2) {
    var result = "", cycle;
    for (cycle = 0; cycle < count2; cycle += 1)
      result += string;
    return result;
  }
  function isNegativeZero(number2) {
    return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
  }
  return common.isNothing = isNothing, common.isObject = isObject2, common.toArray = toArray2, common.repeat = repeat2, common.isNegativeZero = isNegativeZero, common.extend = extend, common;
}
var exception, hasRequiredException;
function requireException() {
  if (hasRequiredException) return exception;
  hasRequiredException = 1;
  function YAMLException(reason, mark2) {
    Error.call(this), this.name = "YAMLException", this.reason = reason, this.mark = mark2, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
  }
  return YAMLException.prototype = Object.create(Error.prototype), YAMLException.prototype.constructor = YAMLException, YAMLException.prototype.toString = function(compact) {
    var result = this.name + ": ";
    return result += this.reason || "(unknown reason)", !compact && this.mark && (result += " " + this.mark.toString()), result;
  }, exception = YAMLException, exception;
}
var mark, hasRequiredMark;
function requireMark() {
  if (hasRequiredMark) return mark;
  hasRequiredMark = 1;
  var common2 = requireCommon();
  function Mark(name, buffer2, position, line3, column2) {
    this.name = name, this.buffer = buffer2, this.position = position, this.line = line3, this.column = column2;
  }
  return Mark.prototype.getSnippet = function(indent, maxLength) {
    var head, start, tail, end, snippet2;
    if (!this.buffer) return null;
    for (indent = indent || 4, maxLength = maxLength || 75, head = "", start = this.position; start > 0 && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(start - 1)) === -1; )
      if (start -= 1, this.position - start > maxLength / 2 - 1) {
        head = " ... ", start += 5;
        break;
      }
    for (tail = "", end = this.position; end < this.buffer.length && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(end)) === -1; )
      if (end += 1, end - this.position > maxLength / 2 - 1) {
        tail = " ... ", end -= 5;
        break;
      }
    return snippet2 = this.buffer.slice(start, end), common2.repeat(" ", indent) + head + snippet2 + tail + `
` + common2.repeat(" ", indent + this.position - start + head.length) + "^";
  }, Mark.prototype.toString = function(compact) {
    var snippet2, where = "";
    return this.name && (where += 'in "' + this.name + '" '), where += "at line " + (this.line + 1) + ", column " + (this.column + 1), compact || (snippet2 = this.getSnippet(), snippet2 && (where += `:
` + snippet2)), where;
  }, mark = Mark, mark;
}
var type, hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  var YAMLException = requireException(), TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "defaultStyle",
    "styleAliases"
  ], YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map2) {
    var result = {};
    return map2 !== null && Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    }), result;
  }
  function Type(tag, options2) {
    if (options2 = options2 || {}, Object.keys(options2).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1)
        throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }), this.tag = tag, this.kind = options2.kind || null, this.resolve = options2.resolve || function() {
      return !0;
    }, this.construct = options2.construct || function(data) {
      return data;
    }, this.instanceOf = options2.instanceOf || null, this.predicate = options2.predicate || null, this.represent = options2.represent || null, this.defaultStyle = options2.defaultStyle || null, this.styleAliases = compileStyleAliases(options2.styleAliases || null), YAML_NODE_KINDS.indexOf(this.kind) === -1)
      throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
  return type = Type, type;
}
var schema, hasRequiredSchema;
function requireSchema() {
  if (hasRequiredSchema) return schema;
  hasRequiredSchema = 1;
  var common2 = requireCommon(), YAMLException = requireException(), Type = requireType();
  function compileList(schema2, name, result) {
    var exclude = [];
    return schema2.include.forEach(function(includedSchema) {
      result = compileList(includedSchema, name, result);
    }), schema2[name].forEach(function(currentType) {
      result.forEach(function(previousType, previousIndex) {
        previousType.tag === currentType.tag && previousType.kind === currentType.kind && exclude.push(previousIndex);
      }), result.push(currentType);
    }), result.filter(function(type2, index) {
      return exclude.indexOf(index) === -1;
    });
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {}
    }, index, length;
    function collectType(type2) {
      result[type2.kind][type2.tag] = result.fallback[type2.tag] = type2;
    }
    for (index = 0, length = arguments.length; index < length; index += 1)
      arguments[index].forEach(collectType);
    return result;
  }
  function Schema(definition) {
    this.include = definition.include || [], this.implicit = definition.implicit || [], this.explicit = definition.explicit || [], this.implicit.forEach(function(type2) {
      if (type2.loadKind && type2.loadKind !== "scalar")
        throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }), this.compiledImplicit = compileList(this, "implicit", []), this.compiledExplicit = compileList(this, "explicit", []), this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
  }
  return Schema.DEFAULT = null, Schema.create = function() {
    var schemas, types2;
    switch (arguments.length) {
      case 1:
        schemas = Schema.DEFAULT, types2 = arguments[0];
        break;
      case 2:
        schemas = arguments[0], types2 = arguments[1];
        break;
      default:
        throw new YAMLException("Wrong number of arguments for Schema.create function");
    }
    if (schemas = common2.toArray(schemas), types2 = common2.toArray(types2), !schemas.every(function(schema2) {
      return schema2 instanceof Schema;
    }))
      throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
    if (!types2.every(function(type2) {
      return type2 instanceof Type;
    }))
      throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    return new Schema({
      include: schemas,
      explicit: types2
    });
  }, schema = Schema, schema;
}
var str, hasRequiredStr;
function requireStr() {
  if (hasRequiredStr) return str;
  hasRequiredStr = 1;
  var Type = requireType();
  return str = new Type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  }), str;
}
var seq, hasRequiredSeq;
function requireSeq() {
  if (hasRequiredSeq) return seq;
  hasRequiredSeq = 1;
  var Type = requireType();
  return seq = new Type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  }), seq;
}
var map$1, hasRequiredMap;
function requireMap() {
  if (hasRequiredMap) return map$1;
  hasRequiredMap = 1;
  var Type = requireType();
  return map$1 = new Type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  }), map$1;
}
var failsafe, hasRequiredFailsafe;
function requireFailsafe() {
  if (hasRequiredFailsafe) return failsafe;
  hasRequiredFailsafe = 1;
  var Schema = requireSchema();
  return failsafe = new Schema({
    explicit: [
      requireStr(),
      requireSeq(),
      requireMap()
    ]
  }), failsafe;
}
var _null, hasRequired_null;
function require_null() {
  if (hasRequired_null) return _null;
  hasRequired_null = 1;
  var Type = requireType();
  function resolveYamlNull(data) {
    if (data === null) return !0;
    var max2 = data.length;
    return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  return _null = new Type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      }
    },
    defaultStyle: "lowercase"
  }), _null;
}
var bool, hasRequiredBool;
function requireBool() {
  if (hasRequiredBool) return bool;
  hasRequiredBool = 1;
  var Type = requireType();
  function resolveYamlBoolean(data) {
    if (data === null) return !1;
    var max2 = data.length;
    return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  return bool = new Type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  }), bool;
}
var int, hasRequiredInt;
function requireInt() {
  if (hasRequiredInt) return int;
  hasRequiredInt = 1;
  var common2 = requireCommon(), Type = requireType();
  function isHexCode(c2) {
    return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
  }
  function isOctCode(c2) {
    return 48 <= c2 && c2 <= 55;
  }
  function isDecCode(c2) {
    return 48 <= c2 && c2 <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null) return !1;
    var max2 = data.length, index = 0, hasDigits = !1, ch;
    if (!max2) return !1;
    if (ch = data[index], (ch === "-" || ch === "+") && (ch = data[++index]), ch === "0") {
      if (index + 1 === max2) return !0;
      if (ch = data[++index], ch === "b") {
        for (index++; index < max2; index++)
          if (ch = data[index], ch !== "_") {
            if (ch !== "0" && ch !== "1") return !1;
            hasDigits = !0;
          }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        for (index++; index < max2; index++)
          if (ch = data[index], ch !== "_") {
            if (!isHexCode(data.charCodeAt(index))) return !1;
            hasDigits = !0;
          }
        return hasDigits && ch !== "_";
      }
      for (; index < max2; index++)
        if (ch = data[index], ch !== "_") {
          if (!isOctCode(data.charCodeAt(index))) return !1;
          hasDigits = !0;
        }
      return hasDigits && ch !== "_";
    }
    if (ch === "_") return !1;
    for (; index < max2; index++)
      if (ch = data[index], ch !== "_") {
        if (ch === ":") break;
        if (!isDecCode(data.charCodeAt(index)))
          return !1;
        hasDigits = !0;
      }
    return !hasDigits || ch === "_" ? !1 : ch !== ":" ? !0 : /^(:[0-5]?[0-9])+$/.test(data.slice(index));
  }
  function constructYamlInteger(data) {
    var value = data, sign2 = 1, ch, base2, digits = [];
    return value.indexOf("_") !== -1 && (value = value.replace(/_/g, "")), ch = value[0], (ch === "-" || ch === "+") && (ch === "-" && (sign2 = -1), value = value.slice(1), ch = value[0]), value === "0" ? 0 : ch === "0" ? value[1] === "b" ? sign2 * parseInt(value.slice(2), 2) : value[1] === "x" ? sign2 * parseInt(value, 16) : sign2 * parseInt(value, 8) : value.indexOf(":") !== -1 ? (value.split(":").forEach(function(v) {
      digits.unshift(parseInt(v, 10));
    }), value = 0, base2 = 1, digits.forEach(function(d) {
      value += d * base2, base2 *= 60;
    }), sign2 * value) : sign2 * parseInt(value, 10);
  }
  function isInteger2(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common2.isNegativeZero(object);
  }
  return int = new Type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger2,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  }), int;
}
var float, hasRequiredFloat;
function requireFloat() {
  if (hasRequiredFloat) return float;
  hasRequiredFloat = 1;
  var common2 = requireCommon(), Type = requireType(), YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function resolveYamlFloat(data) {
    return !(data === null || !YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_");
  }
  function constructYamlFloat(data) {
    var value, sign2, base2, digits;
    return value = data.replace(/_/g, "").toLowerCase(), sign2 = value[0] === "-" ? -1 : 1, digits = [], "+-".indexOf(value[0]) >= 0 && (value = value.slice(1)), value === ".inf" ? sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : value === ".nan" ? NaN : value.indexOf(":") >= 0 ? (value.split(":").forEach(function(v) {
      digits.unshift(parseFloat(v, 10));
    }), value = 0, base2 = 1, digits.forEach(function(d) {
      value += d * base2, base2 *= 60;
    }), sign2 * value) : sign2 * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object))
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    else if (Number.POSITIVE_INFINITY === object)
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    else if (Number.NEGATIVE_INFINITY === object)
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    else if (common2.isNegativeZero(object))
      return "-0.0";
    return res = object.toString(10), SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat2(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common2.isNegativeZero(object));
  }
  return float = new Type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat2,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  }), float;
}
var json, hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json;
  hasRequiredJson = 1;
  var Schema = requireSchema();
  return json = new Schema({
    include: [
      requireFailsafe()
    ],
    implicit: [
      require_null(),
      requireBool(),
      requireInt(),
      requireFloat()
    ]
  }), json;
}
var core$2, hasRequiredCore$2;
function requireCore$2() {
  if (hasRequiredCore$2) return core$2;
  hasRequiredCore$2 = 1;
  var Schema = requireSchema();
  return core$2 = new Schema({
    include: [
      requireJson()
    ]
  }), core$2;
}
var timestamp$1, hasRequiredTimestamp;
function requireTimestamp() {
  if (hasRequiredTimestamp) return timestamp$1;
  hasRequiredTimestamp = 1;
  var Type = requireType(), YAML_DATE_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  ), YAML_TIMESTAMP_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function resolveYamlTimestamp(data) {
    return data === null ? !1 : YAML_DATE_REGEXP.exec(data) !== null || YAML_TIMESTAMP_REGEXP.exec(data) !== null;
  }
  function constructYamlTimestamp(data) {
    var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    if (match2 = YAML_DATE_REGEXP.exec(data), match2 === null && (match2 = YAML_TIMESTAMP_REGEXP.exec(data)), match2 === null) throw new Error("Date resolve error");
    if (year = +match2[1], month = +match2[2] - 1, day = +match2[3], !match2[4])
      return new Date(Date.UTC(year, month, day));
    if (hour = +match2[4], minute = +match2[5], second = +match2[6], match2[7]) {
      for (fraction = match2[7].slice(0, 3); fraction.length < 3; )
        fraction += "0";
      fraction = +fraction;
    }
    return match2[9] && (tz_hour = +match2[10], tz_minute = +(match2[11] || 0), delta = (tz_hour * 60 + tz_minute) * 6e4, match2[9] === "-" && (delta = -delta)), date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction)), delta && date.setTime(date.getTime() - delta), date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  return timestamp$1 = new Type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  }), timestamp$1;
}
var merge$2, hasRequiredMerge;
function requireMerge() {
  if (hasRequiredMerge) return merge$2;
  hasRequiredMerge = 1;
  var Type = requireType();
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  return merge$2 = new Type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  }), merge$2;
}
var binary$1, hasRequiredBinary;
function requireBinary() {
  if (hasRequiredBinary) return binary$1;
  hasRequiredBinary = 1;
  var NodeBuffer;
  try {
    var _require = commonjsRequire;
    NodeBuffer = _require("buffer").Buffer;
  } catch {
  }
  var Type = requireType(), BASE64_MAP = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function resolveYamlBinary(data) {
    if (data === null) return !1;
    var code, idx, bitlen = 0, max2 = data.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++)
      if (code = map2.indexOf(data.charAt(idx)), !(code > 64)) {
        if (code < 0) return !1;
        bitlen += 6;
      }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input2 = data.replace(/[\r\n=]/g, ""), max2 = input2.length, map2 = BASE64_MAP, bits = 0, result = [];
    for (idx = 0; idx < max2; idx++)
      idx % 4 === 0 && idx && (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)), bits = bits << 6 | map2.indexOf(input2.charAt(idx));
    return tailbits = max2 % 4 * 6, tailbits === 0 ? (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)) : tailbits === 18 ? (result.push(bits >> 10 & 255), result.push(bits >> 2 & 255)) : tailbits === 12 && result.push(bits >> 4 & 255), NodeBuffer ? NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result) : result;
  }
  function representYamlBinary(object) {
    var result = "", bits = 0, idx, tail, max2 = object.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++)
      idx % 3 === 0 && idx && (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]), bits = (bits << 8) + object[idx];
    return tail = max2 % 3, tail === 0 ? (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]) : tail === 2 ? (result += map2[bits >> 10 & 63], result += map2[bits >> 4 & 63], result += map2[bits << 2 & 63], result += map2[64]) : tail === 1 && (result += map2[bits >> 2 & 63], result += map2[bits << 4 & 63], result += map2[64], result += map2[64]), result;
  }
  function isBinary(object) {
    return NodeBuffer && NodeBuffer.isBuffer(object);
  }
  return binary$1 = new Type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  }), binary$1;
}
var omap, hasRequiredOmap;
function requireOmap() {
  if (hasRequiredOmap) return omap;
  hasRequiredOmap = 1;
  var Type = requireType(), _hasOwnProperty = Object.prototype.hasOwnProperty, _toString = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null) return !0;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for (index = 0, length = object.length; index < length; index += 1) {
      if (pair = object[index], pairHasKey = !1, _toString.call(pair) !== "[object Object]") return !1;
      for (pairKey in pair)
        if (_hasOwnProperty.call(pair, pairKey))
          if (!pairHasKey) pairHasKey = !0;
          else return !1;
      if (!pairHasKey) return !1;
      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return !1;
    }
    return !0;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  return omap = new Type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  }), omap;
}
var pairs$1, hasRequiredPairs;
function requirePairs() {
  if (hasRequiredPairs) return pairs$1;
  hasRequiredPairs = 1;
  var Type = requireType(), _toString = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null) return !0;
    var index, length, pair, keys, result, object = data;
    for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1) {
      if (pair = object[index], _toString.call(pair) !== "[object Object]" || (keys = Object.keys(pair), keys.length !== 1)) return !1;
      result[index] = [keys[0], pair[keys[0]]];
    }
    return !0;
  }
  function constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair, keys, result, object = data;
    for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1)
      pair = object[index], keys = Object.keys(pair), result[index] = [keys[0], pair[keys[0]]];
    return result;
  }
  return pairs$1 = new Type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  }), pairs$1;
}
var set, hasRequiredSet;
function requireSet() {
  if (hasRequiredSet) return set;
  hasRequiredSet = 1;
  var Type = requireType(), _hasOwnProperty = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null) return !0;
    var key2, object = data;
    for (key2 in object)
      if (_hasOwnProperty.call(object, key2) && object[key2] !== null)
        return !1;
    return !0;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  return set = new Type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  }), set;
}
var default_safe, hasRequiredDefault_safe;
function requireDefault_safe() {
  if (hasRequiredDefault_safe) return default_safe;
  hasRequiredDefault_safe = 1;
  var Schema = requireSchema();
  return default_safe = new Schema({
    include: [
      requireCore$2()
    ],
    implicit: [
      requireTimestamp(),
      requireMerge()
    ],
    explicit: [
      requireBinary(),
      requireOmap(),
      requirePairs(),
      requireSet()
    ]
  }), default_safe;
}
var _undefined, hasRequired_undefined;
function require_undefined() {
  if (hasRequired_undefined) return _undefined;
  hasRequired_undefined = 1;
  var Type = requireType();
  function resolveJavascriptUndefined() {
    return !0;
  }
  function constructJavascriptUndefined() {
  }
  function representJavascriptUndefined() {
    return "";
  }
  function isUndefined(object) {
    return typeof object > "u";
  }
  return _undefined = new Type("tag:yaml.org,2002:js/undefined", {
    kind: "scalar",
    resolve: resolveJavascriptUndefined,
    construct: constructJavascriptUndefined,
    predicate: isUndefined,
    represent: representJavascriptUndefined
  }), _undefined;
}
var regexp, hasRequiredRegexp;
function requireRegexp() {
  if (hasRequiredRegexp) return regexp;
  hasRequiredRegexp = 1;
  var Type = requireType();
  function resolveJavascriptRegExp(data) {
    if (data === null || data.length === 0) return !1;
    var regexp2 = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    return !(regexp2[0] === "/" && (tail && (modifiers = tail[1]), modifiers.length > 3 || regexp2[regexp2.length - modifiers.length - 1] !== "/"));
  }
  function constructJavascriptRegExp(data) {
    var regexp2 = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    return regexp2[0] === "/" && (tail && (modifiers = tail[1]), regexp2 = regexp2.slice(1, regexp2.length - modifiers.length - 1)), new RegExp(regexp2, modifiers);
  }
  function representJavascriptRegExp(object) {
    var result = "/" + object.source + "/";
    return object.global && (result += "g"), object.multiline && (result += "m"), object.ignoreCase && (result += "i"), result;
  }
  function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
  }
  return regexp = new Type("tag:yaml.org,2002:js/regexp", {
    kind: "scalar",
    resolve: resolveJavascriptRegExp,
    construct: constructJavascriptRegExp,
    predicate: isRegExp,
    represent: representJavascriptRegExp
  }), regexp;
}
var _function, hasRequired_function;
function require_function() {
  if (hasRequired_function) return _function;
  hasRequired_function = 1;
  var esprima2;
  try {
    var _require = commonjsRequire;
    esprima2 = _require("esprima");
  } catch {
    typeof window < "u" && (esprima2 = window.esprima);
  }
  var Type = requireType();
  function resolveJavascriptFunction(data) {
    if (data === null) return !1;
    try {
      var source2 = "(" + data + ")", ast = esprima2.parse(source2, { range: !0 });
      return !(ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression");
    } catch {
      return !1;
    }
  }
  function constructJavascriptFunction(data) {
    var source2 = "(" + data + ")", ast = esprima2.parse(source2, { range: !0 }), params = [], body;
    if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression")
      throw new Error("Failed to resolve function");
    return ast.body[0].expression.params.forEach(function(param) {
      params.push(param.name);
    }), body = ast.body[0].expression.body.range, ast.body[0].expression.body.type === "BlockStatement" ? new Function(params, source2.slice(body[0] + 1, body[1] - 1)) : new Function(params, "return " + source2.slice(body[0], body[1]));
  }
  function representJavascriptFunction(object) {
    return object.toString();
  }
  function isFunction2(object) {
    return Object.prototype.toString.call(object) === "[object Function]";
  }
  return _function = new Type("tag:yaml.org,2002:js/function", {
    kind: "scalar",
    resolve: resolveJavascriptFunction,
    construct: constructJavascriptFunction,
    predicate: isFunction2,
    represent: representJavascriptFunction
  }), _function;
}
var default_full, hasRequiredDefault_full;
function requireDefault_full() {
  if (hasRequiredDefault_full) return default_full;
  hasRequiredDefault_full = 1;
  var Schema = requireSchema();
  return default_full = Schema.DEFAULT = new Schema({
    include: [
      requireDefault_safe()
    ],
    explicit: [
      require_undefined(),
      requireRegexp(),
      require_function()
    ]
  }), default_full;
}
var hasRequiredLoader;
function requireLoader() {
  if (hasRequiredLoader) return loader;
  hasRequiredLoader = 1;
  var common2 = requireCommon(), YAMLException = requireException(), Mark = requireMark(), DEFAULT_SAFE_SCHEMA = requireDefault_safe(), DEFAULT_FULL_SCHEMA = requireDefault_full(), _hasOwnProperty = Object.prototype.hasOwnProperty, CONTEXT_FLOW_IN = 1, CONTEXT_FLOW_OUT = 2, CONTEXT_BLOCK_IN = 3, CONTEXT_BLOCK_OUT = 4, CHOMPING_CLIP = 1, CHOMPING_STRIP = 2, CHOMPING_KEEP = 3, PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/, PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/, PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i, PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c2) {
    return c2 === 10 || c2 === 13;
  }
  function is_WHITE_SPACE(c2) {
    return c2 === 9 || c2 === 32;
  }
  function is_WS_OR_EOL(c2) {
    return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
  }
  function is_FLOW_INDICATOR(c2) {
    return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
  }
  function fromHexCode(c2) {
    var lc;
    return 48 <= c2 && c2 <= 57 ? c2 - 48 : (lc = c2 | 32, 97 <= lc && lc <= 102 ? lc - 97 + 10 : -1);
  }
  function escapedHexLen(c2) {
    return c2 === 120 ? 2 : c2 === 117 ? 4 : c2 === 85 ? 8 : 0;
  }
  function fromDecimalCode(c2) {
    return 48 <= c2 && c2 <= 57 ? c2 - 48 : -1;
  }
  function simpleEscapeSequence(c2) {
    return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 || c2 === 9 ? "	" : c2 === 110 ? `
` : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c2) {
    return c2 <= 65535 ? String.fromCharCode(c2) : String.fromCharCode(
      (c2 - 65536 >> 10) + 55296,
      (c2 - 65536 & 1023) + 56320
    );
  }
  for (var simpleEscapeCheck = new Array(256), simpleEscapeMap = new Array(256), i = 0; i < 256; i++)
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0, simpleEscapeMap[i] = simpleEscapeSequence(i);
  function State(input2, options2) {
    this.input = input2, this.filename = options2.filename || null, this.schema = options2.schema || DEFAULT_FULL_SCHEMA, this.onWarning = options2.onWarning || null, this.legacy = options2.legacy || !1, this.json = options2.json || !1, this.listener = options2.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = input2.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
  }
  function generateError(state, message) {
    return new YAMLException(
      message,
      new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart)
    );
  }
  function throwError2(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    state.onWarning && state.onWarning.call(null, generateError(state, message));
  }
  var directiveHandlers = {
    YAML: function(state, name, args) {
      var match2, major2, minor2;
      state.version !== null && throwError2(state, "duplication of %YAML directive"), args.length !== 1 && throwError2(state, "YAML directive accepts exactly one argument"), match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]), match2 === null && throwError2(state, "ill-formed argument of the YAML directive"), major2 = parseInt(match2[1], 10), minor2 = parseInt(match2[2], 10), major2 !== 1 && throwError2(state, "unacceptable YAML version of the document"), state.version = args[0], state.checkLineBreaks = minor2 < 2, minor2 !== 1 && minor2 !== 2 && throwWarning(state, "unsupported YAML version of the document");
    },
    TAG: function(state, name, args) {
      var handle, prefix;
      args.length !== 2 && throwError2(state, "TAG directive accepts exactly two arguments"), handle = args[0], prefix = args[1], PATTERN_TAG_HANDLE.test(handle) || throwError2(state, "ill-formed tag handle (first argument) of the TAG directive"), _hasOwnProperty.call(state.tagMap, handle) && throwError2(state, 'there is a previously declared suffix for "' + handle + '" tag handle'), PATTERN_TAG_URI.test(prefix) || throwError2(state, "ill-formed tag prefix (second argument) of the TAG directive"), state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      if (_result = state.input.slice(start, end), checkJson)
        for (_position = 0, _length = _result.length; _position < _length; _position += 1)
          _character = _result.charCodeAt(_position), _character === 9 || 32 <= _character && _character <= 1114111 || throwError2(state, "expected valid JSON character");
      else PATTERN_NON_PRINTABLE.test(_result) && throwError2(state, "the stream contains non-printable characters");
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source2, overridableKeys) {
    var sourceKeys, key2, index, quantity;
    for (common2.isObject(source2) || throwError2(state, "cannot merge mappings; the provided source object is unacceptable"), sourceKeys = Object.keys(source2), index = 0, quantity = sourceKeys.length; index < quantity; index += 1)
      key2 = sourceKeys[index], _hasOwnProperty.call(destination, key2) || (destination[key2] = source2[key2], overridableKeys[key2] = !0);
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode))
      for (keyNode = Array.prototype.slice.call(keyNode), index = 0, quantity = keyNode.length; index < quantity; index += 1)
        Array.isArray(keyNode[index]) && throwError2(state, "nested arrays are not supported inside keys"), typeof keyNode == "object" && _class(keyNode[index]) === "[object Object]" && (keyNode[index] = "[object Object]");
    if (typeof keyNode == "object" && _class(keyNode) === "[object Object]" && (keyNode = "[object Object]"), keyNode = String(keyNode), _result === null && (_result = {}), keyTag === "tag:yaml.org,2002:merge")
      if (Array.isArray(valueNode))
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1)
          mergeMappings(state, _result, valueNode[index], overridableKeys);
      else
        mergeMappings(state, _result, valueNode, overridableKeys);
    else
      !state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode) && (state.line = startLine || state.line, state.position = startPos || state.position, throwError2(state, "duplicated mapping key")), _result[keyNode] = valueNode, delete overridableKeys[keyNode];
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position), ch === 10 ? state.position++ : ch === 13 ? (state.position++, state.input.charCodeAt(state.position) === 10 && state.position++) : throwError2(state, "a line break is expected"), state.line += 1, state.lineStart = state.position;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    for (var lineBreaks = 0, ch = state.input.charCodeAt(state.position); ch !== 0; ) {
      for (; is_WHITE_SPACE(ch); )
        ch = state.input.charCodeAt(++state.position);
      if (allowComments && ch === 35)
        do
          ch = state.input.charCodeAt(++state.position);
        while (ch !== 10 && ch !== 13 && ch !== 0);
      if (is_EOL(ch))
        for (readLineBreak(state), ch = state.input.charCodeAt(state.position), lineBreaks++, state.lineIndent = 0; ch === 32; )
          state.lineIndent++, ch = state.input.charCodeAt(++state.position);
      else
        break;
    }
    return checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent && throwWarning(state, "deficient indentation"), lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch;
    return ch = state.input.charCodeAt(_position), !!((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2) && (_position += 3, ch = state.input.charCodeAt(_position), ch === 0 || is_WS_OR_EOL(ch)));
  }
  function writeFoldedLines(state, count2) {
    count2 === 1 ? state.result += " " : count2 > 1 && (state.result += common2.repeat(`
`, count2 - 1));
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    if (ch = state.input.charCodeAt(state.position), is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96 || (ch === 63 || ch === 45) && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)))
      return !1;
    for (state.kind = "scalar", state.result = "", captureStart = captureEnd = state.position, hasPendingContent = !1; ch !== 0; ) {
      if (ch === 58) {
        if (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following))
          break;
      } else if (ch === 35) {
        if (preceding = state.input.charCodeAt(state.position - 1), is_WS_OR_EOL(preceding))
          break;
      } else {
        if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch))
          break;
        if (is_EOL(ch))
          if (_line = state.line, _lineStart = state.lineStart, _lineIndent = state.lineIndent, skipSeparationSpace(state, !1, -1), state.lineIndent >= nodeIndent) {
            hasPendingContent = !0, ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd, state.line = _line, state.lineStart = _lineStart, state.lineIndent = _lineIndent;
            break;
          }
      }
      hasPendingContent && (captureSegment(state, captureStart, captureEnd, !1), writeFoldedLines(state, state.line - _line), captureStart = captureEnd = state.position, hasPendingContent = !1), is_WHITE_SPACE(ch) || (captureEnd = state.position + 1), ch = state.input.charCodeAt(++state.position);
    }
    return captureSegment(state, captureStart, captureEnd, !1), state.result ? !0 : (state.kind = _kind, state.result = _result, !1);
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    if (ch = state.input.charCodeAt(state.position), ch !== 39)
      return !1;
    for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; )
      if (ch === 39)
        if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), ch === 39)
          captureStart = state.position, state.position++, captureEnd = state.position;
        else
          return !0;
      else is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError2(state, "unexpected end of the document within a single quoted scalar") : (state.position++, captureEnd = state.position);
    throwError2(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp2, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 34)
      return !1;
    for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; ) {
      if (ch === 34)
        return captureSegment(state, captureStart, state.position, !0), state.position++, !0;
      if (ch === 92) {
        if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), is_EOL(ch))
          skipSeparationSpace(state, !1, nodeIndent);
        else if (ch < 256 && simpleEscapeCheck[ch])
          state.result += simpleEscapeMap[ch], state.position++;
        else if ((tmp2 = escapedHexLen(ch)) > 0) {
          for (hexLength = tmp2, hexResult = 0; hexLength > 0; hexLength--)
            ch = state.input.charCodeAt(++state.position), (tmp2 = fromHexCode(ch)) >= 0 ? hexResult = (hexResult << 4) + tmp2 : throwError2(state, "expected hexadecimal character");
          state.result += charFromCodepoint(hexResult), state.position++;
        } else
          throwError2(state, "unknown escape sequence");
        captureStart = captureEnd = state.position;
      } else is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError2(state, "unexpected end of the document within a double quoted scalar") : (state.position++, captureEnd = state.position);
    }
    throwError2(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = !0, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
    if (ch = state.input.charCodeAt(state.position), ch === 91)
      terminator = 93, isMapping = !1, _result = [];
    else if (ch === 123)
      terminator = 125, isMapping = !0, _result = {};
    else
      return !1;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(++state.position); ch !== 0; ) {
      if (skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === terminator)
        return state.position++, state.tag = _tag, state.anchor = _anchor, state.kind = isMapping ? "mapping" : "sequence", state.result = _result, !0;
      readNext || throwError2(state, "missed comma between flow collection entries"), keyTag = keyNode = valueNode = null, isPair = isExplicitPair = !1, ch === 63 && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) && (isPair = isExplicitPair = !0, state.position++, skipSeparationSpace(state, !0, nodeIndent))), _line = state.line, composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), keyTag = state.tag, keyNode = state.result, skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), (isExplicitPair || state.line === _line) && ch === 58 && (isPair = !0, ch = state.input.charCodeAt(++state.position), skipSeparationSpace(state, !0, nodeIndent), composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), valueNode = state.result), isMapping ? storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode) : isPair ? _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode)) : _result.push(keyNode), skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === 44 ? (readNext = !0, ch = state.input.charCodeAt(++state.position)) : readNext = !1;
    }
    throwError2(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = !1, detectedIndent = !1, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = !1, tmp2, ch;
    if (ch = state.input.charCodeAt(state.position), ch === 124)
      folding = !1;
    else if (ch === 62)
      folding = !0;
    else
      return !1;
    for (state.kind = "scalar", state.result = ""; ch !== 0; )
      if (ch = state.input.charCodeAt(++state.position), ch === 43 || ch === 45)
        CHOMPING_CLIP === chomping ? chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP : throwError2(state, "repeat of a chomping mode identifier");
      else if ((tmp2 = fromDecimalCode(ch)) >= 0)
        tmp2 === 0 ? throwError2(state, "bad explicit indentation width of a block scalar; it cannot be less than one") : detectedIndent ? throwError2(state, "repeat of an indentation width identifier") : (textIndent = nodeIndent + tmp2 - 1, detectedIndent = !0);
      else
        break;
    if (is_WHITE_SPACE(ch)) {
      do
        ch = state.input.charCodeAt(++state.position);
      while (is_WHITE_SPACE(ch));
      if (ch === 35)
        do
          ch = state.input.charCodeAt(++state.position);
        while (!is_EOL(ch) && ch !== 0);
    }
    for (; ch !== 0; ) {
      for (readLineBreak(state), state.lineIndent = 0, ch = state.input.charCodeAt(state.position); (!detectedIndent || state.lineIndent < textIndent) && ch === 32; )
        state.lineIndent++, ch = state.input.charCodeAt(++state.position);
      if (!detectedIndent && state.lineIndent > textIndent && (textIndent = state.lineIndent), is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        chomping === CHOMPING_KEEP ? state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines) : chomping === CHOMPING_CLIP && didReadContent && (state.result += `
`);
        break;
      }
      for (folding ? is_WHITE_SPACE(ch) ? (atMoreIndented = !0, state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines)) : atMoreIndented ? (atMoreIndented = !1, state.result += common2.repeat(`
`, emptyLines + 1)) : emptyLines === 0 ? didReadContent && (state.result += " ") : state.result += common2.repeat(`
`, emptyLines) : state.result += common2.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines), didReadContent = !0, detectedIndent = !0, emptyLines = 0, captureStart = state.position; !is_EOL(ch) && ch !== 0; )
        ch = state.input.charCodeAt(++state.position);
      captureSegment(state, captureStart, state.position, !1);
    }
    return !0;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = !1, ch;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0 && !(ch !== 45 || (following = state.input.charCodeAt(state.position + 1), !is_WS_OR_EOL(following))); ) {
      if (detected = !0, state.position++, skipSeparationSpace(state, !0, -1) && state.lineIndent <= nodeIndent) {
        _result.push(null), ch = state.input.charCodeAt(state.position);
        continue;
      }
      if (_line = state.line, composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, !1, !0), _result.push(state.result), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), (state.line === _line || state.lineIndent > nodeIndent) && ch !== 0)
        throwError2(state, "bad indentation of a sequence entry");
      else if (state.lineIndent < nodeIndent)
        break;
    }
    return detected ? (state.tag = _tag, state.anchor = _anchor, state.kind = "sequence", state.result = _result, !0) : !1;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = !1, detected = !1, ch;
    for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0; ) {
      if (following = state.input.charCodeAt(state.position + 1), _line = state.line, _pos = state.position, (ch === 63 || ch === 58) && is_WS_OR_EOL(following))
        ch === 63 ? (atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !0, allowCompact = !0) : atExplicitKey ? (atExplicitKey = !1, allowCompact = !0) : throwError2(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), state.position += 1, ch = following;
      else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, !1, !0))
        if (state.line === _line) {
          for (ch = state.input.charCodeAt(state.position); is_WHITE_SPACE(ch); )
            ch = state.input.charCodeAt(++state.position);
          if (ch === 58)
            ch = state.input.charCodeAt(++state.position), is_WS_OR_EOL(ch) || throwError2(state, "a whitespace character is expected after the key-value separator within a block mapping"), atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !1, allowCompact = !1, keyTag = state.tag, keyNode = state.result;
          else if (detected)
            throwError2(state, "can not read an implicit mapping pair; a colon is missed");
          else
            return state.tag = _tag, state.anchor = _anchor, !0;
        } else if (detected)
          throwError2(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        else
          return state.tag = _tag, state.anchor = _anchor, !0;
      else
        break;
      if ((state.line === _line || state.lineIndent > nodeIndent) && (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, !0, allowCompact) && (atExplicitKey ? keyNode = state.result : valueNode = state.result), atExplicitKey || (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos), keyTag = keyNode = valueNode = null), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position)), state.lineIndent > nodeIndent && ch !== 0)
        throwError2(state, "bad indentation of a mapping entry");
      else if (state.lineIndent < nodeIndent)
        break;
    }
    return atExplicitKey && storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), detected && (state.tag = _tag, state.anchor = _anchor, state.kind = "mapping", state.result = _result), detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = !1, isNamed = !1, tagHandle, tagName, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 33) return !1;
    if (state.tag !== null && throwError2(state, "duplication of a tag property"), ch = state.input.charCodeAt(++state.position), ch === 60 ? (isVerbatim = !0, ch = state.input.charCodeAt(++state.position)) : ch === 33 ? (isNamed = !0, tagHandle = "!!", ch = state.input.charCodeAt(++state.position)) : tagHandle = "!", _position = state.position, isVerbatim) {
      do
        ch = state.input.charCodeAt(++state.position);
      while (ch !== 0 && ch !== 62);
      state.position < state.length ? (tagName = state.input.slice(_position, state.position), ch = state.input.charCodeAt(++state.position)) : throwError2(state, "unexpected end of the stream within a verbatim tag");
    } else {
      for (; ch !== 0 && !is_WS_OR_EOL(ch); )
        ch === 33 && (isNamed ? throwError2(state, "tag suffix cannot contain exclamation marks") : (tagHandle = state.input.slice(_position - 1, state.position + 1), PATTERN_TAG_HANDLE.test(tagHandle) || throwError2(state, "named tag handle cannot contain such characters"), isNamed = !0, _position = state.position + 1)), ch = state.input.charCodeAt(++state.position);
      tagName = state.input.slice(_position, state.position), PATTERN_FLOW_INDICATORS.test(tagName) && throwError2(state, "tag suffix cannot contain flow indicator characters");
    }
    return tagName && !PATTERN_TAG_URI.test(tagName) && throwError2(state, "tag name cannot contain such characters: " + tagName), isVerbatim ? state.tag = tagName : _hasOwnProperty.call(state.tagMap, tagHandle) ? state.tag = state.tagMap[tagHandle] + tagName : tagHandle === "!" ? state.tag = "!" + tagName : tagHandle === "!!" ? state.tag = "tag:yaml.org,2002:" + tagName : throwError2(state, 'undeclared tag handle "' + tagHandle + '"'), !0;
  }
  function readAnchorProperty(state) {
    var _position, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 38) return !1;
    for (state.anchor !== null && throwError2(state, "duplication of an anchor property"), ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
      ch = state.input.charCodeAt(++state.position);
    return state.position === _position && throwError2(state, "name of an anchor node must contain at least one character"), state.anchor = state.input.slice(_position, state.position), !0;
  }
  function readAlias(state) {
    var _position, alias, ch;
    if (ch = state.input.charCodeAt(state.position), ch !== 42) return !1;
    for (ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
      ch = state.input.charCodeAt(++state.position);
    return state.position === _position && throwError2(state, "name of an alias node must contain at least one character"), alias = state.input.slice(_position, state.position), _hasOwnProperty.call(state.anchorMap, alias) || throwError2(state, 'unidentified alias "' + alias + '"'), state.result = state.anchorMap[alias], skipSeparationSpace(state, !0, -1), !0;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = !1, hasContent = !1, typeIndex, typeQuantity, type2, flowIndent, blockIndent;
    if (state.listener !== null && state.listener("open", state), state.tag = null, state.anchor = null, state.kind = null, state.result = null, allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext, allowToSeek && skipSeparationSpace(state, !0, -1) && (atNewLine = !0, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)), indentStatus === 1)
      for (; readTagProperty(state) || readAnchorProperty(state); )
        skipSeparationSpace(state, !0, -1) ? (atNewLine = !0, allowBlockCollections = allowBlockStyles, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)) : allowBlockCollections = !1;
    if (allowBlockCollections && (allowBlockCollections = atNewLine || allowCompact), (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) && (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext ? flowIndent = parentIndent : flowIndent = parentIndent + 1, blockIndent = state.position - state.lineStart, indentStatus === 1 ? allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent) ? hasContent = !0 : (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent) ? hasContent = !0 : readAlias(state) ? (hasContent = !0, (state.tag !== null || state.anchor !== null) && throwError2(state, "alias node should not have any properties")) : readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext) && (hasContent = !0, state.tag === null && (state.tag = "?")), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : indentStatus === 0 && (hasContent = allowBlockCollections && readBlockSequence(state, blockIndent))), state.tag !== null && state.tag !== "!")
      if (state.tag === "?") {
        for (state.result !== null && state.kind !== "scalar" && throwError2(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"'), typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1)
          if (type2 = state.implicitTypes[typeIndex], type2.resolve(state.result)) {
            state.result = type2.construct(state.result), state.tag = type2.tag, state.anchor !== null && (state.anchorMap[state.anchor] = state.result);
            break;
          }
      } else _hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag) ? (type2 = state.typeMap[state.kind || "fallback"][state.tag], state.result !== null && type2.kind !== state.kind && throwError2(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"'), type2.resolve(state.result) ? (state.result = type2.construct(state.result), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : throwError2(state, "cannot resolve a node with !<" + state.tag + "> explicit tag")) : throwError2(state, "unknown tag !<" + state.tag + ">");
    return state.listener !== null && state.listener("close", state), state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = !1, ch;
    for (state.version = null, state.checkLineBreaks = state.legacy, state.tagMap = {}, state.anchorMap = {}; (ch = state.input.charCodeAt(state.position)) !== 0 && (skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), !(state.lineIndent > 0 || ch !== 37)); ) {
      for (hasDirectives = !0, ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
        ch = state.input.charCodeAt(++state.position);
      for (directiveName = state.input.slice(_position, state.position), directiveArgs = [], directiveName.length < 1 && throwError2(state, "directive name must not be less than one character in length"); ch !== 0; ) {
        for (; is_WHITE_SPACE(ch); )
          ch = state.input.charCodeAt(++state.position);
        if (ch === 35) {
          do
            ch = state.input.charCodeAt(++state.position);
          while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch)) break;
        for (_position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
          ch = state.input.charCodeAt(++state.position);
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      ch !== 0 && readLineBreak(state), _hasOwnProperty.call(directiveHandlers, directiveName) ? directiveHandlers[directiveName](state, directiveName, directiveArgs) : throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
    if (skipSeparationSpace(state, !0, -1), state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45 ? (state.position += 3, skipSeparationSpace(state, !0, -1)) : hasDirectives && throwError2(state, "directives end mark is expected"), composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, !1, !0), skipSeparationSpace(state, !0, -1), state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position)) && throwWarning(state, "non-ASCII line breaks are interpreted as content"), state.documents.push(state.result), state.position === state.lineStart && testDocumentSeparator(state)) {
      state.input.charCodeAt(state.position) === 46 && (state.position += 3, skipSeparationSpace(state, !0, -1));
      return;
    }
    if (state.position < state.length - 1)
      throwError2(state, "end of the stream or a document separator is expected");
    else
      return;
  }
  function loadDocuments(input2, options2) {
    input2 = String(input2), options2 = options2 || {}, input2.length !== 0 && (input2.charCodeAt(input2.length - 1) !== 10 && input2.charCodeAt(input2.length - 1) !== 13 && (input2 += `
`), input2.charCodeAt(0) === 65279 && (input2 = input2.slice(1)));
    var state = new State(input2, options2), nullpos = input2.indexOf("\0");
    for (nullpos !== -1 && (state.position = nullpos, throwError2(state, "null byte is not allowed in input")), state.input += "\0"; state.input.charCodeAt(state.position) === 32; )
      state.lineIndent += 1, state.position += 1;
    for (; state.position < state.length - 1; )
      readDocument(state);
    return state.documents;
  }
  function loadAll(input2, iterator2, options2) {
    iterator2 !== null && typeof iterator2 == "object" && typeof options2 > "u" && (options2 = iterator2, iterator2 = null);
    var documents = loadDocuments(input2, options2);
    if (typeof iterator2 != "function")
      return documents;
    for (var index = 0, length = documents.length; index < length; index += 1)
      iterator2(documents[index]);
  }
  function load(input2, options2) {
    var documents = loadDocuments(input2, options2);
    if (documents.length !== 0) {
      if (documents.length === 1)
        return documents[0];
      throw new YAMLException("expected a single document in the stream, but found more");
    }
  }
  function safeLoadAll(input2, iterator2, options2) {
    return typeof iterator2 == "object" && iterator2 !== null && typeof options2 > "u" && (options2 = iterator2, iterator2 = null), loadAll(input2, iterator2, common2.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  function safeLoad(input2, options2) {
    return load(input2, common2.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  return loader.loadAll = loadAll, loader.load = load, loader.safeLoadAll = safeLoadAll, loader.safeLoad = safeLoad, loader;
}
var dumper = {}, hasRequiredDumper;
function requireDumper() {
  if (hasRequiredDumper) return dumper;
  hasRequiredDumper = 1;
  var common2 = requireCommon(), YAMLException = requireException(), DEFAULT_FULL_SCHEMA = requireDefault_full(), DEFAULT_SAFE_SCHEMA = requireDefault_safe(), _toString = Object.prototype.toString, _hasOwnProperty = Object.prototype.hasOwnProperty, CHAR_TAB = 9, CHAR_LINE_FEED = 10, CHAR_CARRIAGE_RETURN = 13, CHAR_SPACE = 32, CHAR_EXCLAMATION = 33, CHAR_DOUBLE_QUOTE = 34, CHAR_SHARP = 35, CHAR_PERCENT = 37, CHAR_AMPERSAND = 38, CHAR_SINGLE_QUOTE = 39, CHAR_ASTERISK = 42, CHAR_COMMA2 = 44, CHAR_MINUS = 45, CHAR_COLON2 = 58, CHAR_EQUALS2 = 61, CHAR_GREATER_THAN = 62, CHAR_QUESTION = 63, CHAR_COMMERCIAL_AT = 64, CHAR_LEFT_SQUARE_BRACKET = 91, CHAR_RIGHT_SQUARE_BRACKET = 93, CHAR_GRAVE_ACCENT = 96, CHAR_LEFT_CURLY_BRACKET = 123, CHAR_VERTICAL_LINE = 124, CHAR_RIGHT_CURLY_BRACKET = 125, ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0", ESCAPE_SEQUENCES[7] = "\\a", ESCAPE_SEQUENCES[8] = "\\b", ESCAPE_SEQUENCES[9] = "\\t", ESCAPE_SEQUENCES[10] = "\\n", ESCAPE_SEQUENCES[11] = "\\v", ESCAPE_SEQUENCES[12] = "\\f", ESCAPE_SEQUENCES[13] = "\\r", ESCAPE_SEQUENCES[27] = "\\e", ESCAPE_SEQUENCES[34] = '\\"', ESCAPE_SEQUENCES[92] = "\\\\", ESCAPE_SEQUENCES[133] = "\\N", ESCAPE_SEQUENCES[160] = "\\_", ESCAPE_SEQUENCES[8232] = "\\L", ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  function compileStyleMap(schema2, map2) {
    var result, keys, index, length, tag, style, type2;
    if (map2 === null) return {};
    for (result = {}, keys = Object.keys(map2), index = 0, length = keys.length; index < length; index += 1)
      tag = keys[index], style = String(map2[tag]), tag.slice(0, 2) === "!!" && (tag = "tag:yaml.org,2002:" + tag.slice(2)), type2 = schema2.compiledTypeMap.fallback[tag], type2 && _hasOwnProperty.call(type2.styleAliases, style) && (style = type2.styleAliases[style]), result[tag] = style;
    return result;
  }
  function encodeHex(character) {
    var string, handle, length;
    if (string = character.toString(16).toUpperCase(), character <= 255)
      handle = "x", length = 2;
    else if (character <= 65535)
      handle = "u", length = 4;
    else if (character <= 4294967295)
      handle = "U", length = 8;
    else
      throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + handle + common2.repeat("0", length - string.length) + string;
  }
  function State(options2) {
    this.schema = options2.schema || DEFAULT_FULL_SCHEMA, this.indent = Math.max(1, options2.indent || 2), this.noArrayIndent = options2.noArrayIndent || !1, this.skipInvalid = options2.skipInvalid || !1, this.flowLevel = common2.isNothing(options2.flowLevel) ? -1 : options2.flowLevel, this.styleMap = compileStyleMap(this.schema, options2.styles || null), this.sortKeys = options2.sortKeys || !1, this.lineWidth = options2.lineWidth || 80, this.noRefs = options2.noRefs || !1, this.noCompatMode = options2.noCompatMode || !1, this.condenseFlow = options2.condenseFlow || !1, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
  }
  function indentString2(string, spaces) {
    for (var ind = common2.repeat(" ", spaces), position = 0, next = -1, result = "", line3, length = string.length; position < length; )
      next = string.indexOf(`
`, position), next === -1 ? (line3 = string.slice(position), position = length) : (line3 = string.slice(position, next + 1), position = next + 1), line3.length && line3 !== `
` && (result += ind), result += line3;
    return result;
  }
  function generateNextLine(state, level) {
    return `
` + common2.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str2) {
    var index, length, type2;
    for (index = 0, length = state.implicitTypes.length; index < length; index += 1)
      if (type2 = state.implicitTypes[index], type2.resolve(str2))
        return !0;
    return !1;
  }
  function isWhitespace(c2) {
    return c2 === CHAR_SPACE || c2 === CHAR_TAB;
  }
  function isPrintable(c2) {
    return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== 65279 || 65536 <= c2 && c2 <= 1114111;
  }
  function isNsChar(c2) {
    return isPrintable(c2) && !isWhitespace(c2) && c2 !== 65279 && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c2, prev) {
    return isPrintable(c2) && c2 !== 65279 && c2 !== CHAR_COMMA2 && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_COLON2 && (c2 !== CHAR_SHARP || prev && isNsChar(prev));
  }
  function isPlainSafeFirst(c2) {
    return isPrintable(c2) && c2 !== 65279 && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON2 && c2 !== CHAR_COMMA2 && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS2 && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
  }
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }
  var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
    var i, char, prev_char, hasLineBreak = !1, hasFoldableLine = !1, shouldTrackWidth = lineWidth !== -1, previousLineBreak = -1, plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
    if (singleLineOnly)
      for (i = 0; i < string.length; i++) {
        if (char = string.charCodeAt(i), !isPrintable(char))
          return STYLE_DOUBLE;
        prev_char = i > 0 ? string.charCodeAt(i - 1) : null, plain = plain && isPlainSafe(char, prev_char);
      }
    else {
      for (i = 0; i < string.length; i++) {
        if (char = string.charCodeAt(i), char === CHAR_LINE_FEED)
          hasLineBreak = !0, shouldTrackWidth && (hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ", previousLineBreak = i);
        else if (!isPrintable(char))
          return STYLE_DOUBLE;
        prev_char = i > 0 ? string.charCodeAt(i - 1) : null, plain = plain && isPlainSafe(char, prev_char);
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
    }
    return !hasLineBreak && !hasFoldableLine ? plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE : indentPerLevel > 9 && needIndentIndicator(string) ? STYLE_DOUBLE : hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  function writeScalar(state, string, level, iskey) {
    state.dump = function() {
      if (string.length === 0)
        return "''";
      if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1)
        return "'" + string + "'";
      var indent = state.indent * Math.max(1, level), lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent), singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state, string2);
      }
      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString2(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString2(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';
        default:
          throw new YAMLException("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "", clip = string[string.length - 1] === `
`, keep = clip && (string[string.length - 2] === `
` || string === `
`), chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + `
`;
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === `
` ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    for (var lineRe = /(\n+)([^\n]*)/g, result = function() {
      var nextLF = string.indexOf(`
`);
      return nextLF = nextLF !== -1 ? nextLF : string.length, lineRe.lastIndex = nextLF, foldLine(string.slice(0, nextLF), width);
    }(), prevMoreIndented = string[0] === `
` || string[0] === " ", moreIndented, match2; match2 = lineRe.exec(string); ) {
      var prefix = match2[1], line3 = match2[2];
      moreIndented = line3[0] === " ", result += prefix + (!prevMoreIndented && !moreIndented && line3 !== "" ? `
` : "") + foldLine(line3, width), prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line3, width) {
    if (line3 === "" || line3[0] === " ") return line3;
    for (var breakRe = / [^ ]/g, match2, start = 0, end, curr = 0, next = 0, result = ""; match2 = breakRe.exec(line3); )
      next = match2.index, next - start > width && (end = curr > start ? curr : next, result += `
` + line3.slice(start, end), start = end + 1), curr = next;
    return result += `
`, line3.length - start > width && curr > start ? result += line3.slice(start, curr) + `
` + line3.slice(curr + 1) : result += line3.slice(start), result.slice(1);
  }
  function escapeString(string) {
    for (var result = "", char, nextChar, escapeSeq, i = 0; i < string.length; i++) {
      if (char = string.charCodeAt(i), char >= 55296 && char <= 56319 && (nextChar = string.charCodeAt(i + 1), nextChar >= 56320 && nextChar <= 57343)) {
        result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536), i++;
        continue;
      }
      escapeSeq = ESCAPE_SEQUENCES[char], result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
    }
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length;
    for (index = 0, length = object.length; index < length; index += 1)
      writeNode(state, level, object[index], !1, !1) && (index !== 0 && (_result += "," + (state.condenseFlow ? "" : " ")), _result += state.dump);
    state.tag = _tag, state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length;
    for (index = 0, length = object.length; index < length; index += 1)
      writeNode(state, level + 1, object[index], !0, !0) && ((!compact || index !== 0) && (_result += generateNextLine(state, level)), state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? _result += "-" : _result += "- ", _result += state.dump);
    state.tag = _tag, state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length; index < length; index += 1)
      pairBuffer = "", index !== 0 && (pairBuffer += ", "), state.condenseFlow && (pairBuffer += '"'), objectKey = objectKeyList[index], objectValue = object[objectKey], writeNode(state, level, objectKey, !1, !1) && (state.dump.length > 1024 && (pairBuffer += "? "), pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " "), writeNode(state, level, objectValue, !1, !1) && (pairBuffer += state.dump, _result += pairBuffer));
    state.tag = _tag, state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === !0)
      objectKeyList.sort();
    else if (typeof state.sortKeys == "function")
      objectKeyList.sort(state.sortKeys);
    else if (state.sortKeys)
      throw new YAMLException("sortKeys must be a boolean or a function");
    for (index = 0, length = objectKeyList.length; index < length; index += 1)
      pairBuffer = "", (!compact || index !== 0) && (pairBuffer += generateNextLine(state, level)), objectKey = objectKeyList[index], objectValue = object[objectKey], writeNode(state, level + 1, objectKey, !0, !0, !0) && (explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024, explicitPair && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += "?" : pairBuffer += "? "), pairBuffer += state.dump, explicitPair && (pairBuffer += generateNextLine(state, level)), writeNode(state, level + 1, objectValue, !0, explicitPair) && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += ":" : pairBuffer += ": ", pairBuffer += state.dump, _result += pairBuffer));
    state.tag = _tag, state.dump = _result || "{}";
  }
  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type2, style;
    for (typeList = explicit ? state.explicitTypes : state.implicitTypes, index = 0, length = typeList.length; index < length; index += 1)
      if (type2 = typeList[index], (type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object == "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
        if (state.tag = explicit ? type2.tag : "?", type2.represent) {
          if (style = state.styleMap[type2.tag] || type2.defaultStyle, _toString.call(type2.represent) === "[object Function]")
            _result = type2.represent(object, style);
          else if (_hasOwnProperty.call(type2.represent, style))
            _result = type2.represent[style](object, style);
          else
            throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
          state.dump = _result;
        }
        return !0;
      }
    return !1;
  }
  function writeNode(state, level, object, block, compact, iskey) {
    state.tag = null, state.dump = object, detectType(state, object, !1) || detectType(state, object, !0);
    var type2 = _toString.call(state.dump);
    block && (block = state.flowLevel < 0 || state.flowLevel > level);
    var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray && (duplicateIndex = state.duplicates.indexOf(object), duplicate = duplicateIndex !== -1), (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) && (compact = !1), duplicate && state.usedDuplicates[duplicateIndex])
      state.dump = "*ref_" + duplicateIndex;
    else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex] && (state.usedDuplicates[duplicateIndex] = !0), type2 === "[object Object]")
        block && Object.keys(state.dump).length !== 0 ? (writeBlockMapping(state, level, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowMapping(state, level, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
      else if (type2 === "[object Array]") {
        var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
        block && state.dump.length !== 0 ? (writeBlockSequence(state, arrayLevel, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowSequence(state, arrayLevel, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
      } else if (type2 === "[object String]")
        state.tag !== "?" && writeScalar(state, state.dump, level, iskey);
      else {
        if (state.skipInvalid) return !1;
        throw new YAMLException("unacceptable kind of an object to dump " + type2);
      }
      state.tag !== null && state.tag !== "?" && (state.dump = "!<" + state.tag + "> " + state.dump);
    }
    return !0;
  }
  function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    for (inspectNode(object, objects, duplicatesIndexes), index = 0, length = duplicatesIndexes.length; index < length; index += 1)
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object == "object")
      if (index = objects.indexOf(object), index !== -1)
        duplicatesIndexes.indexOf(index) === -1 && duplicatesIndexes.push(index);
      else if (objects.push(object), Array.isArray(object))
        for (index = 0, length = object.length; index < length; index += 1)
          inspectNode(object[index], objects, duplicatesIndexes);
      else
        for (objectKeyList = Object.keys(object), index = 0, length = objectKeyList.length; index < length; index += 1)
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
  }
  function dump(input2, options2) {
    options2 = options2 || {};
    var state = new State(options2);
    return state.noRefs || getDuplicateReferences(input2, state), writeNode(state, 0, input2, !0, !0) ? state.dump + `
` : "";
  }
  function safeDump(input2, options2) {
    return dump(input2, common2.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  return dumper.dump = dump, dumper.safeDump = safeDump, dumper;
}
var hasRequiredJsYaml$1;
function requireJsYaml$1() {
  if (hasRequiredJsYaml$1) return jsYaml$1;
  hasRequiredJsYaml$1 = 1;
  var loader2 = requireLoader(), dumper2 = requireDumper();
  function deprecated(name) {
    return function() {
      throw new Error("Function " + name + " is deprecated and cannot be used.");
    };
  }
  return jsYaml$1.Type = requireType(), jsYaml$1.Schema = requireSchema(), jsYaml$1.FAILSAFE_SCHEMA = requireFailsafe(), jsYaml$1.JSON_SCHEMA = requireJson(), jsYaml$1.CORE_SCHEMA = requireCore$2(), jsYaml$1.DEFAULT_SAFE_SCHEMA = requireDefault_safe(), jsYaml$1.DEFAULT_FULL_SCHEMA = requireDefault_full(), jsYaml$1.load = loader2.load, jsYaml$1.loadAll = loader2.loadAll, jsYaml$1.safeLoad = loader2.safeLoad, jsYaml$1.safeLoadAll = loader2.safeLoadAll, jsYaml$1.dump = dumper2.dump, jsYaml$1.safeDump = dumper2.safeDump, jsYaml$1.YAMLException = requireException(), jsYaml$1.MINIMAL_SCHEMA = requireFailsafe(), jsYaml$1.SAFE_SCHEMA = requireDefault_safe(), jsYaml$1.DEFAULT_SCHEMA = requireDefault_full(), jsYaml$1.scan = deprecated("scan"), jsYaml$1.parse = deprecated("parse"), jsYaml$1.compose = deprecated("compose"), jsYaml$1.addConstructor = deprecated("addConstructor"), jsYaml$1;
}
var jsYaml, hasRequiredJsYaml;
function requireJsYaml() {
  if (hasRequiredJsYaml) return jsYaml;
  hasRequiredJsYaml = 1;
  var yaml = requireJsYaml$1();
  return jsYaml = yaml, jsYaml;
}
var hasRequiredLoadYamlFile;
function requireLoadYamlFile() {
  if (hasRequiredLoadYamlFile) return loadYamlFile.exports;
  hasRequiredLoadYamlFile = 1;
  const fs2 = requireGracefulFs(), pify2 = requirePify(), stripBom2 = requireStripBom(), yaml = requireJsYaml(), parse3 = (data) => yaml.safeLoad(stripBom2(data));
  return loadYamlFile.exports = (fp) => pify2(fs2.readFile)(fp, "utf8").then((data) => parse3(data)), loadYamlFile.exports.sync = (fp) => parse3(fs2.readFileSync(fp, "utf8")), loadYamlFile.exports;
}
var whichPm, hasRequiredWhichPm;
function requireWhichPm() {
  if (hasRequiredWhichPm) return whichPm;
  hasRequiredWhichPm = 1;
  const path2 = require$$0__default$1.default, pathExists2 = requirePathExists(), loadYamlFile2 = requireLoadYamlFile();
  whichPm = async function(pkgPath) {
    const modulesPath = path2.join(pkgPath, "node_modules");
    if (await pathExists2(path2.join(modulesPath, ".yarn-integrity"))) return { name: "yarn" };
    if (await pathExists2(path2.join(pkgPath, "bun.lockb"))) return { name: "bun" };
    try {
      const modules = await loadYamlFile2(path2.join(modulesPath, ".modules.yaml"));
      return toNameAndVersion(modules.packageManager);
    } catch (err) {
      if (err.code !== "ENOENT") throw err;
    }
    return await pathExists2(modulesPath) ? { name: "npm" } : null;
  };
  function toNameAndVersion(pkgSpec) {
    if (pkgSpec[0] === "@") {
      const parts2 = pkgSpec.substr(1).split("@");
      return {
        name: `@${parts2[0]}`,
        version: parts2[1]
      };
    }
    const parts = pkgSpec.split("@");
    return {
      name: parts[0],
      version: parts[1]
    };
  }
  return whichPm;
}
var preferredPm, hasRequiredPreferredPm;
function requirePreferredPm() {
  if (hasRequiredPreferredPm) return preferredPm;
  hasRequiredPreferredPm = 1;
  const findYarnWorkspaceRoot = requireFindYarnWorkspaceRoot2(), findUp2 = requireFindUp(), path2 = require$$0__default$1.default, pathExists2 = requirePathExists(), whichPM = requireWhichPm();
  return preferredPm = async function(pkgPath) {
    if (typeof pkgPath != "string")
      throw new TypeError(`pkgPath should be a string, got ${typeof pkgPath}`);
    if (await pathExists2(path2.join(pkgPath, "package-lock.json")))
      return {
        name: "npm",
        version: ">=5"
      };
    if (await pathExists2(path2.join(pkgPath, "yarn.lock")))
      return {
        name: "yarn",
        version: "*"
      };
    if (await pathExists2(path2.join(pkgPath, "pnpm-lock.yaml")))
      return {
        name: "pnpm",
        version: ">=3"
      };
    if (await pathExists2(path2.join(pkgPath, "shrinkwrap.yaml")))
      return {
        name: "pnpm",
        version: "1 || 2"
      };
    if (await pathExists2(path2.join(pkgPath, "bun.lockb")))
      return {
        name: "bun",
        version: "*"
      };
    if (await findUp2("pnpm-lock.yaml", { cwd: pkgPath }))
      return {
        name: "pnpm",
        version: ">=3"
      };
    try {
      const workspaceRoot = findYarnWorkspaceRoot(pkgPath);
      if (typeof workspaceRoot == "string")
        return await pathExists2(path2.join(workspaceRoot, "package-lock.json")) ? {
          name: "npm",
          version: ">=7"
        } : {
          name: "yarn",
          version: "*"
        };
    } catch {
    }
    const pm = await whichPM(pkgPath);
    return pm && { name: pm.name, version: pm.version || "*" };
  }, preferredPm;
}
var preferredPmExports = requirePreferredPm(), preferredPM = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(preferredPmExports), whichExports = requireWhich(), which = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(whichExports);
const isInteractive$1 = process.stdout.isTTY && process.env.TERM !== "dumb" && !("CI" in process.env), ALLOWED_PACKAGE_MANAGERS = ["npm", "yarn", "pnpm", "bun", "manual"], allowedPackageManagersString = ALLOWED_PACKAGE_MANAGERS.map((pm) => `"${pm}"`).join(
  " | "
), EXPERIMENTAL = ["bun"];
async function getPackageManagerChoice(workDir, options2) {
  const rootDir = workDir || process.cwd(), preferred = (await preferredPM(rootDir))?.name;
  if (preferred && await hasCommand(preferred, rootDir))
    return { chosen: preferred, mostOptimal: preferred };
  const mostLikelyPM = await getMostLikelyInstalledPackageManager(rootDir);
  if (!(typeof options2.interactive == "boolean" ? options2.interactive : isInteractive$1))
    return { chosen: mostLikelyPM || await getFallback(rootDir), mostOptimal: preferred };
  if (!("prompt" in options2))
    throw new Error("Must pass `prompt` when in interactive mode");
  const messageSuffix = preferred ? ` (preferred is ${preferred}, but is not installed)` : "", installed = await getAvailablePackageManagers(rootDir);
  return { chosen: await options2.prompt.single({
    type: "list",
    choices: installed.map((pm) => ({
      value: pm,
      name: EXPERIMENTAL.includes(pm) ? `${pm} (experimental)` : pm
    })),
    default: preferred || mostLikelyPM,
    message: `Package manager to use for installing dependencies?${messageSuffix}`
  }), mostOptimal: preferred };
}
async function getFallback(cwd) {
  return await hasNpmInstalled(cwd) ? "npm" : await hasYarnInstalled(cwd) ? "yarn" : await hasPnpmInstalled(cwd) ? "pnpm" : await hasBunInstalled(cwd) ? "bun" : "manual";
}
async function getAvailablePackageManagers(cwd) {
  const [npm, yarn, pnpm, bun] = await Promise.all([
    hasNpmInstalled(cwd),
    hasYarnInstalled(cwd),
    hasPnpmInstalled(cwd),
    hasBunInstalled(cwd)
  ]);
  return [npm && "npm", yarn && "yarn", pnpm && "pnpm", bun && "bun", "manual"].filter((pm) => pm !== !1);
}
function hasNpmInstalled(cwd) {
  return hasCommand("npm", cwd);
}
function hasYarnInstalled(cwd) {
  return hasCommand("yarn", cwd);
}
function hasPnpmInstalled(cwd) {
  return hasCommand("pnpm", cwd);
}
function hasBunInstalled(cwd) {
  return hasCommand("bun", cwd);
}
function getNpmRunPath(cwd) {
  let previous, cwdPath = path__default.default.resolve(cwd);
  const result = [];
  for (; previous !== cwdPath; )
    result.push(path__default.default.join(cwdPath, "node_modules", ".bin")), previous = cwdPath, cwdPath = path__default.default.resolve(cwdPath, "..");
  result.push(path__default.default.resolve(cwd, process.execPath, ".."));
  const pathEnv = process.env[getPathEnvVarKey()];
  return [...result, pathEnv].join(path__default.default.delimiter);
}
function getPartialEnvWithNpmPath(cwd) {
  return { [getPathEnvVarKey()]: getNpmRunPath(cwd) };
}
function getPathEnvVarKey() {
  return process.platform !== "win32" ? "PATH" : Object.keys(process.env).reverse().find((key2) => key2.toUpperCase() === "PATH") || "Path";
}
function getCommandPath(cmd, cwd) {
  const options2 = cwd ? { path: getNpmRunPath(cwd) } : {};
  return which(cmd, options2).catch(() => null);
}
function hasCommand(cmd, cwd) {
  return getCommandPath(cmd, cwd).then((cmdPath) => cmdPath !== null);
}
async function getMostLikelyInstalledPackageManager(rootDir) {
  const installed = await getAvailablePackageManagers(rootDir), running = getRunningPackageManager();
  return running && installed.includes(running) ? running : void 0;
}
function getRunningPackageManager() {
  const agent = process.env.npm_config_user_agent || "";
  if (agent.includes("yarn"))
    return "yarn";
  if (agent.includes("pnpm"))
    return "pnpm";
  if (agent.includes("bun"))
    return "bun";
  if (/^npm\/\d/.test(agent))
    return "npm";
}
async function getInstallCommand(options2) {
  const { workDir, depType = "prod", pkgNames } = options2, { chosen } = await getPackageManagerChoice(workDir, { interactive: !1 });
  if (!pkgNames || pkgNames.length === 0)
    return `${chosen} install`;
  const pkgNameString = pkgNames.join(" ");
  if (chosen === "yarn") {
    const flag = depType === "dev" || depType === "peer" ? ` --${depType}` : "";
    return `yarn add ${pkgNameString}${flag}`;
  } else if (chosen === "pnpm")
    return `pnpm add ${pkgNameString} --save-${depType}`;
  return `npm install ${pkgNameString} --save-${depType}`;
}
var globalDirs = {}, ini, hasRequiredIni;
function requireIni() {
  if (hasRequiredIni) return ini;
  hasRequiredIni = 1;
  const { hasOwnProperty: hasOwnProperty2 } = Object.prototype, eol = typeof process < "u" && process.platform === "win32" ? `\r
` : `
`, encode = (obj, opt) => {
    const children = [];
    let out = "";
    typeof opt == "string" ? opt = {
      section: opt,
      whitespace: !1
    } : (opt = opt || /* @__PURE__ */ Object.create(null), opt.whitespace = opt.whitespace === !0);
    const separator2 = opt.whitespace ? " = " : "=";
    for (const k of Object.keys(obj)) {
      const val = obj[k];
      if (val && Array.isArray(val))
        for (const item of val)
          out += safe(k + "[]") + separator2 + safe(item) + `
`;
      else val && typeof val == "object" ? children.push(k) : out += safe(k) + separator2 + safe(val) + eol;
    }
    opt.section && out.length && (out = "[" + safe(opt.section) + "]" + eol + out);
    for (const k of children) {
      const nk = dotSplit(k).join("\\."), section = (opt.section ? opt.section + "." : "") + nk, { whitespace } = opt, child = encode(obj[k], {
        section,
        whitespace
      });
      out.length && child.length && (out += eol), out += child;
    }
    return out;
  }, dotSplit = (str2) => str2.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map((part) => part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "")), decode = (str2) => {
    const out = /* @__PURE__ */ Object.create(null);
    let p = out, section = null;
    const re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i, lines2 = str2.split(/[\r\n]+/g);
    for (const line3 of lines2) {
      if (!line3 || line3.match(/^\s*[;#]/))
        continue;
      const match2 = line3.match(re);
      if (!match2)
        continue;
      if (match2[1] !== void 0) {
        if (section = unsafe(match2[1]), section === "__proto__") {
          p = /* @__PURE__ */ Object.create(null);
          continue;
        }
        p = out[section] = out[section] || /* @__PURE__ */ Object.create(null);
        continue;
      }
      const keyRaw = unsafe(match2[2]), isArray2 = keyRaw.length > 2 && keyRaw.slice(-2) === "[]", key2 = isArray2 ? keyRaw.slice(0, -2) : keyRaw;
      if (key2 === "__proto__")
        continue;
      const valueRaw = match2[3] ? unsafe(match2[4]) : !0, value = valueRaw === "true" || valueRaw === "false" || valueRaw === "null" ? JSON.parse(valueRaw) : valueRaw;
      isArray2 && (hasOwnProperty2.call(p, key2) ? Array.isArray(p[key2]) || (p[key2] = [p[key2]]) : p[key2] = []), Array.isArray(p[key2]) ? p[key2].push(value) : p[key2] = value;
    }
    const remove = [];
    for (const k of Object.keys(out)) {
      if (!hasOwnProperty2.call(out, k) || typeof out[k] != "object" || Array.isArray(out[k]))
        continue;
      const parts = dotSplit(k);
      let p2 = out;
      const l = parts.pop(), nl = l.replace(/\\\./g, ".");
      for (const part of parts)
        part !== "__proto__" && ((!hasOwnProperty2.call(p2, part) || typeof p2[part] != "object") && (p2[part] = /* @__PURE__ */ Object.create(null)), p2 = p2[part]);
      p2 === out && nl === l || (p2[nl] = out[k], remove.push(k));
    }
    for (const del of remove)
      delete out[del];
    return out;
  }, isQuoted = (val) => val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'", safe = (val) => typeof val != "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#"), unsafe = (val, doUnesc) => {
    if (val = (val || "").trim(), isQuoted(val)) {
      val.charAt(0) === "'" && (val = val.substr(1, val.length - 2));
      try {
        val = JSON.parse(val);
      } catch {
      }
    } else {
      let esc = !1, unesc = "";
      for (let i = 0, l = val.length; i < l; i++) {
        const c2 = val.charAt(i);
        if (esc)
          "\\;#".indexOf(c2) !== -1 ? unesc += c2 : unesc += "\\" + c2, esc = !1;
        else {
          if (";#".indexOf(c2) !== -1)
            break;
          c2 === "\\" ? esc = !0 : unesc += c2;
        }
      }
      return esc && (unesc += "\\"), unesc.trim();
    }
    return val;
  };
  return ini = {
    parse: decode,
    decode,
    stringify: encode,
    encode,
    safe,
    unsafe
  }, ini;
}
var hasRequiredGlobalDirs;
function requireGlobalDirs() {
  return hasRequiredGlobalDirs || (hasRequiredGlobalDirs = 1, function(exports2) {
    const path2 = require$$0__default$1.default, os2 = require$$0__default$2.default, fs2 = require$$0__default.default, ini2 = requireIni(), isWindows = process.platform === "win32", readRc = (filePath) => {
      try {
        return ini2.parse(fs2.readFileSync(filePath, "utf8")).prefix;
      } catch {
      }
    }, getEnvNpmPrefix = () => Object.keys(process.env).reduce((prefix, name) => /^npm_config_prefix$/i.test(name) ? process.env[name] : prefix, void 0), getGlobalNpmrc = () => {
      if (isWindows && process.env.APPDATA)
        return path2.join(process.env.APPDATA, "/npm/etc/npmrc");
      if (process.execPath.includes("/Cellar/node")) {
        const homebrewPrefix = process.execPath.slice(0, process.execPath.indexOf("/Cellar/node"));
        return path2.join(homebrewPrefix, "/lib/node_modules/npm/npmrc");
      }
      if (process.execPath.endsWith("/bin/node")) {
        const installDir = path2.dirname(path2.dirname(process.execPath));
        return path2.join(installDir, "/etc/npmrc");
      }
    }, getDefaultNpmPrefix = () => {
      if (isWindows) {
        const { APPDATA } = process.env;
        return APPDATA ? path2.join(APPDATA, "npm") : path2.dirname(process.execPath);
      }
      return path2.dirname(path2.dirname(process.execPath));
    }, getNpmPrefix = () => {
      const envPrefix = getEnvNpmPrefix();
      if (envPrefix)
        return envPrefix;
      const homePrefix = readRc(path2.join(os2.homedir(), ".npmrc"));
      if (homePrefix)
        return homePrefix;
      if (process.env.PREFIX)
        return process.env.PREFIX;
      const globalPrefix = readRc(getGlobalNpmrc());
      return globalPrefix || getDefaultNpmPrefix();
    }, npmPrefix = path2.resolve(getNpmPrefix()), getYarnWindowsDirectory = () => {
      if (isWindows && process.env.LOCALAPPDATA) {
        const dir = path2.join(process.env.LOCALAPPDATA, "Yarn");
        if (fs2.existsSync(dir))
          return dir;
      }
      return !1;
    }, getYarnPrefix = () => {
      if (process.env.PREFIX)
        return process.env.PREFIX;
      const windowsPrefix = getYarnWindowsDirectory();
      if (windowsPrefix)
        return windowsPrefix;
      const configPrefix = path2.join(os2.homedir(), ".config/yarn");
      if (fs2.existsSync(configPrefix))
        return configPrefix;
      const homePrefix = path2.join(os2.homedir(), ".yarn-config");
      return fs2.existsSync(homePrefix) ? homePrefix : npmPrefix;
    };
    exports2.npm = {}, exports2.npm.prefix = npmPrefix, exports2.npm.packages = path2.join(npmPrefix, isWindows ? "node_modules" : "lib/node_modules"), exports2.npm.binaries = isWindows ? npmPrefix : path2.join(npmPrefix, "bin");
    const yarnPrefix = path2.resolve(getYarnPrefix());
    exports2.yarn = {}, exports2.yarn.prefix = yarnPrefix, exports2.yarn.packages = path2.join(yarnPrefix, getYarnWindowsDirectory() ? "Data/global/node_modules" : "global/node_modules"), exports2.yarn.binaries = path2.join(exports2.yarn.packages, ".bin");
  }(globalDirs)), globalDirs;
}
var isPathInside, hasRequiredIsPathInside;
function requireIsPathInside() {
  if (hasRequiredIsPathInside) return isPathInside;
  hasRequiredIsPathInside = 1;
  const path2 = require$$0__default$1.default;
  return isPathInside = (childPath, parentPath) => {
    const relation = path2.relative(parentPath, childPath);
    return !!(relation && relation !== ".." && !relation.startsWith(`..${path2.sep}`) && relation !== path2.resolve(childPath));
  }, isPathInside;
}
var isInstalledGlobally$1, hasRequiredIsInstalledGlobally;
function requireIsInstalledGlobally() {
  if (hasRequiredIsInstalledGlobally) return isInstalledGlobally$1;
  hasRequiredIsInstalledGlobally = 1;
  const fs2 = require$$0__default.default, globalDirs2 = requireGlobalDirs(), isPathInside2 = requireIsPathInside();
  return isInstalledGlobally$1 = (() => {
    try {
      return isPathInside2(__dirname, globalDirs2.yarn.packages) || isPathInside2(__dirname, fs2.realpathSync(globalDirs2.npm.packages));
    } catch {
      return !1;
    }
  })(), isInstalledGlobally$1;
}
var isInstalledGloballyExports = requireIsInstalledGlobally(), isInstalledGlobally = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(isInstalledGloballyExports);
const cliPkgName = "@sanity/cli";
async function getCliUpgradeCommand(options2 = {}) {
  let { cwd, workDir } = options2;
  if (cwd = path__default.default.resolve(cwd || process.cwd()), workDir = path__default.default.resolve(workDir || cwd), isInstalledGlobally && isInstalledUsingYarn())
    return loadEnv.debug("CLI is installed globally with yarn"), `yarn global add ${cliPkgName}`;
  if (isInstalledGlobally)
    return loadEnv.debug("CLI is installed globally with npm"), `npm install -g ${cliPkgName}`;
  const cmds = cwd === workDir ? [] : [`cd ${path__default.default.relative(cwd, workDir)}`], { chosen } = await getPackageManagerChoice(workDir, { interactive: !1 });
  return chosen === "yarn" ? cmds.push(`yarn upgrade ${cliPkgName}`) : chosen === "pnpm" ? cmds.push(`pnpm update ${cliPkgName}`) : cmds.push(`npm update ${cliPkgName}`), cmds.join(" && ");
}
function isInstalledUsingYarn() {
  const yarnPath = process.platform === "win32" ? path__default.default.join("Yarn", "config", "global") : path__default.default.join(".config", "yarn", "global");
  return __dirname.includes(yarnPath);
}
async function installDeclaredPackages(cwd, packageManager, context) {
  const { output } = context, execOptions = {
    encoding: "utf8",
    env: getPartialEnvWithNpmPath(cwd),
    cwd,
    stdio: "pipe"
  };
  let result;
  const installerArgs = {
    npm: ["install", "--legacy-peer-deps"],
    yarn: ["install"],
    pnpm: ["install"],
    bun: ["install"]
  };
  async function handleInstall(cmd, args) {
    const progress = output.spinner(`Running ${cmd} ${args.join(" ")}
`).start();
    if (result = await execa(cmd, args, execOptions), result?.exitCode || result?.failed)
      throw progress.fail(), output.print(result.stdout), new Error("Dependency installation failed");
    progress.succeed();
  }
  packageManager === "manual" ? output.print(`Manual installation selected \u2014 run 'npm ${installerArgs.npm} or equivalent'`) : await handleInstall(packageManager, installerArgs[packageManager]);
}
async function installNewPackages(options2, context) {
  const { packageManager, packages } = options2, { output, workDir } = context, execOptions = {
    encoding: "utf8",
    env: getPartialEnvWithNpmPath(workDir),
    cwd: workDir,
    stdio: "inherit"
  }, npmArgs = ["install", "--legacy-peer-deps", "--save", ...packages];
  let result;
  if (packageManager === "npm")
    output.print(`Running 'npm ${npmArgs.join(" ")}'`), result = await execa("npm", npmArgs, execOptions);
  else if (packageManager === "yarn") {
    const yarnArgs = ["add", ...packages];
    output.print(`Running 'yarn ${yarnArgs.join(" ")}'`), result = await execa("yarn", yarnArgs, execOptions);
  } else if (packageManager === "pnpm") {
    const pnpmArgs = ["add", "--save-prod", ...packages];
    output.print(`Running 'pnpm ${pnpmArgs.join(" ")}'`), result = await execa("pnpm", pnpmArgs, execOptions);
  } else if (packageManager === "bun") {
    const bunArgs = ["add", ...packages];
    output.print(`Running 'bun ${bunArgs.join(" ")}'`), result = await execa("bun", bunArgs, execOptions);
  } else packageManager === "manual" && output.print(`Manual installation selected - run 'npm ${npmArgs.join(" ")}' or equivalent`);
  if (result?.exitCode || result?.failed)
    throw new Error("Package installation failed");
}
const cliPackageManager = {
  getInstallCommand,
  getPackageManagerChoice,
  installNewPackages
};
var gitconfiglocal, hasRequiredGitconfiglocal;
function requireGitconfiglocal() {
  if (hasRequiredGitconfiglocal) return gitconfiglocal;
  hasRequiredGitconfiglocal = 1;
  const fs2 = require$$0__default.default.promises, ini2 = requireIni$1(), path2 = require$$0__default$1.default;
  gitconfiglocal = async function(dir, options2 = {}) {
    const config2 = await findGit(dir, options2);
    if (!config2) throw new Error("no gitconfig to be found at " + dir);
    const data = await fs2.readFile(config2);
    return format(ini2.parse(data.toString()));
  };
  function format(data) {
    const out = {};
    return Object.keys(data).forEach(function(k) {
      if (k.indexOf('"') > -1) {
        const parts = k.split('"'), parentKey = parts.shift().trim(), childKey = parts.shift().trim();
        out[parentKey] || (out[parentKey] = {}), out[parentKey][childKey] = data[k];
      } else
        out[k] = { ...out[k], ...data[k] };
    }), out;
  }
  async function findGit(dir, options2) {
    const folder = path2.resolve(
      dir,
      options2.gitDir || process.env.GIT_DIR || ".git",
      "config"
    );
    return await pathExists2(folder) ? folder : dir === path2.resolve(dir, "..") ? !1 : findGit(path2.resolve(dir, ".."), options2);
  }
  function pathExists2(filePath) {
    return fs2.access(filePath).then(
      () => !0,
      () => !1
    );
  }
  return gitconfiglocal;
}
var gitconfiglocalExports = requireGitconfiglocal(), getGitConfig = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(gitconfiglocalExports);
/*!
 * fs-exists-sync (https://github.com/jonschlinkert/fs-exists-sync)
 *
 * Copyright (c) 2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var fsExistsSync, hasRequiredFsExistsSync;
function requireFsExistsSync() {
  if (hasRequiredFsExistsSync) return fsExistsSync;
  hasRequiredFsExistsSync = 1;
  var fs2 = require$$0__default.default;
  return fsExistsSync = function(filepath) {
    try {
      return (fs2.accessSync || fs2.statSync)(filepath), !0;
    } catch {
    }
    return !1;
  }, fsExistsSync;
}
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var isExtendable, hasRequiredIsExtendable;
function requireIsExtendable() {
  return hasRequiredIsExtendable || (hasRequiredIsExtendable = 1, isExtendable = function(val) {
    return typeof val < "u" && val !== null && (typeof val == "object" || typeof val == "function");
  }), isExtendable;
}
var extendShallow, hasRequiredExtendShallow;
function requireExtendShallow() {
  if (hasRequiredExtendShallow) return extendShallow;
  hasRequiredExtendShallow = 1;
  var isObject2 = requireIsExtendable();
  extendShallow = function(o) {
    isObject2(o) || (o = {});
    for (var len = arguments.length, i = 1; i < len; i++) {
      var obj = arguments[i];
      isObject2(obj) && assign(o, obj);
    }
    return o;
  };
  function assign(a, b) {
    for (var key2 in b)
      hasOwn(b, key2) && (a[key2] = b[key2]);
  }
  function hasOwn(obj, key2) {
    return Object.prototype.hasOwnProperty.call(obj, key2);
  }
  return extendShallow;
}
var homedirPolyfill = { exports: {} }, parsePasswd, hasRequiredParsePasswd;
function requireParsePasswd() {
  if (hasRequiredParsePasswd) return parsePasswd;
  hasRequiredParsePasswd = 1, parsePasswd = function(content) {
    if (typeof content != "string")
      throw new Error("expected a string");
    return content.split(`
`).map(user).filter(Boolean);
  };
  function user(line3, i) {
    if (!line3 || !line3.length || line3.charAt(0) === "#")
      return null;
    var fields = line3.split(":");
    return {
      username: fields[0],
      password: fields[1],
      uid: fields[2],
      gid: fields[3],
      // see https://en.wikipedia.org/wiki/Gecos_field for GECOS field descriptions
      gecos: fields[4],
      homedir: fields[5],
      shell: fields[6]
    };
  }
  return parsePasswd;
}
var polyfill, hasRequiredPolyfill;
function requirePolyfill() {
  if (hasRequiredPolyfill) return polyfill;
  hasRequiredPolyfill = 1;
  var fs2 = require$$0__default.default, parse3 = requireParsePasswd();
  function homedir() {
    if (process.platform === "win32")
      return process.env.USERPROFILE ? process.env.USERPROFILE : process.env.HOMEDRIVE && process.env.HOMEPATH ? process.env.HOMEDRIVE + process.env.HOMEPATH : process.env.HOME ? process.env.HOME : null;
    if (process.env.HOME)
      return process.env.HOME;
    var passwd = tryReadFileSync("/etc/passwd"), home = find2(parse3(passwd), getuid());
    if (home)
      return home;
    var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
    return user ? process.platform === "darwin" ? "/Users/" + user : "/home/" + user : null;
  }
  function find2(arr, uid) {
    for (var len = arr.length, i = 0; i < len; i++)
      if (+arr[i].uid === uid)
        return arr[i].homedir;
  }
  function getuid() {
    return typeof process.geteuid == "function" ? process.geteuid() : process.getuid();
  }
  function tryReadFileSync(fp) {
    try {
      return fs2.readFileSync(fp, "utf8");
    } catch {
      return "";
    }
  }
  return polyfill = homedir, polyfill;
}
var hasRequiredHomedirPolyfill;
function requireHomedirPolyfill() {
  if (hasRequiredHomedirPolyfill) return homedirPolyfill.exports;
  hasRequiredHomedirPolyfill = 1;
  var os2 = require$$0__default$2.default;
  return typeof os2.homedir < "u" ? homedirPolyfill.exports = os2.homedir : homedirPolyfill.exports = requirePolyfill(), homedirPolyfill.exports;
}
/*!
 * git-config-path <https://github.com/jonschlinkert/git-config-path>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var gitConfigPath, hasRequiredGitConfigPath;
function requireGitConfigPath() {
  if (hasRequiredGitConfigPath) return gitConfigPath;
  hasRequiredGitConfigPath = 1;
  var path2 = require$$0__default$1.default, exists = requireFsExistsSync(), extend = requireExtendShallow(), homedir = requireHomedirPolyfill();
  return gitConfigPath = function(type2, options2) {
    typeof type2 != "string" && (options2 = type2, type2 = null);
    var opts = extend({ cwd: process.cwd() }, options2);
    type2 = type2 || opts.type;
    var configPath = path2.resolve(opts.cwd, ".git/config");
    if (type2 === "global" && (configPath = path2.join(homedir(), ".gitconfig")), !exists(configPath)) {
      if (typeof type2 == "string")
        return null;
      configPath = path2.join(homedir(), ".config/git/config");
    }
    return exists(configPath) ? configPath : null;
  }, gitConfigPath;
}
/*!
 * parse-git-config <https://github.com/jonschlinkert/parse-git-config>
 *
 * Copyright (c) 2015 Jon Schlinkert.
 * Licensed under the MIT license.
 */
var parseGitConfig, hasRequiredParseGitConfig;
function requireParseGitConfig() {
  if (hasRequiredParseGitConfig) return parseGitConfig;
  hasRequiredParseGitConfig = 1;
  var fs2 = require$$0__default.default, path2 = require$$0__default$1.default, exists = requireFsExistsSync(), extend = requireExtendShallow(), configPath = requireGitConfigPath(), ini2 = requireIni$1();
  function parse3(options2, cb) {
    if (typeof options2 == "function" && (cb = options2, options2 = {}), typeof cb != "function")
      throw new TypeError("parse-git-config async expects a callback function.");
    options2 = options2 || {};
    var filepath = parse3.resolve(options2);
    fs2.stat(filepath, function(err, stat2) {
      if (err) return cb(err);
      fs2.readFile(filepath, "utf8", function(err2, str2) {
        if (err2) return cb(err2);
        var parsed = ini2.parse(str2);
        cb(null, parsed);
      });
    });
  }
  return parse3.sync = function(options2) {
    options2 = options2 || {};
    var filepath = parse3.resolve(options2);
    if (filepath && exists(filepath)) {
      var str2 = fs2.readFileSync(filepath, "utf8");
      return ini2.parse(str2);
    }
    return {};
  }, parse3.resolve = function(options2) {
    typeof options2 == "string" && (options2 = { type: options2 });
    var opts = extend({ cwd: process.cwd() }, options2), fp = opts.path || configPath(opts.type);
    return fp ? path2.resolve(opts.cwd, fp) : null;
  }, parse3.keys = function(config2) {
    var res = {};
    for (var key2 in config2) {
      var m = /(\S+) "(.*)"/.exec(key2);
      if (m) {
        var prop = m[1];
        res[prop] = res[prop] || {}, res[prop][m[2]] = config2[key2];
      }
    }
    return res;
  }, parseGitConfig = parse3, parseGitConfig;
}
var gitUserInfo, hasRequiredGitUserInfo;
function requireGitUserInfo() {
  if (hasRequiredGitUserInfo) return gitUserInfo;
  hasRequiredGitUserInfo = 1;
  const gitconfig = requireGitConfigPath(), parse3 = requireParseGitConfig();
  async function getGitUserInfo(options2 = {}) {
    const opts = { cwd: "/", path: gitconfig(), ...options2 }, user = await getUserFromConfig(opts);
    return user || options2.path ? user : getUserFromConfig({ ...opts, path: gitconfig("global") });
  }
  function getUserFromConfig(options2) {
    return new Promise((resolve, reject) => {
      if (typeof options2.path != "string")
        return resolve(null);
      parse3(options2, (err, config2) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(config2 && config2.user ? config2.user : null);
      });
    });
  }
  return gitUserInfo = {
    getGitUserInfo
  }, gitUserInfo;
}
var gitUserInfoExports = requireGitUserInfo();
function getProjectDefaults(workDir, { isPlugin, context }) {
  const cwd = process.cwd(), isSanityRoot = workDir === cwd;
  return promiseProps({
    license: "UNLICENSED",
    author: getUserInfo(context),
    // Don't try to use git remote from main Sanity project for plugins
    gitRemote: resolveGitRemote(cwd),
    // Don't try to guess plugin name if we're initing from Sanity root
    projectName: path__default.default.basename(cwd),
    // If we're initing a plugin, don't use description from Sanity readme
    description: getProjectDescription({ isSanityRoot, isPlugin, outputDir: cwd })
  });
}
async function resolveGitRemote(cwd) {
  try {
    await fs__default.default.stat(path__default.default.join(cwd, ".git"));
    const cfg = await getGitConfig(cwd);
    return cfg.remote && cfg.remote.origin && cfg.remote.origin.url;
  } catch {
    return;
  }
}
async function getUserInfo(context) {
  const user = await gitUserInfoExports.getGitUserInfo();
  if (!user)
    return getSanityUserInfo(context);
  if (user.name && user.email)
    return `${user.name} <${user.email}>`;
}
async function getSanityUserInfo(context) {
  if (!getCliToken())
    return;
  const client2 = context.apiClient({ requireUser: !0, requireProject: !1 });
  try {
    const user = await client2.users.getById("me");
    return user ? `${user.name} <${user.email}>` : void 0;
  } catch {
    return;
  }
}
async function getProjectDescription({
  isSanityRoot,
  isPlugin,
  outputDir
}) {
  if (!(isSanityRoot && !isPlugin))
    return Promise.resolve("");
  try {
    const readmePath = path__default.default.join(outputDir, "README.md"), match2 = (await fs__default.default.readFile(readmePath, { encoding: "utf8" })).match(/^# .*?\n+(\w.*?)(?:$|\n)/);
    return (match2 && match2[1] || "").replace(/\.$/, "") || "";
  } catch {
    return "";
  }
}
function getProviderName(provider) {
  return provider === "google" ? "Google" : provider === "github" ? "GitHub" : provider === "sanity" ? "Email" : provider.startsWith("saml-") ? "SAML" : provider;
}
var tar = {}, highLevelOpt, hasRequiredHighLevelOpt;
function requireHighLevelOpt() {
  if (hasRequiredHighLevelOpt) return highLevelOpt;
  hasRequiredHighLevelOpt = 1;
  const argmap = /* @__PURE__ */ new Map([
    ["C", "cwd"],
    ["f", "file"],
    ["z", "gzip"],
    ["P", "preservePaths"],
    ["U", "unlink"],
    ["strip-components", "strip"],
    ["stripComponents", "strip"],
    ["keep-newer", "newer"],
    ["keepNewer", "newer"],
    ["keep-newer-files", "newer"],
    ["keepNewerFiles", "newer"],
    ["k", "keep"],
    ["keep-existing", "keep"],
    ["keepExisting", "keep"],
    ["m", "noMtime"],
    ["no-mtime", "noMtime"],
    ["p", "preserveOwner"],
    ["L", "follow"],
    ["h", "follow"]
  ]);
  return highLevelOpt = (opt) => opt ? Object.keys(opt).map((k) => [
    argmap.has(k) ? argmap.get(k) : k,
    opt[k]
  ]).reduce((set2, kv) => (set2[kv[0]] = kv[1], set2), /* @__PURE__ */ Object.create(null)) : {}, highLevelOpt;
}
var minipass$1 = {}, hasRequiredMinipass$1;
function requireMinipass$1() {
  if (hasRequiredMinipass$1) return minipass$1;
  hasRequiredMinipass$1 = 1;
  const proc2 = typeof process == "object" && process ? process : {
    stdout: null,
    stderr: null
  }, EE = require$$0__default$7.default, Stream2 = require$$0__default$4.default, SD = require$$2__default$1.default.StringDecoder, EOF2 = Symbol("EOF"), MAYBE_EMIT_END2 = Symbol("maybeEmitEnd"), EMITTED_END2 = Symbol("emittedEnd"), EMITTING_END2 = Symbol("emittingEnd"), EMITTED_ERROR2 = Symbol("emittedError"), CLOSED2 = Symbol("closed"), READ2 = Symbol("read"), FLUSH2 = Symbol("flush"), FLUSHCHUNK2 = Symbol("flushChunk"), ENCODING2 = Symbol("encoding"), DECODER2 = Symbol("decoder"), FLOWING2 = Symbol("flowing"), PAUSED2 = Symbol("paused"), RESUME2 = Symbol("resume"), BUFFER2 = Symbol("buffer"), PIPES2 = Symbol("pipes"), BUFFERLENGTH2 = Symbol("bufferLength"), BUFFERPUSH2 = Symbol("bufferPush"), BUFFERSHIFT2 = Symbol("bufferShift"), OBJECTMODE2 = Symbol("objectMode"), DESTROYED2 = Symbol("destroyed"), ERROR2 = Symbol("error"), EMITDATA2 = Symbol("emitData"), EMITEND3 = Symbol("emitEnd"), EMITEND22 = Symbol("emitEnd2"), ASYNC2 = Symbol("async"), ABORT2 = Symbol("abort"), ABORTED2 = Symbol("aborted"), SIGNAL2 = Symbol("signal"), defer2 = (fn) => Promise.resolve().then(fn), doIter = loadEnv.commonjsGlobal._MP_NO_ITERATOR_SYMBOLS_ !== "1", ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented"), ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented"), isEndish2 = (ev) => ev === "end" || ev === "finish" || ev === "prefinish", isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b == "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0, isArrayBufferView2 = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
  class Pipe2 {
    constructor(src2, dest, opts) {
      this.src = src2, this.dest = dest, this.opts = opts, this.ondrain = () => src2[RESUME2](), dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    // istanbul ignore next - only here for the prototype
    proxyErrors() {
    }
    end() {
      this.unpipe(), this.opts.end && this.dest.end();
    }
  }
  class PipeProxyErrors2 extends Pipe2 {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors), super.unpipe();
    }
    constructor(src2, dest, opts) {
      super(src2, dest, opts), this.proxyErrors = (er) => dest.emit("error", er), src2.on("error", this.proxyErrors);
    }
  }
  class Minipass2 extends Stream2 {
    constructor(options2) {
      super(), this[FLOWING2] = !1, this[PAUSED2] = !1, this[PIPES2] = [], this[BUFFER2] = [], this[OBJECTMODE2] = options2 && options2.objectMode || !1, this[OBJECTMODE2] ? this[ENCODING2] = null : this[ENCODING2] = options2 && options2.encoding || null, this[ENCODING2] === "buffer" && (this[ENCODING2] = null), this[ASYNC2] = options2 && !!options2.async || !1, this[DECODER2] = this[ENCODING2] ? new SD(this[ENCODING2]) : null, this[EOF2] = !1, this[EMITTED_END2] = !1, this[EMITTING_END2] = !1, this[CLOSED2] = !1, this[EMITTED_ERROR2] = null, this.writable = !0, this.readable = !0, this[BUFFERLENGTH2] = 0, this[DESTROYED2] = !1, options2 && options2.debugExposeBuffer === !0 && Object.defineProperty(this, "buffer", { get: () => this[BUFFER2] }), options2 && options2.debugExposePipes === !0 && Object.defineProperty(this, "pipes", { get: () => this[PIPES2] }), this[SIGNAL2] = options2 && options2.signal, this[ABORTED2] = !1, this[SIGNAL2] && (this[SIGNAL2].addEventListener("abort", () => this[ABORT2]()), this[SIGNAL2].aborted && this[ABORT2]());
    }
    get bufferLength() {
      return this[BUFFERLENGTH2];
    }
    get encoding() {
      return this[ENCODING2];
    }
    set encoding(enc) {
      if (this[OBJECTMODE2]) throw new Error("cannot set encoding in objectMode");
      if (this[ENCODING2] && enc !== this[ENCODING2] && (this[DECODER2] && this[DECODER2].lastNeed || this[BUFFERLENGTH2]))
        throw new Error("cannot change encoding");
      this[ENCODING2] !== enc && (this[DECODER2] = enc ? new SD(enc) : null, this[BUFFER2].length && (this[BUFFER2] = this[BUFFER2].map((chunk) => this[DECODER2].write(chunk)))), this[ENCODING2] = enc;
    }
    setEncoding(enc) {
      this.encoding = enc;
    }
    get objectMode() {
      return this[OBJECTMODE2];
    }
    set objectMode(om) {
      this[OBJECTMODE2] = this[OBJECTMODE2] || !!om;
    }
    get async() {
      return this[ASYNC2];
    }
    set async(a) {
      this[ASYNC2] = this[ASYNC2] || !!a;
    }
    // drop everything and get out of the flow completely
    [ABORT2]() {
      this[ABORTED2] = !0, this.emit("abort", this[SIGNAL2].reason), this.destroy(this[SIGNAL2].reason);
    }
    get aborted() {
      return this[ABORTED2];
    }
    set aborted(_) {
    }
    write(chunk, encoding, cb) {
      if (this[ABORTED2]) return !1;
      if (this[EOF2]) throw new Error("write after end");
      if (this[DESTROYED2])
        return this.emit(
          "error",
          Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          )
        ), !0;
      typeof encoding == "function" && (cb = encoding, encoding = "utf8"), encoding || (encoding = "utf8");
      const fn = this[ASYNC2] ? defer2 : (f) => f();
      return !this[OBJECTMODE2] && !Buffer.isBuffer(chunk) && (isArrayBufferView2(chunk) ? chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength) : isArrayBuffer(chunk) ? chunk = Buffer.from(chunk) : typeof chunk != "string" && (this.objectMode = !0)), this[OBJECTMODE2] ? (this.flowing && this[BUFFERLENGTH2] !== 0 && this[FLUSH2](!0), this.flowing ? this.emit("data", chunk) : this[BUFFERPUSH2](chunk), this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this.flowing) : chunk.length ? (typeof chunk == "string" && // unless it is a string already ready for us to use
      !(encoding === this[ENCODING2] && !this[DECODER2].lastNeed) && (chunk = Buffer.from(chunk, encoding)), Buffer.isBuffer(chunk) && this[ENCODING2] && (chunk = this[DECODER2].write(chunk)), this.flowing && this[BUFFERLENGTH2] !== 0 && this[FLUSH2](!0), this.flowing ? this.emit("data", chunk) : this[BUFFERPUSH2](chunk), this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this.flowing) : (this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this.flowing);
    }
    read(n) {
      if (this[DESTROYED2]) return null;
      if (this[BUFFERLENGTH2] === 0 || n === 0 || n > this[BUFFERLENGTH2])
        return this[MAYBE_EMIT_END2](), null;
      this[OBJECTMODE2] && (n = null), this[BUFFER2].length > 1 && !this[OBJECTMODE2] && (this.encoding ? this[BUFFER2] = [this[BUFFER2].join("")] : this[BUFFER2] = [Buffer.concat(this[BUFFER2], this[BUFFERLENGTH2])]);
      const ret = this[READ2](n || null, this[BUFFER2][0]);
      return this[MAYBE_EMIT_END2](), ret;
    }
    [READ2](n, chunk) {
      return n === chunk.length || n === null ? this[BUFFERSHIFT2]() : (this[BUFFER2][0] = chunk.slice(n), chunk = chunk.slice(0, n), this[BUFFERLENGTH2] -= n), this.emit("data", chunk), !this[BUFFER2].length && !this[EOF2] && this.emit("drain"), chunk;
    }
    end(chunk, encoding, cb) {
      return typeof chunk == "function" && (cb = chunk, chunk = null), typeof encoding == "function" && (cb = encoding, encoding = "utf8"), chunk && this.write(chunk, encoding), cb && this.once("end", cb), this[EOF2] = !0, this.writable = !1, (this.flowing || !this[PAUSED2]) && this[MAYBE_EMIT_END2](), this;
    }
    // don't let the internal resume be overwritten
    [RESUME2]() {
      this[DESTROYED2] || (this[PAUSED2] = !1, this[FLOWING2] = !0, this.emit("resume"), this[BUFFER2].length ? this[FLUSH2]() : this[EOF2] ? this[MAYBE_EMIT_END2]() : this.emit("drain"));
    }
    resume() {
      return this[RESUME2]();
    }
    pause() {
      this[FLOWING2] = !1, this[PAUSED2] = !0;
    }
    get destroyed() {
      return this[DESTROYED2];
    }
    get flowing() {
      return this[FLOWING2];
    }
    get paused() {
      return this[PAUSED2];
    }
    [BUFFERPUSH2](chunk) {
      this[OBJECTMODE2] ? this[BUFFERLENGTH2] += 1 : this[BUFFERLENGTH2] += chunk.length, this[BUFFER2].push(chunk);
    }
    [BUFFERSHIFT2]() {
      return this[OBJECTMODE2] ? this[BUFFERLENGTH2] -= 1 : this[BUFFERLENGTH2] -= this[BUFFER2][0].length, this[BUFFER2].shift();
    }
    [FLUSH2](noDrain) {
      do
        ;
      while (this[FLUSHCHUNK2](this[BUFFERSHIFT2]()) && this[BUFFER2].length);
      !noDrain && !this[BUFFER2].length && !this[EOF2] && this.emit("drain");
    }
    [FLUSHCHUNK2](chunk) {
      return this.emit("data", chunk), this.flowing;
    }
    pipe(dest, opts) {
      if (this[DESTROYED2]) return;
      const ended = this[EMITTED_END2];
      return opts = opts || {}, dest === proc2.stdout || dest === proc2.stderr ? opts.end = !1 : opts.end = opts.end !== !1, opts.proxyErrors = !!opts.proxyErrors, ended ? opts.end && dest.end() : (this[PIPES2].push(
        opts.proxyErrors ? new PipeProxyErrors2(this, dest, opts) : new Pipe2(this, dest, opts)
      ), this[ASYNC2] ? defer2(() => this[RESUME2]()) : this[RESUME2]()), dest;
    }
    unpipe(dest) {
      const p = this[PIPES2].find((p2) => p2.dest === dest);
      p && (this[PIPES2].splice(this[PIPES2].indexOf(p), 1), p.unpipe());
    }
    addListener(ev, fn) {
      return this.on(ev, fn);
    }
    on(ev, fn) {
      const ret = super.on(ev, fn);
      return ev === "data" && !this[PIPES2].length && !this.flowing ? this[RESUME2]() : ev === "readable" && this[BUFFERLENGTH2] !== 0 ? super.emit("readable") : isEndish2(ev) && this[EMITTED_END2] ? (super.emit(ev), this.removeAllListeners(ev)) : ev === "error" && this[EMITTED_ERROR2] && (this[ASYNC2] ? defer2(() => fn.call(this, this[EMITTED_ERROR2])) : fn.call(this, this[EMITTED_ERROR2])), ret;
    }
    get emittedEnd() {
      return this[EMITTED_END2];
    }
    [MAYBE_EMIT_END2]() {
      !this[EMITTING_END2] && !this[EMITTED_END2] && !this[DESTROYED2] && this[BUFFER2].length === 0 && this[EOF2] && (this[EMITTING_END2] = !0, this.emit("end"), this.emit("prefinish"), this.emit("finish"), this[CLOSED2] && this.emit("close"), this[EMITTING_END2] = !1);
    }
    emit(ev, data, ...extra) {
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED2 && this[DESTROYED2])
        return;
      if (ev === "data")
        return !this[OBJECTMODE2] && !data ? !1 : this[ASYNC2] ? defer2(() => this[EMITDATA2](data)) : this[EMITDATA2](data);
      if (ev === "end")
        return this[EMITEND3]();
      if (ev === "close") {
        if (this[CLOSED2] = !0, !this[EMITTED_END2] && !this[DESTROYED2]) return;
        const ret2 = super.emit("close");
        return this.removeAllListeners("close"), ret2;
      } else if (ev === "error") {
        this[EMITTED_ERROR2] = data, super.emit(ERROR2, data);
        const ret2 = !this[SIGNAL2] || this.listeners("error").length ? super.emit("error", data) : !1;
        return this[MAYBE_EMIT_END2](), ret2;
      } else if (ev === "resume") {
        const ret2 = super.emit("resume");
        return this[MAYBE_EMIT_END2](), ret2;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret2 = super.emit(ev);
        return this.removeAllListeners(ev), ret2;
      }
      const ret = super.emit(ev, data, ...extra);
      return this[MAYBE_EMIT_END2](), ret;
    }
    [EMITDATA2](data) {
      for (const p of this[PIPES2])
        p.dest.write(data) === !1 && this.pause();
      const ret = super.emit("data", data);
      return this[MAYBE_EMIT_END2](), ret;
    }
    [EMITEND3]() {
      this[EMITTED_END2] || (this[EMITTED_END2] = !0, this.readable = !1, this[ASYNC2] ? defer2(() => this[EMITEND22]()) : this[EMITEND22]());
    }
    [EMITEND22]() {
      if (this[DECODER2]) {
        const data = this[DECODER2].end();
        if (data) {
          for (const p of this[PIPES2])
            p.dest.write(data);
          super.emit("data", data);
        }
      }
      for (const p of this[PIPES2])
        p.end();
      const ret = super.emit("end");
      return this.removeAllListeners("end"), ret;
    }
    // const all = await stream.collect()
    collect() {
      const buf = [];
      this[OBJECTMODE2] || (buf.dataLength = 0);
      const p = this.promise();
      return this.on("data", (c2) => {
        buf.push(c2), this[OBJECTMODE2] || (buf.dataLength += c2.length);
      }), p.then(() => buf);
    }
    // const data = await stream.concat()
    concat() {
      return this[OBJECTMODE2] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then(
        (buf) => this[OBJECTMODE2] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING2] ? buf.join("") : Buffer.concat(buf, buf.dataLength)
      );
    }
    // stream.promise().then(() => done, er => emitted error)
    promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED2, () => reject(new Error("stream destroyed"))), this.on("error", (er) => reject(er)), this.on("end", () => resolve());
      });
    }
    // for await (let chunk of stream)
    [ASYNCITERATOR]() {
      let stopped = !1;
      const stop = () => (this.pause(), stopped = !0, Promise.resolve({ done: !0 }));
      return {
        next: () => {
          if (stopped) return stop();
          const res = this.read();
          if (res !== null) return Promise.resolve({ done: !1, value: res });
          if (this[EOF2]) return stop();
          let resolve = null, reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata), this.removeListener("end", onend), this.removeListener(DESTROYED2, ondestroy), stop(), reject(er);
          }, ondata = (value) => {
            this.removeListener("error", onerr), this.removeListener("end", onend), this.removeListener(DESTROYED2, ondestroy), this.pause(), resolve({ value, done: !!this[EOF2] });
          }, onend = () => {
            this.removeListener("error", onerr), this.removeListener("data", ondata), this.removeListener(DESTROYED2, ondestroy), stop(), resolve({ done: !0 });
          }, ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej, resolve = res2, this.once(DESTROYED2, ondestroy), this.once("error", onerr), this.once("end", onend), this.once("data", ondata);
          });
        },
        throw: stop,
        return: stop,
        [ASYNCITERATOR]() {
          return this;
        }
      };
    }
    // for (let chunk of stream)
    [ITERATOR]() {
      let stopped = !1;
      const stop = () => (this.pause(), this.removeListener(ERROR2, stop), this.removeListener(DESTROYED2, stop), this.removeListener("end", stop), stopped = !0, { done: !0 }), next = () => {
        if (stopped) return stop();
        const value = this.read();
        return value === null ? stop() : { value };
      };
      return this.once("end", stop), this.once(ERROR2, stop), this.once(DESTROYED2, stop), {
        next,
        throw: stop,
        return: stop,
        [ITERATOR]() {
          return this;
        }
      };
    }
    destroy(er) {
      return this[DESTROYED2] ? (er ? this.emit("error", er) : this.emit(DESTROYED2), this) : (this[DESTROYED2] = !0, this[BUFFER2].length = 0, this[BUFFERLENGTH2] = 0, typeof this.close == "function" && !this[CLOSED2] && this.close(), er ? this.emit("error", er) : this.emit(DESTROYED2), this);
    }
    static isStream(s) {
      return !!s && (s instanceof Minipass2 || s instanceof Stream2 || s instanceof EE && // readable
      (typeof s.pipe == "function" || // writable
      typeof s.write == "function" && typeof s.end == "function"));
    }
  }
  return minipass$1.Minipass = Minipass2, minipass$1;
}
var minizlib = {}, constants, hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  const realZlibConstants = require$$0__default$a.default.constants || /* istanbul ignore next */
  { ZLIB_VERNUM: 4736 };
  return constants = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: 1 / 0,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
  }, realZlibConstants)), constants;
}
var minipass, hasRequiredMinipass;
function requireMinipass() {
  if (hasRequiredMinipass) return minipass;
  hasRequiredMinipass = 1;
  const proc2 = typeof process == "object" && process ? process : {
    stdout: null,
    stderr: null
  }, EE = require$$0__default$7.default, Stream2 = require$$0__default$4.default, SD = require$$2__default$1.default.StringDecoder, EOF2 = Symbol("EOF"), MAYBE_EMIT_END2 = Symbol("maybeEmitEnd"), EMITTED_END2 = Symbol("emittedEnd"), EMITTING_END2 = Symbol("emittingEnd"), EMITTED_ERROR2 = Symbol("emittedError"), CLOSED2 = Symbol("closed"), READ2 = Symbol("read"), FLUSH2 = Symbol("flush"), FLUSHCHUNK2 = Symbol("flushChunk"), ENCODING2 = Symbol("encoding"), DECODER2 = Symbol("decoder"), FLOWING2 = Symbol("flowing"), PAUSED2 = Symbol("paused"), RESUME2 = Symbol("resume"), BUFFERLENGTH2 = Symbol("bufferLength"), BUFFERPUSH2 = Symbol("bufferPush"), BUFFERSHIFT2 = Symbol("bufferShift"), OBJECTMODE2 = Symbol("objectMode"), DESTROYED2 = Symbol("destroyed"), EMITDATA2 = Symbol("emitData"), EMITEND3 = Symbol("emitEnd"), EMITEND22 = Symbol("emitEnd2"), ASYNC2 = Symbol("async"), defer2 = (fn) => Promise.resolve().then(fn), doIter = loadEnv.commonjsGlobal._MP_NO_ITERATOR_SYMBOLS_ !== "1", ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented"), ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented"), isEndish2 = (ev) => ev === "end" || ev === "finish" || ev === "prefinish", isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b == "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0, isArrayBufferView2 = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
  class Pipe2 {
    constructor(src2, dest, opts) {
      this.src = src2, this.dest = dest, this.opts = opts, this.ondrain = () => src2[RESUME2](), dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    // istanbul ignore next - only here for the prototype
    proxyErrors() {
    }
    end() {
      this.unpipe(), this.opts.end && this.dest.end();
    }
  }
  class PipeProxyErrors2 extends Pipe2 {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors), super.unpipe();
    }
    constructor(src2, dest, opts) {
      super(src2, dest, opts), this.proxyErrors = (er) => dest.emit("error", er), src2.on("error", this.proxyErrors);
    }
  }
  return minipass = class Minipass2 extends Stream2 {
    constructor(options2) {
      super(), this[FLOWING2] = !1, this[PAUSED2] = !1, this.pipes = [], this.buffer = [], this[OBJECTMODE2] = options2 && options2.objectMode || !1, this[OBJECTMODE2] ? this[ENCODING2] = null : this[ENCODING2] = options2 && options2.encoding || null, this[ENCODING2] === "buffer" && (this[ENCODING2] = null), this[ASYNC2] = options2 && !!options2.async || !1, this[DECODER2] = this[ENCODING2] ? new SD(this[ENCODING2]) : null, this[EOF2] = !1, this[EMITTED_END2] = !1, this[EMITTING_END2] = !1, this[CLOSED2] = !1, this[EMITTED_ERROR2] = null, this.writable = !0, this.readable = !0, this[BUFFERLENGTH2] = 0, this[DESTROYED2] = !1;
    }
    get bufferLength() {
      return this[BUFFERLENGTH2];
    }
    get encoding() {
      return this[ENCODING2];
    }
    set encoding(enc) {
      if (this[OBJECTMODE2])
        throw new Error("cannot set encoding in objectMode");
      if (this[ENCODING2] && enc !== this[ENCODING2] && (this[DECODER2] && this[DECODER2].lastNeed || this[BUFFERLENGTH2]))
        throw new Error("cannot change encoding");
      this[ENCODING2] !== enc && (this[DECODER2] = enc ? new SD(enc) : null, this.buffer.length && (this.buffer = this.buffer.map((chunk) => this[DECODER2].write(chunk)))), this[ENCODING2] = enc;
    }
    setEncoding(enc) {
      this.encoding = enc;
    }
    get objectMode() {
      return this[OBJECTMODE2];
    }
    set objectMode(om) {
      this[OBJECTMODE2] = this[OBJECTMODE2] || !!om;
    }
    get async() {
      return this[ASYNC2];
    }
    set async(a) {
      this[ASYNC2] = this[ASYNC2] || !!a;
    }
    write(chunk, encoding, cb) {
      if (this[EOF2])
        throw new Error("write after end");
      if (this[DESTROYED2])
        return this.emit("error", Object.assign(
          new Error("Cannot call write after a stream was destroyed"),
          { code: "ERR_STREAM_DESTROYED" }
        )), !0;
      typeof encoding == "function" && (cb = encoding, encoding = "utf8"), encoding || (encoding = "utf8");
      const fn = this[ASYNC2] ? defer2 : (f) => f();
      return !this[OBJECTMODE2] && !Buffer.isBuffer(chunk) && (isArrayBufferView2(chunk) ? chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength) : isArrayBuffer(chunk) ? chunk = Buffer.from(chunk) : typeof chunk != "string" && (this.objectMode = !0)), this[OBJECTMODE2] ? (this.flowing && this[BUFFERLENGTH2] !== 0 && this[FLUSH2](!0), this.flowing ? this.emit("data", chunk) : this[BUFFERPUSH2](chunk), this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this.flowing) : chunk.length ? (typeof chunk == "string" && // unless it is a string already ready for us to use
      !(encoding === this[ENCODING2] && !this[DECODER2].lastNeed) && (chunk = Buffer.from(chunk, encoding)), Buffer.isBuffer(chunk) && this[ENCODING2] && (chunk = this[DECODER2].write(chunk)), this.flowing && this[BUFFERLENGTH2] !== 0 && this[FLUSH2](!0), this.flowing ? this.emit("data", chunk) : this[BUFFERPUSH2](chunk), this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this.flowing) : (this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this.flowing);
    }
    read(n) {
      if (this[DESTROYED2])
        return null;
      if (this[BUFFERLENGTH2] === 0 || n === 0 || n > this[BUFFERLENGTH2])
        return this[MAYBE_EMIT_END2](), null;
      this[OBJECTMODE2] && (n = null), this.buffer.length > 1 && !this[OBJECTMODE2] && (this.encoding ? this.buffer = [this.buffer.join("")] : this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH2])]);
      const ret = this[READ2](n || null, this.buffer[0]);
      return this[MAYBE_EMIT_END2](), ret;
    }
    [READ2](n, chunk) {
      return n === chunk.length || n === null ? this[BUFFERSHIFT2]() : (this.buffer[0] = chunk.slice(n), chunk = chunk.slice(0, n), this[BUFFERLENGTH2] -= n), this.emit("data", chunk), !this.buffer.length && !this[EOF2] && this.emit("drain"), chunk;
    }
    end(chunk, encoding, cb) {
      return typeof chunk == "function" && (cb = chunk, chunk = null), typeof encoding == "function" && (cb = encoding, encoding = "utf8"), chunk && this.write(chunk, encoding), cb && this.once("end", cb), this[EOF2] = !0, this.writable = !1, (this.flowing || !this[PAUSED2]) && this[MAYBE_EMIT_END2](), this;
    }
    // don't let the internal resume be overwritten
    [RESUME2]() {
      this[DESTROYED2] || (this[PAUSED2] = !1, this[FLOWING2] = !0, this.emit("resume"), this.buffer.length ? this[FLUSH2]() : this[EOF2] ? this[MAYBE_EMIT_END2]() : this.emit("drain"));
    }
    resume() {
      return this[RESUME2]();
    }
    pause() {
      this[FLOWING2] = !1, this[PAUSED2] = !0;
    }
    get destroyed() {
      return this[DESTROYED2];
    }
    get flowing() {
      return this[FLOWING2];
    }
    get paused() {
      return this[PAUSED2];
    }
    [BUFFERPUSH2](chunk) {
      this[OBJECTMODE2] ? this[BUFFERLENGTH2] += 1 : this[BUFFERLENGTH2] += chunk.length, this.buffer.push(chunk);
    }
    [BUFFERSHIFT2]() {
      return this.buffer.length && (this[OBJECTMODE2] ? this[BUFFERLENGTH2] -= 1 : this[BUFFERLENGTH2] -= this.buffer[0].length), this.buffer.shift();
    }
    [FLUSH2](noDrain) {
      do
        ;
      while (this[FLUSHCHUNK2](this[BUFFERSHIFT2]()));
      !noDrain && !this.buffer.length && !this[EOF2] && this.emit("drain");
    }
    [FLUSHCHUNK2](chunk) {
      return chunk ? (this.emit("data", chunk), this.flowing) : !1;
    }
    pipe(dest, opts) {
      if (this[DESTROYED2])
        return;
      const ended = this[EMITTED_END2];
      return opts = opts || {}, dest === proc2.stdout || dest === proc2.stderr ? opts.end = !1 : opts.end = opts.end !== !1, opts.proxyErrors = !!opts.proxyErrors, ended ? opts.end && dest.end() : (this.pipes.push(opts.proxyErrors ? new PipeProxyErrors2(this, dest, opts) : new Pipe2(this, dest, opts)), this[ASYNC2] ? defer2(() => this[RESUME2]()) : this[RESUME2]()), dest;
    }
    unpipe(dest) {
      const p = this.pipes.find((p2) => p2.dest === dest);
      p && (this.pipes.splice(this.pipes.indexOf(p), 1), p.unpipe());
    }
    addListener(ev, fn) {
      return this.on(ev, fn);
    }
    on(ev, fn) {
      const ret = super.on(ev, fn);
      return ev === "data" && !this.pipes.length && !this.flowing ? this[RESUME2]() : ev === "readable" && this[BUFFERLENGTH2] !== 0 ? super.emit("readable") : isEndish2(ev) && this[EMITTED_END2] ? (super.emit(ev), this.removeAllListeners(ev)) : ev === "error" && this[EMITTED_ERROR2] && (this[ASYNC2] ? defer2(() => fn.call(this, this[EMITTED_ERROR2])) : fn.call(this, this[EMITTED_ERROR2])), ret;
    }
    get emittedEnd() {
      return this[EMITTED_END2];
    }
    [MAYBE_EMIT_END2]() {
      !this[EMITTING_END2] && !this[EMITTED_END2] && !this[DESTROYED2] && this.buffer.length === 0 && this[EOF2] && (this[EMITTING_END2] = !0, this.emit("end"), this.emit("prefinish"), this.emit("finish"), this[CLOSED2] && this.emit("close"), this[EMITTING_END2] = !1);
    }
    emit(ev, data, ...extra) {
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED2 && this[DESTROYED2])
        return;
      if (ev === "data")
        return data ? this[ASYNC2] ? defer2(() => this[EMITDATA2](data)) : this[EMITDATA2](data) : !1;
      if (ev === "end")
        return this[EMITEND3]();
      if (ev === "close") {
        if (this[CLOSED2] = !0, !this[EMITTED_END2] && !this[DESTROYED2])
          return;
        const ret2 = super.emit("close");
        return this.removeAllListeners("close"), ret2;
      } else if (ev === "error") {
        this[EMITTED_ERROR2] = data;
        const ret2 = super.emit("error", data);
        return this[MAYBE_EMIT_END2](), ret2;
      } else if (ev === "resume") {
        const ret2 = super.emit("resume");
        return this[MAYBE_EMIT_END2](), ret2;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret2 = super.emit(ev);
        return this.removeAllListeners(ev), ret2;
      }
      const ret = super.emit(ev, data, ...extra);
      return this[MAYBE_EMIT_END2](), ret;
    }
    [EMITDATA2](data) {
      for (const p of this.pipes)
        p.dest.write(data) === !1 && this.pause();
      const ret = super.emit("data", data);
      return this[MAYBE_EMIT_END2](), ret;
    }
    [EMITEND3]() {
      this[EMITTED_END2] || (this[EMITTED_END2] = !0, this.readable = !1, this[ASYNC2] ? defer2(() => this[EMITEND22]()) : this[EMITEND22]());
    }
    [EMITEND22]() {
      if (this[DECODER2]) {
        const data = this[DECODER2].end();
        if (data) {
          for (const p of this.pipes)
            p.dest.write(data);
          super.emit("data", data);
        }
      }
      for (const p of this.pipes)
        p.end();
      const ret = super.emit("end");
      return this.removeAllListeners("end"), ret;
    }
    // const all = await stream.collect()
    collect() {
      const buf = [];
      this[OBJECTMODE2] || (buf.dataLength = 0);
      const p = this.promise();
      return this.on("data", (c2) => {
        buf.push(c2), this[OBJECTMODE2] || (buf.dataLength += c2.length);
      }), p.then(() => buf);
    }
    // const data = await stream.concat()
    concat() {
      return this[OBJECTMODE2] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE2] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING2] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
    }
    // stream.promise().then(() => done, er => emitted error)
    promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED2, () => reject(new Error("stream destroyed"))), this.on("error", (er) => reject(er)), this.on("end", () => resolve());
      });
    }
    // for await (let chunk of stream)
    [ASYNCITERATOR]() {
      return { next: () => {
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: !1, value: res });
        if (this[EOF2])
          return Promise.resolve({ done: !0 });
        let resolve = null, reject = null;
        const onerr = (er) => {
          this.removeListener("data", ondata), this.removeListener("end", onend), reject(er);
        }, ondata = (value) => {
          this.removeListener("error", onerr), this.removeListener("end", onend), this.pause(), resolve({ value, done: !!this[EOF2] });
        }, onend = () => {
          this.removeListener("error", onerr), this.removeListener("data", ondata), resolve({ done: !0 });
        }, ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej, resolve = res2, this.once(DESTROYED2, ondestroy), this.once("error", onerr), this.once("end", onend), this.once("data", ondata);
        });
      } };
    }
    // for (let chunk of stream)
    [ITERATOR]() {
      return { next: () => {
        const value = this.read();
        return { value, done: value === null };
      } };
    }
    destroy(er) {
      return this[DESTROYED2] ? (er ? this.emit("error", er) : this.emit(DESTROYED2), this) : (this[DESTROYED2] = !0, this.buffer.length = 0, this[BUFFERLENGTH2] = 0, typeof this.close == "function" && !this[CLOSED2] && this.close(), er ? this.emit("error", er) : this.emit(DESTROYED2), this);
    }
    static isStream(s) {
      return !!s && (s instanceof Minipass2 || s instanceof Stream2 || s instanceof EE && (typeof s.pipe == "function" || // readable
      typeof s.write == "function" && typeof s.end == "function"));
    }
  }, minipass;
}
var hasRequiredMinizlib;
function requireMinizlib() {
  if (hasRequiredMinizlib) return minizlib;
  hasRequiredMinizlib = 1;
  const assert = require$$0__default$6.default, Buffer2 = require$$0__default$9.default.Buffer, realZlib = require$$0__default$a.default, constants2 = minizlib.constants = requireConstants(), Minipass2 = requireMinipass(), OriginalBufferConcat = Buffer2.concat, _superWrite = Symbol("_superWrite");
  class ZlibError extends Error {
    constructor(err) {
      super("zlib: " + err.message), this.code = err.code, this.errno = err.errno, this.code || (this.code = "ZLIB_ERROR"), this.message = "zlib: " + err.message, Error.captureStackTrace(this, this.constructor);
    }
    get name() {
      return "ZlibError";
    }
  }
  const _opts = Symbol("opts"), _flushFlag = Symbol("flushFlag"), _finishFlushFlag = Symbol("finishFlushFlag"), _fullFlushFlag = Symbol("fullFlushFlag"), _handle = Symbol("handle"), _onError = Symbol("onError"), _sawError = Symbol("sawError"), _level = Symbol("level"), _strategy = Symbol("strategy"), _ended = Symbol("ended");
  class ZlibBase extends Minipass2 {
    constructor(opts, mode2) {
      if (!opts || typeof opts != "object")
        throw new TypeError("invalid options for ZlibBase constructor");
      super(opts), this[_sawError] = !1, this[_ended] = !1, this[_opts] = opts, this[_flushFlag] = opts.flush, this[_finishFlushFlag] = opts.finishFlush;
      try {
        this[_handle] = new realZlib[mode2](opts);
      } catch (er) {
        throw new ZlibError(er);
      }
      this[_onError] = (err) => {
        this[_sawError] || (this[_sawError] = !0, this.close(), this.emit("error", err));
      }, this[_handle].on("error", (er) => this[_onError](new ZlibError(er))), this.once("end", () => this.close);
    }
    close() {
      this[_handle] && (this[_handle].close(), this[_handle] = null, this.emit("close"));
    }
    reset() {
      if (!this[_sawError])
        return assert(this[_handle], "zlib binding closed"), this[_handle].reset();
    }
    flush(flushFlag) {
      this.ended || (typeof flushFlag != "number" && (flushFlag = this[_fullFlushFlag]), this.write(Object.assign(Buffer2.alloc(0), { [_flushFlag]: flushFlag })));
    }
    end(chunk, encoding, cb) {
      return chunk && this.write(chunk, encoding), this.flush(this[_finishFlushFlag]), this[_ended] = !0, super.end(null, null, cb);
    }
    get ended() {
      return this[_ended];
    }
    write(chunk, encoding, cb) {
      if (typeof encoding == "function" && (cb = encoding, encoding = "utf8"), typeof chunk == "string" && (chunk = Buffer2.from(chunk, encoding)), this[_sawError])
        return;
      assert(this[_handle], "zlib binding closed");
      const nativeHandle = this[_handle]._handle, originalNativeClose = nativeHandle.close;
      nativeHandle.close = () => {
      };
      const originalClose = this[_handle].close;
      this[_handle].close = () => {
      }, Buffer2.concat = (args) => args;
      let result;
      try {
        const flushFlag = typeof chunk[_flushFlag] == "number" ? chunk[_flushFlag] : this[_flushFlag];
        result = this[_handle]._processChunk(chunk, flushFlag), Buffer2.concat = OriginalBufferConcat;
      } catch (err) {
        Buffer2.concat = OriginalBufferConcat, this[_onError](new ZlibError(err));
      } finally {
        this[_handle] && (this[_handle]._handle = nativeHandle, nativeHandle.close = originalNativeClose, this[_handle].close = originalClose, this[_handle].removeAllListeners("error"));
      }
      this[_handle] && this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
      let writeReturn;
      if (result)
        if (Array.isArray(result) && result.length > 0) {
          writeReturn = this[_superWrite](Buffer2.from(result[0]));
          for (let i = 1; i < result.length; i++)
            writeReturn = this[_superWrite](result[i]);
        } else
          writeReturn = this[_superWrite](Buffer2.from(result));
      return cb && cb(), writeReturn;
    }
    [_superWrite](data) {
      return super.write(data);
    }
  }
  class Zlib extends ZlibBase {
    constructor(opts, mode2) {
      opts = opts || {}, opts.flush = opts.flush || constants2.Z_NO_FLUSH, opts.finishFlush = opts.finishFlush || constants2.Z_FINISH, super(opts, mode2), this[_fullFlushFlag] = constants2.Z_FULL_FLUSH, this[_level] = opts.level, this[_strategy] = opts.strategy;
    }
    params(level, strategy) {
      if (!this[_sawError]) {
        if (!this[_handle])
          throw new Error("cannot switch params when binding is closed");
        if (!this[_handle].params)
          throw new Error("not supported in this implementation");
        if (this[_level] !== level || this[_strategy] !== strategy) {
          this.flush(constants2.Z_SYNC_FLUSH), assert(this[_handle], "zlib binding closed");
          const origFlush = this[_handle].flush;
          this[_handle].flush = (flushFlag, cb) => {
            this.flush(flushFlag), cb();
          };
          try {
            this[_handle].params(level, strategy);
          } finally {
            this[_handle].flush = origFlush;
          }
          this[_handle] && (this[_level] = level, this[_strategy] = strategy);
        }
      }
    }
  }
  class Deflate extends Zlib {
    constructor(opts) {
      super(opts, "Deflate");
    }
  }
  class Inflate extends Zlib {
    constructor(opts) {
      super(opts, "Inflate");
    }
  }
  const _portable = Symbol("_portable");
  class Gzip extends Zlib {
    constructor(opts) {
      super(opts, "Gzip"), this[_portable] = opts && !!opts.portable;
    }
    [_superWrite](data) {
      return this[_portable] ? (this[_portable] = !1, data[9] = 255, super[_superWrite](data)) : super[_superWrite](data);
    }
  }
  class Gunzip extends Zlib {
    constructor(opts) {
      super(opts, "Gunzip");
    }
  }
  class DeflateRaw extends Zlib {
    constructor(opts) {
      super(opts, "DeflateRaw");
    }
  }
  class InflateRaw extends Zlib {
    constructor(opts) {
      super(opts, "InflateRaw");
    }
  }
  class Unzip extends Zlib {
    constructor(opts) {
      super(opts, "Unzip");
    }
  }
  class Brotli extends ZlibBase {
    constructor(opts, mode2) {
      opts = opts || {}, opts.flush = opts.flush || constants2.BROTLI_OPERATION_PROCESS, opts.finishFlush = opts.finishFlush || constants2.BROTLI_OPERATION_FINISH, super(opts, mode2), this[_fullFlushFlag] = constants2.BROTLI_OPERATION_FLUSH;
    }
  }
  class BrotliCompress extends Brotli {
    constructor(opts) {
      super(opts, "BrotliCompress");
    }
  }
  class BrotliDecompress extends Brotli {
    constructor(opts) {
      super(opts, "BrotliDecompress");
    }
  }
  return minizlib.Deflate = Deflate, minizlib.Inflate = Inflate, minizlib.Gzip = Gzip, minizlib.Gunzip = Gunzip, minizlib.DeflateRaw = DeflateRaw, minizlib.InflateRaw = InflateRaw, minizlib.Unzip = Unzip, typeof realZlib.BrotliCompress == "function" ? (minizlib.BrotliCompress = BrotliCompress, minizlib.BrotliDecompress = BrotliDecompress) : minizlib.BrotliCompress = minizlib.BrotliDecompress = class {
    constructor() {
      throw new Error("Brotli is not supported in this version of Node.js");
    }
  }, minizlib;
}
var normalizeWindowsPath, hasRequiredNormalizeWindowsPath;
function requireNormalizeWindowsPath() {
  return hasRequiredNormalizeWindowsPath || (hasRequiredNormalizeWindowsPath = 1, normalizeWindowsPath = (process.env.TESTING_TAR_FAKE_PLATFORM || process.platform) !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/")), normalizeWindowsPath;
}
var readEntry, hasRequiredReadEntry;
function requireReadEntry() {
  if (hasRequiredReadEntry) return readEntry;
  hasRequiredReadEntry = 1;
  const { Minipass: Minipass2 } = requireMinipass$1(), normPath = requireNormalizeWindowsPath(), SLURP = Symbol("slurp");
  return readEntry = class extends Minipass2 {
    constructor(header2, ex, gex) {
      switch (super(), this.pause(), this.extended = ex, this.globalExtended = gex, this.header = header2, this.startBlockSize = 512 * Math.ceil(header2.size / 512), this.blockRemain = this.startBlockSize, this.remain = header2.size, this.type = header2.type, this.meta = !1, this.ignore = !1, this.type) {
        case "File":
        case "OldFile":
        case "Link":
        case "SymbolicLink":
        case "CharacterDevice":
        case "BlockDevice":
        case "Directory":
        case "FIFO":
        case "ContiguousFile":
        case "GNUDumpDir":
          break;
        case "NextFileHasLongLinkpath":
        case "NextFileHasLongPath":
        case "OldGnuLongPath":
        case "GlobalExtendedHeader":
        case "ExtendedHeader":
        case "OldExtendedHeader":
          this.meta = !0;
          break;
        // NOTE: gnutar and bsdtar treat unrecognized types as 'File'
        // it may be worth doing the same, but with a warning.
        default:
          this.ignore = !0;
      }
      this.path = normPath(header2.path), this.mode = header2.mode, this.mode && (this.mode = this.mode & 4095), this.uid = header2.uid, this.gid = header2.gid, this.uname = header2.uname, this.gname = header2.gname, this.size = header2.size, this.mtime = header2.mtime, this.atime = header2.atime, this.ctime = header2.ctime, this.linkpath = normPath(header2.linkpath), this.uname = header2.uname, this.gname = header2.gname, ex && this[SLURP](ex), gex && this[SLURP](gex, !0);
    }
    write(data) {
      const writeLen = data.length;
      if (writeLen > this.blockRemain)
        throw new Error("writing more to entry than is appropriate");
      const r = this.remain, br = this.blockRemain;
      return this.remain = Math.max(0, r - writeLen), this.blockRemain = Math.max(0, br - writeLen), this.ignore ? !0 : r >= writeLen ? super.write(data) : super.write(data.slice(0, r));
    }
    [SLURP](ex, global2) {
      for (const k in ex)
        ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path") && (this[k] = k === "path" || k === "linkpath" ? normPath(ex[k]) : ex[k]);
    }
  }, readEntry;
}
var types$2 = {}, hasRequiredTypes$1;
function requireTypes$1() {
  return hasRequiredTypes$1 || (hasRequiredTypes$1 = 1, function(exports2) {
    exports2.name = /* @__PURE__ */ new Map([
      ["0", "File"],
      // same as File
      ["", "OldFile"],
      ["1", "Link"],
      ["2", "SymbolicLink"],
      // Devices and FIFOs aren't fully supported
      // they are parsed, but skipped when unpacking
      ["3", "CharacterDevice"],
      ["4", "BlockDevice"],
      ["5", "Directory"],
      ["6", "FIFO"],
      // same as File
      ["7", "ContiguousFile"],
      // pax headers
      ["g", "GlobalExtendedHeader"],
      ["x", "ExtendedHeader"],
      // vendor-specific stuff
      // skip
      ["A", "SolarisACL"],
      // like 5, but with data, which should be skipped
      ["D", "GNUDumpDir"],
      // metadata only, skip
      ["I", "Inode"],
      // data = link path of next file
      ["K", "NextFileHasLongLinkpath"],
      // data = path of next file
      ["L", "NextFileHasLongPath"],
      // skip
      ["M", "ContinuationFile"],
      // like L
      ["N", "OldGnuLongPath"],
      // skip
      ["S", "SparseFile"],
      // skip
      ["V", "TapeVolumeHeader"],
      // like x
      ["X", "OldExtendedHeader"]
    ]), exports2.code = new Map(Array.from(exports2.name).map((kv) => [kv[1], kv[0]]));
  }(types$2)), types$2;
}
var largeNumbers, hasRequiredLargeNumbers;
function requireLargeNumbers() {
  if (hasRequiredLargeNumbers) return largeNumbers;
  hasRequiredLargeNumbers = 1;
  const encode = (num, buf) => {
    if (Number.isSafeInteger(num))
      num < 0 ? encodeNegative(num, buf) : encodePositive(num, buf);
    else throw Error("cannot encode number outside of javascript safe integer range");
    return buf;
  }, encodePositive = (num, buf) => {
    buf[0] = 128;
    for (var i = buf.length; i > 1; i--)
      buf[i - 1] = num & 255, num = Math.floor(num / 256);
  }, encodeNegative = (num, buf) => {
    buf[0] = 255;
    var flipped = !1;
    num = num * -1;
    for (var i = buf.length; i > 1; i--) {
      var byte = num & 255;
      num = Math.floor(num / 256), flipped ? buf[i - 1] = onesComp(byte) : byte === 0 ? buf[i - 1] = 0 : (flipped = !0, buf[i - 1] = twosComp(byte));
    }
  }, parse3 = (buf) => {
    const pre = buf[0], value = pre === 128 ? pos2(buf.slice(1, buf.length)) : pre === 255 ? twos(buf) : null;
    if (value === null)
      throw Error("invalid base256 encoding");
    if (!Number.isSafeInteger(value))
      throw Error("parsed number outside of javascript safe integer range");
    return value;
  }, twos = (buf) => {
    for (var len = buf.length, sum = 0, flipped = !1, i = len - 1; i > -1; i--) {
      var byte = buf[i], f;
      flipped ? f = onesComp(byte) : byte === 0 ? f = byte : (flipped = !0, f = twosComp(byte)), f !== 0 && (sum -= f * Math.pow(256, len - i - 1));
    }
    return sum;
  }, pos2 = (buf) => {
    for (var len = buf.length, sum = 0, i = len - 1; i > -1; i--) {
      var byte = buf[i];
      byte !== 0 && (sum += byte * Math.pow(256, len - i - 1));
    }
    return sum;
  }, onesComp = (byte) => (255 ^ byte) & 255, twosComp = (byte) => (255 ^ byte) + 1 & 255;
  return largeNumbers = {
    encode,
    parse: parse3
  }, largeNumbers;
}
var header, hasRequiredHeader;
function requireHeader() {
  if (hasRequiredHeader) return header;
  hasRequiredHeader = 1;
  const types2 = requireTypes$1(), pathModule = require$$0__default$1.default.posix, large = requireLargeNumbers(), SLURP = Symbol("slurp"), TYPE = Symbol("type");
  class Header {
    constructor(data, off, ex, gex) {
      this.cksumValid = !1, this.needPax = !1, this.nullBlock = !1, this.block = null, this.path = null, this.mode = null, this.uid = null, this.gid = null, this.size = null, this.mtime = null, this.cksum = null, this[TYPE] = "0", this.linkpath = null, this.uname = null, this.gname = null, this.devmaj = 0, this.devmin = 0, this.atime = null, this.ctime = null, Buffer.isBuffer(data) ? this.decode(data, off || 0, ex, gex) : data && this.set(data);
    }
    decode(buf, off, ex, gex) {
      if (off || (off = 0), !buf || !(buf.length >= off + 512))
        throw new Error("need 512 bytes for header");
      if (this.path = decString(buf, off, 100), this.mode = decNumber(buf, off + 100, 8), this.uid = decNumber(buf, off + 108, 8), this.gid = decNumber(buf, off + 116, 8), this.size = decNumber(buf, off + 124, 12), this.mtime = decDate(buf, off + 136, 12), this.cksum = decNumber(buf, off + 148, 12), this[SLURP](ex), this[SLURP](gex, !0), this[TYPE] = decString(buf, off + 156, 1), this[TYPE] === "" && (this[TYPE] = "0"), this[TYPE] === "0" && this.path.slice(-1) === "/" && (this[TYPE] = "5"), this[TYPE] === "5" && (this.size = 0), this.linkpath = decString(buf, off + 157, 100), buf.slice(off + 257, off + 265).toString() === "ustar\x0000")
        if (this.uname = decString(buf, off + 265, 32), this.gname = decString(buf, off + 297, 32), this.devmaj = decNumber(buf, off + 329, 8), this.devmin = decNumber(buf, off + 337, 8), buf[off + 475] !== 0) {
          const prefix = decString(buf, off + 345, 155);
          this.path = prefix + "/" + this.path;
        } else {
          const prefix = decString(buf, off + 345, 130);
          prefix && (this.path = prefix + "/" + this.path), this.atime = decDate(buf, off + 476, 12), this.ctime = decDate(buf, off + 488, 12);
        }
      let sum = 8 * 32;
      for (let i = off; i < off + 148; i++)
        sum += buf[i];
      for (let i = off + 156; i < off + 512; i++)
        sum += buf[i];
      this.cksumValid = sum === this.cksum, this.cksum === null && sum === 8 * 32 && (this.nullBlock = !0);
    }
    [SLURP](ex, global2) {
      for (const k in ex)
        ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path") && (this[k] = ex[k]);
    }
    encode(buf, off) {
      if (buf || (buf = this.block = Buffer.alloc(512), off = 0), off || (off = 0), !(buf.length >= off + 512))
        throw new Error("need 512 bytes for header");
      const prefixSize = this.ctime || this.atime ? 130 : 155, split = splitPrefix(this.path || "", prefixSize), path2 = split[0], prefix = split[1];
      this.needPax = split[2], this.needPax = encString(buf, off, 100, path2) || this.needPax, this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax, this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax, this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax, this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax, this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax, buf[off + 156] = this[TYPE].charCodeAt(0), this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax, buf.write("ustar\x0000", off + 257, 8), this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax, this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax, this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax, this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax, this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax, buf[off + 475] !== 0 ? this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax : (this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax, this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax, this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax);
      let sum = 8 * 32;
      for (let i = off; i < off + 148; i++)
        sum += buf[i];
      for (let i = off + 156; i < off + 512; i++)
        sum += buf[i];
      return this.cksum = sum, encNumber(buf, off + 148, 8, this.cksum), this.cksumValid = !0, this.needPax;
    }
    set(data) {
      for (const i in data)
        data[i] !== null && data[i] !== void 0 && (this[i] = data[i]);
    }
    get type() {
      return types2.name.get(this[TYPE]) || this[TYPE];
    }
    get typeKey() {
      return this[TYPE];
    }
    set type(type2) {
      types2.code.has(type2) ? this[TYPE] = types2.code.get(type2) : this[TYPE] = type2;
    }
  }
  const splitPrefix = (p, prefixSize) => {
    let pp = p, prefix = "", ret;
    const root2 = pathModule.parse(p).root || ".";
    if (Buffer.byteLength(pp) < 100)
      ret = [pp, prefix, !1];
    else {
      prefix = pathModule.dirname(pp), pp = pathModule.basename(pp);
      do
        Buffer.byteLength(pp) <= 100 && Buffer.byteLength(prefix) <= prefixSize ? ret = [pp, prefix, !1] : Buffer.byteLength(pp) > 100 && Buffer.byteLength(prefix) <= prefixSize ? ret = [pp.slice(0, 99), prefix, !0] : (pp = pathModule.join(pathModule.basename(prefix), pp), prefix = pathModule.dirname(prefix));
      while (prefix !== root2 && !ret);
      ret || (ret = [p.slice(0, 99), "", !0]);
    }
    return ret;
  }, decString = (buf, off, size) => buf.slice(off, off + size).toString("utf8").replace(/\0.*/, ""), decDate = (buf, off, size) => numToDate(decNumber(buf, off, size)), numToDate = (num) => num === null ? null : new Date(num * 1e3), decNumber = (buf, off, size) => buf[off] & 128 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size), nanNull = (value) => isNaN(value) ? null : value, decSmallNumber = (buf, off, size) => nanNull(parseInt(
    buf.slice(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(),
    8
  )), MAXNUM = {
    12: 8589934591,
    8: 2097151
  }, encNumber = (buf, off, size, number2) => number2 === null ? !1 : number2 > MAXNUM[size] || number2 < 0 ? (large.encode(number2, buf.slice(off, off + size)), !0) : (encSmallNumber(buf, off, size, number2), !1), encSmallNumber = (buf, off, size, number2) => buf.write(octalString(number2, size), off, size, "ascii"), octalString = (number2, size) => padOctal(Math.floor(number2).toString(8), size), padOctal = (string, size) => (string.length === size - 1 ? string : new Array(size - string.length - 1).join("0") + string + " ") + "\0", encDate = (buf, off, size, date) => date === null ? !1 : encNumber(buf, off, size, date.getTime() / 1e3), NULLS = new Array(156).join("\0"), encString = (buf, off, size, string) => string === null ? !1 : (buf.write(string + NULLS, off, size, "utf8"), string.length !== Buffer.byteLength(string) || string.length > size);
  return header = Header, header;
}
var pax, hasRequiredPax;
function requirePax() {
  if (hasRequiredPax) return pax;
  hasRequiredPax = 1;
  const Header = requireHeader(), path2 = require$$0__default$1.default;
  class Pax {
    constructor(obj, global2) {
      this.atime = obj.atime || null, this.charset = obj.charset || null, this.comment = obj.comment || null, this.ctime = obj.ctime || null, this.gid = obj.gid || null, this.gname = obj.gname || null, this.linkpath = obj.linkpath || null, this.mtime = obj.mtime || null, this.path = obj.path || null, this.size = obj.size || null, this.uid = obj.uid || null, this.uname = obj.uname || null, this.dev = obj.dev || null, this.ino = obj.ino || null, this.nlink = obj.nlink || null, this.global = global2 || !1;
    }
    encode() {
      const body = this.encodeBody();
      if (body === "")
        return null;
      const bodyLen = Buffer.byteLength(body), bufLen = 512 * Math.ceil(1 + bodyLen / 512), buf = Buffer.allocUnsafe(bufLen);
      for (let i = 0; i < 512; i++)
        buf[i] = 0;
      new Header({
        // XXX split the path
        // then the path should be PaxHeader + basename, but less than 99,
        // prepend with the dirname
        path: ("PaxHeader/" + path2.basename(this.path)).slice(0, 99),
        mode: this.mode || 420,
        uid: this.uid || null,
        gid: this.gid || null,
        size: bodyLen,
        mtime: this.mtime || null,
        type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
        linkpath: "",
        uname: this.uname || "",
        gname: this.gname || "",
        devmaj: 0,
        devmin: 0,
        atime: this.atime || null,
        ctime: this.ctime || null
      }).encode(buf), buf.write(body, 512, bodyLen, "utf8");
      for (let i = bodyLen + 512; i < buf.length; i++)
        buf[i] = 0;
      return buf;
    }
    encodeBody() {
      return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
    }
    encodeField(field) {
      if (this[field] === null || this[field] === void 0)
        return "";
      const v = this[field] instanceof Date ? this[field].getTime() / 1e3 : this[field], s = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + `
`, byteLen = Buffer.byteLength(s);
      let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
      return byteLen + digits >= Math.pow(10, digits) && (digits += 1), digits + byteLen + s;
    }
  }
  Pax.parse = (string, ex, g) => new Pax(merge2(parseKV(string), ex), g);
  const merge2 = (a, b) => b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a, parseKV = (string) => string.replace(/\n$/, "").split(`
`).reduce(parseKVLine, /* @__PURE__ */ Object.create(null)), parseKVLine = (set2, line3) => {
    const n = parseInt(line3, 10);
    if (n !== Buffer.byteLength(line3) + 1)
      return set2;
    line3 = line3.slice((n + " ").length);
    const kv = line3.split("="), k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
    if (!k)
      return set2;
    const v = kv.join("=");
    return set2[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1e3) : /^[0-9]+$/.test(v) ? +v : v, set2;
  };
  return pax = Pax, pax;
}
var stripTrailingSlashes, hasRequiredStripTrailingSlashes;
function requireStripTrailingSlashes() {
  return hasRequiredStripTrailingSlashes || (hasRequiredStripTrailingSlashes = 1, stripTrailingSlashes = (str2) => {
    let i = str2.length - 1, slashesStart = -1;
    for (; i > -1 && str2.charAt(i) === "/"; )
      slashesStart = i, i--;
    return slashesStart === -1 ? str2 : str2.slice(0, slashesStart);
  }), stripTrailingSlashes;
}
var warnMixin, hasRequiredWarnMixin;
function requireWarnMixin() {
  return hasRequiredWarnMixin || (hasRequiredWarnMixin = 1, warnMixin = (Base) => class extends Base {
    warn(code, message, data = {}) {
      this.file && (data.file = this.file), this.cwd && (data.cwd = this.cwd), data.code = message instanceof Error && message.code || code, data.tarCode = code, !this.strict && data.recoverable !== !1 ? (message instanceof Error && (data = Object.assign(message, data), message = message.message), this.emit("warn", data.tarCode, message, data)) : message instanceof Error ? this.emit("error", Object.assign(message, data)) : this.emit("error", Object.assign(new Error(`${code}: ${message}`), data));
    }
  }), warnMixin;
}
var winchars, hasRequiredWinchars;
function requireWinchars() {
  if (hasRequiredWinchars) return winchars;
  hasRequiredWinchars = 1;
  const raw = [
    "|",
    "<",
    ">",
    "?",
    ":"
  ], win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0))), toWin = new Map(raw.map((char, i) => [char, win[i]])), toRaw = new Map(win.map((char, i) => [char, raw[i]]));
  return winchars = {
    encode: (s) => raw.reduce((s2, c2) => s2.split(c2).join(toWin.get(c2)), s),
    decode: (s) => win.reduce((s2, c2) => s2.split(c2).join(toRaw.get(c2)), s)
  }, winchars;
}
var stripAbsolutePath, hasRequiredStripAbsolutePath;
function requireStripAbsolutePath() {
  if (hasRequiredStripAbsolutePath) return stripAbsolutePath;
  hasRequiredStripAbsolutePath = 1;
  const { isAbsolute, parse: parse3 } = require$$0__default$1.default.win32;
  return stripAbsolutePath = (path2) => {
    let r = "", parsed = parse3(path2);
    for (; isAbsolute(path2) || parsed.root; ) {
      const root2 = path2.charAt(0) === "/" && path2.slice(0, 4) !== "//?/" ? "/" : parsed.root;
      path2 = path2.slice(root2.length), r += root2, parsed = parse3(path2);
    }
    return [r, path2];
  }, stripAbsolutePath;
}
var modeFix, hasRequiredModeFix;
function requireModeFix() {
  return hasRequiredModeFix || (hasRequiredModeFix = 1, modeFix = (mode2, isDir2, portable) => (mode2 &= 4095, portable && (mode2 = (mode2 | 384) & -19), isDir2 && (mode2 & 256 && (mode2 |= 64), mode2 & 32 && (mode2 |= 8), mode2 & 4 && (mode2 |= 1)), mode2)), modeFix;
}
var writeEntry, hasRequiredWriteEntry;
function requireWriteEntry() {
  if (hasRequiredWriteEntry) return writeEntry;
  hasRequiredWriteEntry = 1;
  const { Minipass: Minipass2 } = requireMinipass$1(), Pax = requirePax(), Header = requireHeader(), fs2 = require$$0__default.default, path2 = require$$0__default$1.default, normPath = requireNormalizeWindowsPath(), stripSlash = requireStripTrailingSlashes(), prefixPath = (path3, prefix) => prefix ? (path3 = normPath(path3).replace(/^\.(\/|$)/, ""), stripSlash(prefix) + "/" + path3) : normPath(path3), maxReadSize = 16 * 1024 * 1024, PROCESS2 = Symbol("process"), FILE = Symbol("file"), DIRECTORY = Symbol("directory"), SYMLINK = Symbol("symlink"), HARDLINK = Symbol("hardlink"), HEADER = Symbol("header"), READ2 = Symbol("read"), LSTAT = Symbol("lstat"), ONLSTAT = Symbol("onlstat"), ONREAD = Symbol("onread"), ONREADLINK = Symbol("onreadlink"), OPENFILE = Symbol("openfile"), ONOPENFILE = Symbol("onopenfile"), CLOSE = Symbol("close"), MODE = Symbol("mode"), AWAITDRAIN = Symbol("awaitDrain"), ONDRAIN = Symbol("ondrain"), PREFIX = Symbol("prefix"), HAD_ERROR = Symbol("hadError"), warner = requireWarnMixin(), winchars2 = requireWinchars(), stripAbsolutePath2 = requireStripAbsolutePath(), modeFix2 = requireModeFix(), WriteEntry = warner(class extends Minipass2 {
    constructor(p, opt) {
      if (opt = opt || {}, super(opt), typeof p != "string")
        throw new TypeError("path is required");
      this.path = normPath(p), this.portable = !!opt.portable, this.myuid = process.getuid && process.getuid() || 0, this.myuser = process.env.USER || "", this.maxReadSize = opt.maxReadSize || maxReadSize, this.linkCache = opt.linkCache || /* @__PURE__ */ new Map(), this.statCache = opt.statCache || /* @__PURE__ */ new Map(), this.preservePaths = !!opt.preservePaths, this.cwd = normPath(opt.cwd || process.cwd()), this.strict = !!opt.strict, this.noPax = !!opt.noPax, this.noMtime = !!opt.noMtime, this.mtime = opt.mtime || null, this.prefix = opt.prefix ? normPath(opt.prefix) : null, this.fd = null, this.blockLen = null, this.blockRemain = null, this.buf = null, this.offset = null, this.length = null, this.pos = null, this.remain = null, typeof opt.onwarn == "function" && this.on("warn", opt.onwarn);
      let pathWarn = !1;
      if (!this.preservePaths) {
        const [root2, stripped] = stripAbsolutePath2(this.path);
        root2 && (this.path = stripped, pathWarn = root2);
      }
      this.win32 = !!opt.win32 || process.platform === "win32", this.win32 && (this.path = winchars2.decode(this.path.replace(/\\/g, "/")), p = p.replace(/\\/g, "/")), this.absolute = normPath(opt.absolute || path2.resolve(this.cwd, p)), this.path === "" && (this.path = "./"), pathWarn && this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
        entry: this,
        path: pathWarn + this.path
      }), this.statCache.has(this.absolute) ? this[ONLSTAT](this.statCache.get(this.absolute)) : this[LSTAT]();
    }
    emit(ev, ...data) {
      return ev === "error" && (this[HAD_ERROR] = !0), super.emit(ev, ...data);
    }
    [LSTAT]() {
      fs2.lstat(this.absolute, (er, stat2) => {
        if (er)
          return this.emit("error", er);
        this[ONLSTAT](stat2);
      });
    }
    [ONLSTAT](stat2) {
      this.statCache.set(this.absolute, stat2), this.stat = stat2, stat2.isFile() || (stat2.size = 0), this.type = getType(stat2), this.emit("stat", stat2), this[PROCESS2]();
    }
    [PROCESS2]() {
      switch (this.type) {
        case "File":
          return this[FILE]();
        case "Directory":
          return this[DIRECTORY]();
        case "SymbolicLink":
          return this[SYMLINK]();
        // unsupported types are ignored.
        default:
          return this.end();
      }
    }
    [MODE](mode2) {
      return modeFix2(mode2, this.type === "Directory", this.portable);
    }
    [PREFIX](path3) {
      return prefixPath(path3, this.prefix);
    }
    [HEADER]() {
      this.type === "Directory" && this.portable && (this.noMtime = !0), this.header = new Header({
        path: this[PREFIX](this.path),
        // only apply the prefix to hard links.
        linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
        // only the permissions and setuid/setgid/sticky bitflags
        // not the higher-order bits that specify file type
        mode: this[MODE](this.stat.mode),
        uid: this.portable ? null : this.stat.uid,
        gid: this.portable ? null : this.stat.gid,
        size: this.stat.size,
        mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
        type: this.type,
        uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
        atime: this.portable ? null : this.stat.atime,
        ctime: this.portable ? null : this.stat.ctime
      }), this.header.encode() && !this.noPax && super.write(new Pax({
        atime: this.portable ? null : this.header.atime,
        ctime: this.portable ? null : this.header.ctime,
        gid: this.portable ? null : this.header.gid,
        mtime: this.noMtime ? null : this.mtime || this.header.mtime,
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
        size: this.header.size,
        uid: this.portable ? null : this.header.uid,
        uname: this.portable ? null : this.header.uname,
        dev: this.portable ? null : this.stat.dev,
        ino: this.portable ? null : this.stat.ino,
        nlink: this.portable ? null : this.stat.nlink
      }).encode()), super.write(this.header.block);
    }
    [DIRECTORY]() {
      this.path.slice(-1) !== "/" && (this.path += "/"), this.stat.size = 0, this[HEADER](), this.end();
    }
    [SYMLINK]() {
      fs2.readlink(this.absolute, (er, linkpath) => {
        if (er)
          return this.emit("error", er);
        this[ONREADLINK](linkpath);
      });
    }
    [ONREADLINK](linkpath) {
      this.linkpath = normPath(linkpath), this[HEADER](), this.end();
    }
    [HARDLINK](linkpath) {
      this.type = "Link", this.linkpath = normPath(path2.relative(this.cwd, linkpath)), this.stat.size = 0, this[HEADER](), this.end();
    }
    [FILE]() {
      if (this.stat.nlink > 1) {
        const linkKey = this.stat.dev + ":" + this.stat.ino;
        if (this.linkCache.has(linkKey)) {
          const linkpath = this.linkCache.get(linkKey);
          if (linkpath.indexOf(this.cwd) === 0)
            return this[HARDLINK](linkpath);
        }
        this.linkCache.set(linkKey, this.absolute);
      }
      if (this[HEADER](), this.stat.size === 0)
        return this.end();
      this[OPENFILE]();
    }
    [OPENFILE]() {
      fs2.open(this.absolute, "r", (er, fd) => {
        if (er)
          return this.emit("error", er);
        this[ONOPENFILE](fd);
      });
    }
    [ONOPENFILE](fd) {
      if (this.fd = fd, this[HAD_ERROR])
        return this[CLOSE]();
      this.blockLen = 512 * Math.ceil(this.stat.size / 512), this.blockRemain = this.blockLen;
      const bufLen = Math.min(this.blockLen, this.maxReadSize);
      this.buf = Buffer.allocUnsafe(bufLen), this.offset = 0, this.pos = 0, this.remain = this.stat.size, this.length = this.buf.length, this[READ2]();
    }
    [READ2]() {
      const { fd, buf, offset, length, pos: pos2 } = this;
      fs2.read(fd, buf, offset, length, pos2, (er, bytesRead) => {
        if (er)
          return this[CLOSE](() => this.emit("error", er));
        this[ONREAD](bytesRead);
      });
    }
    [CLOSE](cb) {
      fs2.close(this.fd, cb);
    }
    [ONREAD](bytesRead) {
      if (bytesRead <= 0 && this.remain > 0) {
        const er = new Error("encountered unexpected EOF");
        return er.path = this.absolute, er.syscall = "read", er.code = "EOF", this[CLOSE](() => this.emit("error", er));
      }
      if (bytesRead > this.remain) {
        const er = new Error("did not encounter expected EOF");
        return er.path = this.absolute, er.syscall = "read", er.code = "EOF", this[CLOSE](() => this.emit("error", er));
      }
      if (bytesRead === this.remain)
        for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++)
          this.buf[i + this.offset] = 0, bytesRead++, this.remain++;
      const writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);
      this.write(writeBuf) ? this[ONDRAIN]() : this[AWAITDRAIN](() => this[ONDRAIN]());
    }
    [AWAITDRAIN](cb) {
      this.once("drain", cb);
    }
    write(writeBuf) {
      if (this.blockRemain < writeBuf.length) {
        const er = new Error("writing more data than expected");
        return er.path = this.absolute, this.emit("error", er);
      }
      return this.remain -= writeBuf.length, this.blockRemain -= writeBuf.length, this.pos += writeBuf.length, this.offset += writeBuf.length, super.write(writeBuf);
    }
    [ONDRAIN]() {
      if (!this.remain)
        return this.blockRemain && super.write(Buffer.alloc(this.blockRemain)), this[CLOSE]((er) => er ? this.emit("error", er) : this.end());
      this.offset >= this.length && (this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length)), this.offset = 0), this.length = this.buf.length - this.offset, this[READ2]();
    }
  });
  class WriteEntrySync extends WriteEntry {
    [LSTAT]() {
      this[ONLSTAT](fs2.lstatSync(this.absolute));
    }
    [SYMLINK]() {
      this[ONREADLINK](fs2.readlinkSync(this.absolute));
    }
    [OPENFILE]() {
      this[ONOPENFILE](fs2.openSync(this.absolute, "r"));
    }
    [READ2]() {
      let threw = !0;
      try {
        const { fd, buf, offset, length, pos: pos2 } = this, bytesRead = fs2.readSync(fd, buf, offset, length, pos2);
        this[ONREAD](bytesRead), threw = !1;
      } finally {
        if (threw)
          try {
            this[CLOSE](() => {
            });
          } catch {
          }
      }
    }
    [AWAITDRAIN](cb) {
      cb();
    }
    [CLOSE](cb) {
      fs2.closeSync(this.fd), cb();
    }
  }
  const WriteEntryTar = warner(class extends Minipass2 {
    constructor(readEntry2, opt) {
      opt = opt || {}, super(opt), this.preservePaths = !!opt.preservePaths, this.portable = !!opt.portable, this.strict = !!opt.strict, this.noPax = !!opt.noPax, this.noMtime = !!opt.noMtime, this.readEntry = readEntry2, this.type = readEntry2.type, this.type === "Directory" && this.portable && (this.noMtime = !0), this.prefix = opt.prefix || null, this.path = normPath(readEntry2.path), this.mode = this[MODE](readEntry2.mode), this.uid = this.portable ? null : readEntry2.uid, this.gid = this.portable ? null : readEntry2.gid, this.uname = this.portable ? null : readEntry2.uname, this.gname = this.portable ? null : readEntry2.gname, this.size = readEntry2.size, this.mtime = this.noMtime ? null : opt.mtime || readEntry2.mtime, this.atime = this.portable ? null : readEntry2.atime, this.ctime = this.portable ? null : readEntry2.ctime, this.linkpath = normPath(readEntry2.linkpath), typeof opt.onwarn == "function" && this.on("warn", opt.onwarn);
      let pathWarn = !1;
      if (!this.preservePaths) {
        const [root2, stripped] = stripAbsolutePath2(this.path);
        root2 && (this.path = stripped, pathWarn = root2);
      }
      this.remain = readEntry2.size, this.blockRemain = readEntry2.startBlockSize, this.header = new Header({
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
        // only the permissions and setuid/setgid/sticky bitflags
        // not the higher-order bits that specify file type
        mode: this.mode,
        uid: this.portable ? null : this.uid,
        gid: this.portable ? null : this.gid,
        size: this.size,
        mtime: this.noMtime ? null : this.mtime,
        type: this.type,
        uname: this.portable ? null : this.uname,
        atime: this.portable ? null : this.atime,
        ctime: this.portable ? null : this.ctime
      }), pathWarn && this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
        entry: this,
        path: pathWarn + this.path
      }), this.header.encode() && !this.noPax && super.write(new Pax({
        atime: this.portable ? null : this.atime,
        ctime: this.portable ? null : this.ctime,
        gid: this.portable ? null : this.gid,
        mtime: this.noMtime ? null : this.mtime,
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
        size: this.size,
        uid: this.portable ? null : this.uid,
        uname: this.portable ? null : this.uname,
        dev: this.portable ? null : this.readEntry.dev,
        ino: this.portable ? null : this.readEntry.ino,
        nlink: this.portable ? null : this.readEntry.nlink
      }).encode()), super.write(this.header.block), readEntry2.pipe(this);
    }
    [PREFIX](path3) {
      return prefixPath(path3, this.prefix);
    }
    [MODE](mode2) {
      return modeFix2(mode2, this.type === "Directory", this.portable);
    }
    write(data) {
      const writeLen = data.length;
      if (writeLen > this.blockRemain)
        throw new Error("writing more to entry than is appropriate");
      return this.blockRemain -= writeLen, super.write(data);
    }
    end() {
      return this.blockRemain && super.write(Buffer.alloc(this.blockRemain)), super.end();
    }
  });
  WriteEntry.Sync = WriteEntrySync, WriteEntry.Tar = WriteEntryTar;
  const getType = (stat2) => stat2.isFile() ? "File" : stat2.isDirectory() ? "Directory" : stat2.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
  return writeEntry = WriteEntry, writeEntry;
}
var iterator$1, hasRequiredIterator;
function requireIterator() {
  return hasRequiredIterator || (hasRequiredIterator = 1, iterator$1 = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next)
        yield walker.value;
    };
  }), iterator$1;
}
var yallist, hasRequiredYallist;
function requireYallist() {
  if (hasRequiredYallist) return yallist;
  hasRequiredYallist = 1, yallist = Yallist, Yallist.Node = Node, Yallist.create = Yallist;
  function Yallist(list2) {
    var self2 = this;
    if (self2 instanceof Yallist || (self2 = new Yallist()), self2.tail = null, self2.head = null, self2.length = 0, list2 && typeof list2.forEach == "function")
      list2.forEach(function(item) {
        self2.push(item);
      });
    else if (arguments.length > 0)
      for (var i = 0, l = arguments.length; i < l; i++)
        self2.push(arguments[i]);
    return self2;
  }
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this)
      throw new Error("removing node which does not belong to this list");
    var next = node.next, prev = node.prev;
    return next && (next.prev = prev), prev && (prev.next = next), node === this.head && (this.head = next), node === this.tail && (this.tail = prev), node.list.length--, node.next = null, node.prev = null, node.list = null, next;
  }, Yallist.prototype.unshiftNode = function(node) {
    if (node !== this.head) {
      node.list && node.list.removeNode(node);
      var head = this.head;
      node.list = this, node.next = head, head && (head.prev = node), this.head = node, this.tail || (this.tail = node), this.length++;
    }
  }, Yallist.prototype.pushNode = function(node) {
    if (node !== this.tail) {
      node.list && node.list.removeNode(node);
      var tail = this.tail;
      node.list = this, node.prev = tail, tail && (tail.next = node), this.tail = node, this.head || (this.head = node), this.length++;
    }
  }, Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length; i < l; i++)
      push2(this, arguments[i]);
    return this.length;
  }, Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length; i < l; i++)
      unshift(this, arguments[i]);
    return this.length;
  }, Yallist.prototype.pop = function() {
    if (this.tail) {
      var res = this.tail.value;
      return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, res;
    }
  }, Yallist.prototype.shift = function() {
    if (this.head) {
      var res = this.head.value;
      return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, res;
    }
  }, Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0; walker !== null; i++)
      fn.call(thisp, walker.value, i, this), walker = walker.next;
  }, Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1; walker !== null; i--)
      fn.call(thisp, walker.value, i, this), walker = walker.prev;
  }, Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++)
      walker = walker.next;
    if (i === n && walker !== null)
      return walker.value;
  }, Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++)
      walker = walker.prev;
    if (i === n && walker !== null)
      return walker.value;
  }, Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    for (var res = new Yallist(), walker = this.head; walker !== null; )
      res.push(fn.call(thisp, walker.value, this)), walker = walker.next;
    return res;
  }, Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var res = new Yallist(), walker = this.tail; walker !== null; )
      res.push(fn.call(thisp, walker.value, this)), walker = walker.prev;
    return res;
  }, Yallist.prototype.reduce = function(fn, initial) {
    var acc, walker = this.head;
    if (arguments.length > 1)
      acc = initial;
    else if (this.head)
      walker = this.head.next, acc = this.head.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (var i = 0; walker !== null; i++)
      acc = fn(acc, walker.value, i), walker = walker.next;
    return acc;
  }, Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc, walker = this.tail;
    if (arguments.length > 1)
      acc = initial;
    else if (this.tail)
      walker = this.tail.prev, acc = this.tail.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (var i = this.length - 1; walker !== null; i--)
      acc = fn(acc, walker.value, i), walker = walker.prev;
    return acc;
  }, Yallist.prototype.toArray = function() {
    for (var arr = new Array(this.length), i = 0, walker = this.head; walker !== null; i++)
      arr[i] = walker.value, walker = walker.next;
    return arr;
  }, Yallist.prototype.toArrayReverse = function() {
    for (var arr = new Array(this.length), i = 0, walker = this.tail; walker !== null; i++)
      arr[i] = walker.value, walker = walker.prev;
    return arr;
  }, Yallist.prototype.slice = function(from2, to) {
    to = to || this.length, to < 0 && (to += this.length), from2 = from2 || 0, from2 < 0 && (from2 += this.length);
    var ret = new Yallist();
    if (to < from2 || to < 0)
      return ret;
    from2 < 0 && (from2 = 0), to > this.length && (to = this.length);
    for (var i = 0, walker = this.head; walker !== null && i < from2; i++)
      walker = walker.next;
    for (; walker !== null && i < to; i++, walker = walker.next)
      ret.push(walker.value);
    return ret;
  }, Yallist.prototype.sliceReverse = function(from2, to) {
    to = to || this.length, to < 0 && (to += this.length), from2 = from2 || 0, from2 < 0 && (from2 += this.length);
    var ret = new Yallist();
    if (to < from2 || to < 0)
      return ret;
    from2 < 0 && (from2 = 0), to > this.length && (to = this.length);
    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--)
      walker = walker.prev;
    for (; walker !== null && i > from2; i--, walker = walker.prev)
      ret.push(walker.value);
    return ret;
  }, Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    start > this.length && (start = this.length - 1), start < 0 && (start = this.length + start);
    for (var i = 0, walker = this.head; walker !== null && i < start; i++)
      walker = walker.next;
    for (var ret = [], i = 0; walker && i < deleteCount; i++)
      ret.push(walker.value), walker = this.removeNode(walker);
    walker === null && (walker = this.tail), walker !== this.head && walker !== this.tail && (walker = walker.prev);
    for (var i = 0; i < nodes.length; i++)
      walker = insert(this, walker, nodes[i]);
    return ret;
  }, Yallist.prototype.reverse = function() {
    for (var head = this.head, tail = this.tail, walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next, walker.next = p;
    }
    return this.head = tail, this.tail = head, this;
  };
  function insert(self2, node, value) {
    var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
    return inserted.next === null && (self2.tail = inserted), inserted.prev === null && (self2.head = inserted), self2.length++, inserted;
  }
  function push2(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2), self2.head || (self2.head = self2.tail), self2.length++;
  }
  function unshift(self2, item) {
    self2.head = new Node(item, null, self2.head, self2), self2.tail || (self2.tail = self2.head), self2.length++;
  }
  function Node(value, prev, next, list2) {
    if (!(this instanceof Node))
      return new Node(value, prev, next, list2);
    this.list = list2, this.value = value, prev ? (prev.next = this, this.prev = prev) : this.prev = null, next ? (next.prev = this, this.next = next) : this.next = null;
  }
  try {
    requireIterator()(Yallist);
  } catch {
  }
  return yallist;
}
var pack, hasRequiredPack;
function requirePack() {
  if (hasRequiredPack) return pack;
  hasRequiredPack = 1;
  class PackJob {
    constructor(path3, absolute) {
      this.path = path3 || "./", this.absolute = absolute, this.entry = null, this.stat = null, this.readdir = null, this.pending = !1, this.ignore = !1, this.piped = !1;
    }
  }
  const { Minipass: Minipass2 } = requireMinipass$1(), zlib = requireMinizlib(), ReadEntry = requireReadEntry(), WriteEntry = requireWriteEntry(), WriteEntrySync = WriteEntry.Sync, WriteEntryTar = WriteEntry.Tar, Yallist = requireYallist(), EOF2 = Buffer.alloc(1024), ONSTAT = Symbol("onStat"), ENDED = Symbol("ended"), QUEUE = Symbol("queue"), CURRENT = Symbol("current"), PROCESS2 = Symbol("process"), PROCESSING = Symbol("processing"), PROCESSJOB = Symbol("processJob"), JOBS = Symbol("jobs"), JOBDONE = Symbol("jobDone"), ADDFSENTRY = Symbol("addFSEntry"), ADDTARENTRY = Symbol("addTarEntry"), STAT = Symbol("stat"), READDIR = Symbol("readdir"), ONREADDIR = Symbol("onreaddir"), PIPE = Symbol("pipe"), ENTRY = Symbol("entry"), ENTRYOPT = Symbol("entryOpt"), WRITEENTRYCLASS = Symbol("writeEntryClass"), WRITE = Symbol("write"), ONDRAIN = Symbol("ondrain"), fs2 = require$$0__default.default, path2 = require$$0__default$1.default, warner = requireWarnMixin(), normPath = requireNormalizeWindowsPath(), Pack = warner(class extends Minipass2 {
    constructor(opt) {
      if (super(opt), opt = opt || /* @__PURE__ */ Object.create(null), this.opt = opt, this.file = opt.file || "", this.cwd = opt.cwd || process.cwd(), this.maxReadSize = opt.maxReadSize, this.preservePaths = !!opt.preservePaths, this.strict = !!opt.strict, this.noPax = !!opt.noPax, this.prefix = normPath(opt.prefix || ""), this.linkCache = opt.linkCache || /* @__PURE__ */ new Map(), this.statCache = opt.statCache || /* @__PURE__ */ new Map(), this.readdirCache = opt.readdirCache || /* @__PURE__ */ new Map(), this[WRITEENTRYCLASS] = WriteEntry, typeof opt.onwarn == "function" && this.on("warn", opt.onwarn), this.portable = !!opt.portable, this.zip = null, opt.gzip || opt.brotli) {
        if (opt.gzip && opt.brotli)
          throw new TypeError("gzip and brotli are mutually exclusive");
        opt.gzip && (typeof opt.gzip != "object" && (opt.gzip = {}), this.portable && (opt.gzip.portable = !0), this.zip = new zlib.Gzip(opt.gzip)), opt.brotli && (typeof opt.brotli != "object" && (opt.brotli = {}), this.zip = new zlib.BrotliCompress(opt.brotli)), this.zip.on("data", (chunk) => super.write(chunk)), this.zip.on("end", (_) => super.end()), this.zip.on("drain", (_) => this[ONDRAIN]()), this.on("resume", (_) => this.zip.resume());
      } else
        this.on("drain", this[ONDRAIN]);
      this.noDirRecurse = !!opt.noDirRecurse, this.follow = !!opt.follow, this.noMtime = !!opt.noMtime, this.mtime = opt.mtime || null, this.filter = typeof opt.filter == "function" ? opt.filter : (_) => !0, this[QUEUE] = new Yallist(), this[JOBS] = 0, this.jobs = +opt.jobs || 4, this[PROCESSING] = !1, this[ENDED] = !1;
    }
    [WRITE](chunk) {
      return super.write(chunk);
    }
    add(path3) {
      return this.write(path3), this;
    }
    end(path3) {
      return path3 && this.write(path3), this[ENDED] = !0, this[PROCESS2](), this;
    }
    write(path3) {
      if (this[ENDED])
        throw new Error("write after end");
      return path3 instanceof ReadEntry ? this[ADDTARENTRY](path3) : this[ADDFSENTRY](path3), this.flowing;
    }
    [ADDTARENTRY](p) {
      const absolute = normPath(path2.resolve(this.cwd, p.path));
      if (!this.filter(p.path, p))
        p.resume();
      else {
        const job = new PackJob(p.path, absolute, !1);
        job.entry = new WriteEntryTar(p, this[ENTRYOPT](job)), job.entry.on("end", (_) => this[JOBDONE](job)), this[JOBS] += 1, this[QUEUE].push(job);
      }
      this[PROCESS2]();
    }
    [ADDFSENTRY](p) {
      const absolute = normPath(path2.resolve(this.cwd, p));
      this[QUEUE].push(new PackJob(p, absolute)), this[PROCESS2]();
    }
    [STAT](job) {
      job.pending = !0, this[JOBS] += 1;
      const stat2 = this.follow ? "stat" : "lstat";
      fs2[stat2](job.absolute, (er, stat3) => {
        job.pending = !1, this[JOBS] -= 1, er ? this.emit("error", er) : this[ONSTAT](job, stat3);
      });
    }
    [ONSTAT](job, stat2) {
      this.statCache.set(job.absolute, stat2), job.stat = stat2, this.filter(job.path, stat2) || (job.ignore = !0), this[PROCESS2]();
    }
    [READDIR](job) {
      job.pending = !0, this[JOBS] += 1, fs2.readdir(job.absolute, (er, entries) => {
        if (job.pending = !1, this[JOBS] -= 1, er)
          return this.emit("error", er);
        this[ONREADDIR](job, entries);
      });
    }
    [ONREADDIR](job, entries) {
      this.readdirCache.set(job.absolute, entries), job.readdir = entries, this[PROCESS2]();
    }
    [PROCESS2]() {
      if (!this[PROCESSING]) {
        this[PROCESSING] = !0;
        for (let w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next)
          if (this[PROCESSJOB](w.value), w.value.ignore) {
            const p = w.next;
            this[QUEUE].removeNode(w), w.next = p;
          }
        this[PROCESSING] = !1, this[ENDED] && !this[QUEUE].length && this[JOBS] === 0 && (this.zip ? this.zip.end(EOF2) : (super.write(EOF2), super.end()));
      }
    }
    get [CURRENT]() {
      return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
    }
    [JOBDONE](job) {
      this[QUEUE].shift(), this[JOBS] -= 1, this[PROCESS2]();
    }
    [PROCESSJOB](job) {
      if (!job.pending) {
        if (job.entry) {
          job === this[CURRENT] && !job.piped && this[PIPE](job);
          return;
        }
        if (job.stat || (this.statCache.has(job.absolute) ? this[ONSTAT](job, this.statCache.get(job.absolute)) : this[STAT](job)), !!job.stat && !job.ignore && !(!this.noDirRecurse && job.stat.isDirectory() && !job.readdir && (this.readdirCache.has(job.absolute) ? this[ONREADDIR](job, this.readdirCache.get(job.absolute)) : this[READDIR](job), !job.readdir))) {
          if (job.entry = this[ENTRY](job), !job.entry) {
            job.ignore = !0;
            return;
          }
          job === this[CURRENT] && !job.piped && this[PIPE](job);
        }
      }
    }
    [ENTRYOPT](job) {
      return {
        onwarn: (code, msg, data) => this.warn(code, msg, data),
        noPax: this.noPax,
        cwd: this.cwd,
        absolute: job.absolute,
        preservePaths: this.preservePaths,
        maxReadSize: this.maxReadSize,
        strict: this.strict,
        portable: this.portable,
        linkCache: this.linkCache,
        statCache: this.statCache,
        noMtime: this.noMtime,
        mtime: this.mtime,
        prefix: this.prefix
      };
    }
    [ENTRY](job) {
      this[JOBS] += 1;
      try {
        return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
      } catch (er) {
        this.emit("error", er);
      }
    }
    [ONDRAIN]() {
      this[CURRENT] && this[CURRENT].entry && this[CURRENT].entry.resume();
    }
    // like .pipe() but using super, because our write() is special
    [PIPE](job) {
      job.piped = !0, job.readdir && job.readdir.forEach((entry) => {
        const p = job.path, base2 = p === "./" ? "" : p.replace(/\/*$/, "/");
        this[ADDFSENTRY](base2 + entry);
      });
      const source2 = job.entry, zip2 = this.zip;
      zip2 ? source2.on("data", (chunk) => {
        zip2.write(chunk) || source2.pause();
      }) : source2.on("data", (chunk) => {
        super.write(chunk) || source2.pause();
      });
    }
    pause() {
      return this.zip && this.zip.pause(), super.pause();
    }
  });
  class PackSync extends Pack {
    constructor(opt) {
      super(opt), this[WRITEENTRYCLASS] = WriteEntrySync;
    }
    // pause/resume are no-ops in sync streams.
    pause() {
    }
    resume() {
    }
    [STAT](job) {
      const stat2 = this.follow ? "statSync" : "lstatSync";
      this[ONSTAT](job, fs2[stat2](job.absolute));
    }
    [READDIR](job, stat2) {
      this[ONREADDIR](job, fs2.readdirSync(job.absolute));
    }
    // gotta get it all in this tick
    [PIPE](job) {
      const source2 = job.entry, zip2 = this.zip;
      job.readdir && job.readdir.forEach((entry) => {
        const p = job.path, base2 = p === "./" ? "" : p.replace(/\/*$/, "/");
        this[ADDFSENTRY](base2 + entry);
      }), zip2 ? source2.on("data", (chunk) => {
        zip2.write(chunk);
      }) : source2.on("data", (chunk) => {
        super[WRITE](chunk);
      });
    }
  }
  return Pack.Sync = PackSync, pack = Pack, pack;
}
var fsMinipass = {}, hasRequiredFsMinipass;
function requireFsMinipass() {
  if (hasRequiredFsMinipass) return fsMinipass;
  hasRequiredFsMinipass = 1;
  const MiniPass = requireMinipass(), EE = require$$0__default$7.default.EventEmitter, fs2 = require$$0__default.default;
  let writev = fs2.writev;
  if (!writev) {
    const binding = process.binding("fs"), FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
    writev = (fd, iovec, pos2, cb) => {
      const done = (er, bw) => cb(er, bw, iovec), req = new FSReqWrap();
      req.oncomplete = done, binding.writeBuffers(fd, iovec, pos2, req);
    };
  }
  const _autoClose = Symbol("_autoClose"), _close = Symbol("_close"), _ended = Symbol("_ended"), _fd = Symbol("_fd"), _finished = Symbol("_finished"), _flags = Symbol("_flags"), _flush = Symbol("_flush"), _handleChunk = Symbol("_handleChunk"), _makeBuf = Symbol("_makeBuf"), _mode = Symbol("_mode"), _needDrain = Symbol("_needDrain"), _onerror = Symbol("_onerror"), _onopen = Symbol("_onopen"), _onread = Symbol("_onread"), _onwrite = Symbol("_onwrite"), _open = Symbol("_open"), _path = Symbol("_path"), _pos = Symbol("_pos"), _queue = Symbol("_queue"), _read = Symbol("_read"), _readSize = Symbol("_readSize"), _reading = Symbol("_reading"), _remain = Symbol("_remain"), _size = Symbol("_size"), _write = Symbol("_write"), _writing = Symbol("_writing"), _defaultFlag = Symbol("_defaultFlag"), _errored = Symbol("_errored");
  class ReadStream extends MiniPass {
    constructor(path2, opt) {
      if (opt = opt || {}, super(opt), this.readable = !0, this.writable = !1, typeof path2 != "string")
        throw new TypeError("path must be a string");
      this[_errored] = !1, this[_fd] = typeof opt.fd == "number" ? opt.fd : null, this[_path] = path2, this[_readSize] = opt.readSize || 16 * 1024 * 1024, this[_reading] = !1, this[_size] = typeof opt.size == "number" ? opt.size : 1 / 0, this[_remain] = this[_size], this[_autoClose] = typeof opt.autoClose == "boolean" ? opt.autoClose : !0, typeof this[_fd] == "number" ? this[_read]() : this[_open]();
    }
    get fd() {
      return this[_fd];
    }
    get path() {
      return this[_path];
    }
    write() {
      throw new TypeError("this is a readable stream");
    }
    end() {
      throw new TypeError("this is a readable stream");
    }
    [_open]() {
      fs2.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
      er ? this[_onerror](er) : (this[_fd] = fd, this.emit("open", fd), this[_read]());
    }
    [_makeBuf]() {
      return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
    }
    [_read]() {
      if (!this[_reading]) {
        this[_reading] = !0;
        const buf = this[_makeBuf]();
        if (buf.length === 0)
          return process.nextTick(() => this[_onread](null, 0, buf));
        fs2.read(this[_fd], buf, 0, buf.length, null, (er, br, buf2) => this[_onread](er, br, buf2));
      }
    }
    [_onread](er, br, buf) {
      this[_reading] = !1, er ? this[_onerror](er) : this[_handleChunk](br, buf) && this[_read]();
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] == "number") {
        const fd = this[_fd];
        this[_fd] = null, fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
      }
    }
    [_onerror](er) {
      this[_reading] = !0, this[_close](), this.emit("error", er);
    }
    [_handleChunk](br, buf) {
      let ret = !1;
      return this[_remain] -= br, br > 0 && (ret = super.write(br < buf.length ? buf.slice(0, br) : buf)), (br === 0 || this[_remain] <= 0) && (ret = !1, this[_close](), super.end()), ret;
    }
    emit(ev, data) {
      switch (ev) {
        case "prefinish":
        case "finish":
          break;
        case "drain":
          typeof this[_fd] == "number" && this[_read]();
          break;
        case "error":
          return this[_errored] ? void 0 : (this[_errored] = !0, super.emit(ev, data));
        default:
          return super.emit(ev, data);
      }
    }
  }
  class ReadStreamSync extends ReadStream {
    [_open]() {
      let threw = !0;
      try {
        this[_onopen](null, fs2.openSync(this[_path], "r")), threw = !1;
      } finally {
        threw && this[_close]();
      }
    }
    [_read]() {
      let threw = !0;
      try {
        if (!this[_reading]) {
          this[_reading] = !0;
          do {
            const buf = this[_makeBuf](), br = buf.length === 0 ? 0 : fs2.readSync(this[_fd], buf, 0, buf.length, null);
            if (!this[_handleChunk](br, buf))
              break;
          } while (!0);
          this[_reading] = !1;
        }
        threw = !1;
      } finally {
        threw && this[_close]();
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] == "number") {
        const fd = this[_fd];
        this[_fd] = null, fs2.closeSync(fd), this.emit("close");
      }
    }
  }
  class WriteStream extends EE {
    constructor(path2, opt) {
      opt = opt || {}, super(opt), this.readable = !1, this.writable = !0, this[_errored] = !1, this[_writing] = !1, this[_ended] = !1, this[_needDrain] = !1, this[_queue] = [], this[_path] = path2, this[_fd] = typeof opt.fd == "number" ? opt.fd : null, this[_mode] = opt.mode === void 0 ? 438 : opt.mode, this[_pos] = typeof opt.start == "number" ? opt.start : null, this[_autoClose] = typeof opt.autoClose == "boolean" ? opt.autoClose : !0;
      const defaultFlag = this[_pos] !== null ? "r+" : "w";
      this[_defaultFlag] = opt.flags === void 0, this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags, this[_fd] === null && this[_open]();
    }
    emit(ev, data) {
      if (ev === "error") {
        if (this[_errored])
          return;
        this[_errored] = !0;
      }
      return super.emit(ev, data);
    }
    get fd() {
      return this[_fd];
    }
    get path() {
      return this[_path];
    }
    [_onerror](er) {
      this[_close](), this[_writing] = !0, this.emit("error", er);
    }
    [_open]() {
      fs2.open(
        this[_path],
        this[_flags],
        this[_mode],
        (er, fd) => this[_onopen](er, fd)
      );
    }
    [_onopen](er, fd) {
      this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT" ? (this[_flags] = "w", this[_open]()) : er ? this[_onerror](er) : (this[_fd] = fd, this.emit("open", fd), this[_flush]());
    }
    end(buf, enc) {
      return buf && this.write(buf, enc), this[_ended] = !0, !this[_writing] && !this[_queue].length && typeof this[_fd] == "number" && this[_onwrite](null, 0), this;
    }
    write(buf, enc) {
      return typeof buf == "string" && (buf = Buffer.from(buf, enc)), this[_ended] ? (this.emit("error", new Error("write() after end()")), !1) : this[_fd] === null || this[_writing] || this[_queue].length ? (this[_queue].push(buf), this[_needDrain] = !0, !1) : (this[_writing] = !0, this[_write](buf), !0);
    }
    [_write](buf) {
      fs2.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
    }
    [_onwrite](er, bw) {
      er ? this[_onerror](er) : (this[_pos] !== null && (this[_pos] += bw), this[_queue].length ? this[_flush]() : (this[_writing] = !1, this[_ended] && !this[_finished] ? (this[_finished] = !0, this[_close](), this.emit("finish")) : this[_needDrain] && (this[_needDrain] = !1, this.emit("drain"))));
    }
    [_flush]() {
      if (this[_queue].length === 0)
        this[_ended] && this[_onwrite](null, 0);
      else if (this[_queue].length === 1)
        this[_write](this[_queue].pop());
      else {
        const iovec = this[_queue];
        this[_queue] = [], writev(
          this[_fd],
          iovec,
          this[_pos],
          (er, bw) => this[_onwrite](er, bw)
        );
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] == "number") {
        const fd = this[_fd];
        this[_fd] = null, fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
      }
    }
  }
  class WriteStreamSync extends WriteStream {
    [_open]() {
      let fd;
      if (this[_defaultFlag] && this[_flags] === "r+")
        try {
          fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
        } catch (er) {
          if (er.code === "ENOENT")
            return this[_flags] = "w", this[_open]();
          throw er;
        }
      else
        fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
      this[_onopen](null, fd);
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] == "number") {
        const fd = this[_fd];
        this[_fd] = null, fs2.closeSync(fd), this.emit("close");
      }
    }
    [_write](buf) {
      let threw = !0;
      try {
        this[_onwrite](
          null,
          fs2.writeSync(this[_fd], buf, 0, buf.length, this[_pos])
        ), threw = !1;
      } finally {
        if (threw)
          try {
            this[_close]();
          } catch {
          }
      }
    }
  }
  return fsMinipass.ReadStream = ReadStream, fsMinipass.ReadStreamSync = ReadStreamSync, fsMinipass.WriteStream = WriteStream, fsMinipass.WriteStreamSync = WriteStreamSync, fsMinipass;
}
var parse, hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  const warner = requireWarnMixin(), Header = requireHeader(), EE = require$$0__default$7.default, Yallist = requireYallist(), maxMetaEntrySize = 1024 * 1024, Entry = requireReadEntry(), Pax = requirePax(), zlib = requireMinizlib(), { nextTick } = require$$7__default.default, gzipHeader = Buffer.from([31, 139]), STATE = Symbol("state"), WRITEENTRY = Symbol("writeEntry"), READENTRY = Symbol("readEntry"), NEXTENTRY = Symbol("nextEntry"), PROCESSENTRY = Symbol("processEntry"), EX = Symbol("extendedHeader"), GEX = Symbol("globalExtendedHeader"), META = Symbol("meta"), EMITMETA = Symbol("emitMeta"), BUFFER2 = Symbol("buffer"), QUEUE = Symbol("queue"), ENDED = Symbol("ended"), EMITTEDEND = Symbol("emittedEnd"), EMIT = Symbol("emit"), UNZIP = Symbol("unzip"), CONSUMECHUNK = Symbol("consumeChunk"), CONSUMECHUNKSUB = Symbol("consumeChunkSub"), CONSUMEBODY = Symbol("consumeBody"), CONSUMEMETA = Symbol("consumeMeta"), CONSUMEHEADER = Symbol("consumeHeader"), CONSUMING = Symbol("consuming"), BUFFERCONCAT = Symbol("bufferConcat"), MAYBEEND = Symbol("maybeEnd"), WRITING = Symbol("writing"), ABORTED2 = Symbol("aborted"), DONE = Symbol("onDone"), SAW_VALID_ENTRY = Symbol("sawValidEntry"), SAW_NULL_BLOCK = Symbol("sawNullBlock"), SAW_EOF = Symbol("sawEOF"), CLOSESTREAM = Symbol("closeStream"), noop2 = (_) => !0;
  return parse = warner(class extends EE {
    constructor(opt) {
      opt = opt || {}, super(opt), this.file = opt.file || "", this[SAW_VALID_ENTRY] = null, this.on(DONE, (_) => {
        (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === !1) && this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
      }), opt.ondone ? this.on(DONE, opt.ondone) : this.on(DONE, (_) => {
        this.emit("prefinish"), this.emit("finish"), this.emit("end");
      }), this.strict = !!opt.strict, this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize, this.filter = typeof opt.filter == "function" ? opt.filter : noop2;
      const isTBR = opt.file && (opt.file.endsWith(".tar.br") || opt.file.endsWith(".tbr"));
      this.brotli = !opt.gzip && opt.brotli !== void 0 ? opt.brotli : isTBR ? void 0 : !1, this.writable = !0, this.readable = !1, this[QUEUE] = new Yallist(), this[BUFFER2] = null, this[READENTRY] = null, this[WRITEENTRY] = null, this[STATE] = "begin", this[META] = "", this[EX] = null, this[GEX] = null, this[ENDED] = !1, this[UNZIP] = null, this[ABORTED2] = !1, this[SAW_NULL_BLOCK] = !1, this[SAW_EOF] = !1, this.on("end", () => this[CLOSESTREAM]()), typeof opt.onwarn == "function" && this.on("warn", opt.onwarn), typeof opt.onentry == "function" && this.on("entry", opt.onentry);
    }
    [CONSUMEHEADER](chunk, position) {
      this[SAW_VALID_ENTRY] === null && (this[SAW_VALID_ENTRY] = !1);
      let header2;
      try {
        header2 = new Header(chunk, position, this[EX], this[GEX]);
      } catch (er) {
        return this.warn("TAR_ENTRY_INVALID", er);
      }
      if (header2.nullBlock)
        this[SAW_NULL_BLOCK] ? (this[SAW_EOF] = !0, this[STATE] === "begin" && (this[STATE] = "header"), this[EMIT]("eof")) : (this[SAW_NULL_BLOCK] = !0, this[EMIT]("nullBlock"));
      else if (this[SAW_NULL_BLOCK] = !1, !header2.cksumValid)
        this.warn("TAR_ENTRY_INVALID", "checksum failure", { header: header2 });
      else if (!header2.path)
        this.warn("TAR_ENTRY_INVALID", "path is required", { header: header2 });
      else {
        const type2 = header2.type;
        if (/^(Symbolic)?Link$/.test(type2) && !header2.linkpath)
          this.warn("TAR_ENTRY_INVALID", "linkpath required", { header: header2 });
        else if (!/^(Symbolic)?Link$/.test(type2) && header2.linkpath)
          this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", { header: header2 });
        else {
          const entry = this[WRITEENTRY] = new Entry(header2, this[EX], this[GEX]);
          if (!this[SAW_VALID_ENTRY])
            if (entry.remain) {
              const onend = () => {
                entry.invalid || (this[SAW_VALID_ENTRY] = !0);
              };
              entry.on("end", onend);
            } else
              this[SAW_VALID_ENTRY] = !0;
          entry.meta ? entry.size > this.maxMetaEntrySize ? (entry.ignore = !0, this[EMIT]("ignoredEntry", entry), this[STATE] = "ignore", entry.resume()) : entry.size > 0 && (this[META] = "", entry.on("data", (c2) => this[META] += c2), this[STATE] = "meta") : (this[EX] = null, entry.ignore = entry.ignore || !this.filter(entry.path, entry), entry.ignore ? (this[EMIT]("ignoredEntry", entry), this[STATE] = entry.remain ? "ignore" : "header", entry.resume()) : (entry.remain ? this[STATE] = "body" : (this[STATE] = "header", entry.end()), this[READENTRY] ? this[QUEUE].push(entry) : (this[QUEUE].push(entry), this[NEXTENTRY]())));
        }
      }
    }
    [CLOSESTREAM]() {
      nextTick(() => this.emit("close"));
    }
    [PROCESSENTRY](entry) {
      let go = !0;
      return entry ? Array.isArray(entry) ? this.emit.apply(this, entry) : (this[READENTRY] = entry, this.emit("entry", entry), entry.emittedEnd || (entry.on("end", (_) => this[NEXTENTRY]()), go = !1)) : (this[READENTRY] = null, go = !1), go;
    }
    [NEXTENTRY]() {
      do
        ;
      while (this[PROCESSENTRY](this[QUEUE].shift()));
      if (!this[QUEUE].length) {
        const re = this[READENTRY];
        !re || re.flowing || re.size === re.remain ? this[WRITING] || this.emit("drain") : re.once("drain", (_) => this.emit("drain"));
      }
    }
    [CONSUMEBODY](chunk, position) {
      const entry = this[WRITEENTRY], br = entry.blockRemain, c2 = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);
      return entry.write(c2), entry.blockRemain || (this[STATE] = "header", this[WRITEENTRY] = null, entry.end()), c2.length;
    }
    [CONSUMEMETA](chunk, position) {
      const entry = this[WRITEENTRY], ret = this[CONSUMEBODY](chunk, position);
      return this[WRITEENTRY] || this[EMITMETA](entry), ret;
    }
    [EMIT](ev, data, extra) {
      !this[QUEUE].length && !this[READENTRY] ? this.emit(ev, data, extra) : this[QUEUE].push([ev, data, extra]);
    }
    [EMITMETA](entry) {
      switch (this[EMIT]("meta", this[META]), entry.type) {
        case "ExtendedHeader":
        case "OldExtendedHeader":
          this[EX] = Pax.parse(this[META], this[EX], !1);
          break;
        case "GlobalExtendedHeader":
          this[GEX] = Pax.parse(this[META], this[GEX], !0);
          break;
        case "NextFileHasLongPath":
        case "OldGnuLongPath":
          this[EX] = this[EX] || /* @__PURE__ */ Object.create(null), this[EX].path = this[META].replace(/\0.*/, "");
          break;
        case "NextFileHasLongLinkpath":
          this[EX] = this[EX] || /* @__PURE__ */ Object.create(null), this[EX].linkpath = this[META].replace(/\0.*/, "");
          break;
        /* istanbul ignore next */
        default:
          throw new Error("unknown meta: " + entry.type);
      }
    }
    abort(error2) {
      this[ABORTED2] = !0, this.emit("abort", error2), this.warn("TAR_ABORT", error2, { recoverable: !1 });
    }
    write(chunk) {
      if (this[ABORTED2])
        return;
      if ((this[UNZIP] === null || this.brotli === void 0 && this[UNZIP] === !1) && chunk) {
        if (this[BUFFER2] && (chunk = Buffer.concat([this[BUFFER2], chunk]), this[BUFFER2] = null), chunk.length < gzipHeader.length)
          return this[BUFFER2] = chunk, !0;
        for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++)
          chunk[i] !== gzipHeader[i] && (this[UNZIP] = !1);
        const maybeBrotli = this.brotli === void 0;
        if (this[UNZIP] === !1 && maybeBrotli)
          if (chunk.length < 512)
            if (this[ENDED])
              this.brotli = !0;
            else
              return this[BUFFER2] = chunk, !0;
          else
            try {
              new Header(chunk.slice(0, 512)), this.brotli = !1;
            } catch {
              this.brotli = !0;
            }
        if (this[UNZIP] === null || this[UNZIP] === !1 && this.brotli) {
          const ended = this[ENDED];
          this[ENDED] = !1, this[UNZIP] = this[UNZIP] === null ? new zlib.Unzip() : new zlib.BrotliDecompress(), this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2)), this[UNZIP].on("error", (er) => this.abort(er)), this[UNZIP].on("end", (_) => {
            this[ENDED] = !0, this[CONSUMECHUNK]();
          }), this[WRITING] = !0;
          const ret2 = this[UNZIP][ended ? "end" : "write"](chunk);
          return this[WRITING] = !1, ret2;
        }
      }
      this[WRITING] = !0, this[UNZIP] ? this[UNZIP].write(chunk) : this[CONSUMECHUNK](chunk), this[WRITING] = !1;
      const ret = this[QUEUE].length ? !1 : this[READENTRY] ? this[READENTRY].flowing : !0;
      return !ret && !this[QUEUE].length && this[READENTRY].once("drain", (_) => this.emit("drain")), ret;
    }
    [BUFFERCONCAT](c2) {
      c2 && !this[ABORTED2] && (this[BUFFER2] = this[BUFFER2] ? Buffer.concat([this[BUFFER2], c2]) : c2);
    }
    [MAYBEEND]() {
      if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED2] && !this[CONSUMING]) {
        this[EMITTEDEND] = !0;
        const entry = this[WRITEENTRY];
        if (entry && entry.blockRemain) {
          const have = this[BUFFER2] ? this[BUFFER2].length : 0;
          this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry }), this[BUFFER2] && entry.write(this[BUFFER2]), entry.end();
        }
        this[EMIT](DONE);
      }
    }
    [CONSUMECHUNK](chunk) {
      if (this[CONSUMING])
        this[BUFFERCONCAT](chunk);
      else if (!chunk && !this[BUFFER2])
        this[MAYBEEND]();
      else {
        if (this[CONSUMING] = !0, this[BUFFER2]) {
          this[BUFFERCONCAT](chunk);
          const c2 = this[BUFFER2];
          this[BUFFER2] = null, this[CONSUMECHUNKSUB](c2);
        } else
          this[CONSUMECHUNKSUB](chunk);
        for (; this[BUFFER2] && this[BUFFER2].length >= 512 && !this[ABORTED2] && !this[SAW_EOF]; ) {
          const c2 = this[BUFFER2];
          this[BUFFER2] = null, this[CONSUMECHUNKSUB](c2);
        }
        this[CONSUMING] = !1;
      }
      (!this[BUFFER2] || this[ENDED]) && this[MAYBEEND]();
    }
    [CONSUMECHUNKSUB](chunk) {
      let position = 0;
      const length = chunk.length;
      for (; position + 512 <= length && !this[ABORTED2] && !this[SAW_EOF]; )
        switch (this[STATE]) {
          case "begin":
          case "header":
            this[CONSUMEHEADER](chunk, position), position += 512;
            break;
          case "ignore":
          case "body":
            position += this[CONSUMEBODY](chunk, position);
            break;
          case "meta":
            position += this[CONSUMEMETA](chunk, position);
            break;
          /* istanbul ignore next */
          default:
            throw new Error("invalid state: " + this[STATE]);
        }
      position < length && (this[BUFFER2] ? this[BUFFER2] = Buffer.concat([chunk.slice(position), this[BUFFER2]]) : this[BUFFER2] = chunk.slice(position));
    }
    end(chunk) {
      this[ABORTED2] || (this[UNZIP] ? this[UNZIP].end(chunk) : (this[ENDED] = !0, this.brotli === void 0 && (chunk = chunk || Buffer.alloc(0)), this.write(chunk)));
    }
  }), parse;
}
var list_1, hasRequiredList$1;
function requireList$1() {
  if (hasRequiredList$1) return list_1;
  hasRequiredList$1 = 1;
  const hlo = requireHighLevelOpt(), Parser = requireParse(), fs2 = require$$0__default.default, fsm = requireFsMinipass(), path2 = require$$0__default$1.default, stripSlash = requireStripTrailingSlashes();
  list_1 = (opt_, files, cb) => {
    typeof opt_ == "function" ? (cb = opt_, files = null, opt_ = {}) : Array.isArray(opt_) && (files = opt_, opt_ = {}), typeof files == "function" && (cb = files, files = null), files ? files = Array.from(files) : files = [];
    const opt = hlo(opt_);
    if (opt.sync && typeof cb == "function")
      throw new TypeError("callback not supported for sync tar functions");
    if (!opt.file && typeof cb == "function")
      throw new TypeError("callback only supported with file option");
    return files.length && filesFilter(opt, files), opt.noResume || onentryFunction(opt), opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list2(opt);
  };
  const onentryFunction = (opt) => {
    const onentry = opt.onentry;
    opt.onentry = onentry ? (e) => {
      onentry(e), e.resume();
    } : (e) => e.resume();
  }, filesFilter = (opt, files) => {
    const map2 = new Map(files.map((f) => [stripSlash(f), !0])), filter2 = opt.filter, mapHas = (file, r) => {
      const root2 = r || path2.parse(file).root || ".", ret = file === root2 ? !1 : map2.has(file) ? map2.get(file) : mapHas(path2.dirname(file), root2);
      return map2.set(file, ret), ret;
    };
    opt.filter = filter2 ? (file, entry) => filter2(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
  }, listFileSync = (opt) => {
    const p = list2(opt), file = opt.file;
    let threw = !0, fd;
    try {
      const stat2 = fs2.statSync(file), readSize = opt.maxReadSize || 16 * 1024 * 1024;
      if (stat2.size < readSize)
        p.end(fs2.readFileSync(file));
      else {
        let pos2 = 0;
        const buf = Buffer.allocUnsafe(readSize);
        for (fd = fs2.openSync(file, "r"); pos2 < stat2.size; ) {
          const bytesRead = fs2.readSync(fd, buf, 0, readSize, pos2);
          pos2 += bytesRead, p.write(buf.slice(0, bytesRead));
        }
        p.end();
      }
      threw = !1;
    } finally {
      if (threw && fd)
        try {
          fs2.closeSync(fd);
        } catch {
        }
    }
  }, listFile = (opt, cb) => {
    const parse3 = new Parser(opt), readSize = opt.maxReadSize || 16 * 1024 * 1024, file = opt.file, p = new Promise((resolve, reject) => {
      parse3.on("error", reject), parse3.on("end", resolve), fs2.stat(file, (er, stat2) => {
        if (er)
          reject(er);
        else {
          const stream2 = new fsm.ReadStream(file, {
            readSize,
            size: stat2.size
          });
          stream2.on("error", reject), stream2.pipe(parse3);
        }
      });
    });
    return cb ? p.then(cb, cb) : p;
  }, list2 = (opt) => new Parser(opt);
  return list_1;
}
var create_1, hasRequiredCreate;
function requireCreate() {
  if (hasRequiredCreate) return create_1;
  hasRequiredCreate = 1;
  const hlo = requireHighLevelOpt(), Pack = requirePack(), fsm = requireFsMinipass(), t = requireList$1(), path2 = require$$0__default$1.default;
  create_1 = (opt_, files, cb) => {
    if (typeof files == "function" && (cb = files), Array.isArray(opt_) && (files = opt_, opt_ = {}), !files || !Array.isArray(files) || !files.length)
      throw new TypeError("no files or directories specified");
    files = Array.from(files);
    const opt = hlo(opt_);
    if (opt.sync && typeof cb == "function")
      throw new TypeError("callback not supported for sync tar functions");
    if (!opt.file && typeof cb == "function")
      throw new TypeError("callback only supported with file option");
    return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create(opt, files);
  };
  const createFileSync = (opt, files) => {
    const p = new Pack.Sync(opt), stream2 = new fsm.WriteStreamSync(opt.file, {
      mode: opt.mode || 438
    });
    p.pipe(stream2), addFilesSync(p, files);
  }, createFile = (opt, files, cb) => {
    const p = new Pack(opt), stream2 = new fsm.WriteStream(opt.file, {
      mode: opt.mode || 438
    });
    p.pipe(stream2);
    const promise2 = new Promise((res, rej) => {
      stream2.on("error", rej), stream2.on("close", res), p.on("error", rej);
    });
    return addFilesAsync(p, files), cb ? promise2.then(cb, cb) : promise2;
  }, addFilesSync = (p, files) => {
    files.forEach((file) => {
      file.charAt(0) === "@" ? t({
        file: path2.resolve(p.cwd, file.slice(1)),
        sync: !0,
        noResume: !0,
        onentry: (entry) => p.add(entry)
      }) : p.add(file);
    }), p.end();
  }, addFilesAsync = (p, files) => {
    for (; files.length; ) {
      const file = files.shift();
      if (file.charAt(0) === "@")
        return t({
          file: path2.resolve(p.cwd, file.slice(1)),
          noResume: !0,
          onentry: (entry) => p.add(entry)
        }).then((_) => addFilesAsync(p, files));
      p.add(file);
    }
    p.end();
  }, createSync = (opt, files) => {
    const p = new Pack.Sync(opt);
    return addFilesSync(p, files), p;
  }, create = (opt, files) => {
    const p = new Pack(opt);
    return addFilesAsync(p, files), p;
  };
  return create_1;
}
var replace_1, hasRequiredReplace;
function requireReplace() {
  if (hasRequiredReplace) return replace_1;
  hasRequiredReplace = 1;
  const hlo = requireHighLevelOpt(), Pack = requirePack(), fs2 = require$$0__default.default, fsm = requireFsMinipass(), t = requireList$1(), path2 = require$$0__default$1.default, Header = requireHeader();
  replace_1 = (opt_, files, cb) => {
    const opt = hlo(opt_);
    if (!opt.file)
      throw new TypeError("file is required");
    if (opt.gzip || opt.brotli || opt.file.endsWith(".br") || opt.file.endsWith(".tbr"))
      throw new TypeError("cannot append to compressed archives");
    if (!files || !Array.isArray(files) || !files.length)
      throw new TypeError("no files or directories specified");
    return files = Array.from(files), opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);
  };
  const replaceSync = (opt, files) => {
    const p = new Pack.Sync(opt);
    let threw = !0, fd, position;
    try {
      try {
        fd = fs2.openSync(opt.file, "r+");
      } catch (er) {
        if (er.code === "ENOENT")
          fd = fs2.openSync(opt.file, "w+");
        else
          throw er;
      }
      const st = fs2.fstatSync(fd), headBuf = Buffer.alloc(512);
      POSITION: for (position = 0; position < st.size; position += 512) {
        for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
          if (bytes = fs2.readSync(
            fd,
            headBuf,
            bufPos,
            headBuf.length - bufPos,
            position + bufPos
          ), position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
            throw new Error("cannot append to compressed archives");
          if (!bytes)
            break POSITION;
        }
        const h = new Header(headBuf);
        if (!h.cksumValid)
          break;
        const entryBlockSize = 512 * Math.ceil(h.size / 512);
        if (position + entryBlockSize + 512 > st.size)
          break;
        position += entryBlockSize, opt.mtimeCache && opt.mtimeCache.set(h.path, h.mtime);
      }
      threw = !1, streamSync2(opt, p, position, fd, files);
    } finally {
      if (threw)
        try {
          fs2.closeSync(fd);
        } catch {
        }
    }
  }, streamSync2 = (opt, p, position, fd, files) => {
    const stream2 = new fsm.WriteStreamSync(opt.file, {
      fd,
      start: position
    });
    p.pipe(stream2), addFilesSync(p, files);
  }, replace = (opt, files, cb) => {
    files = Array.from(files);
    const p = new Pack(opt), getPos = (fd, size, cb_) => {
      const cb2 = (er, pos2) => {
        er ? fs2.close(fd, (_) => cb_(er)) : cb_(null, pos2);
      };
      let position = 0;
      if (size === 0)
        return cb2(null, 0);
      let bufPos = 0;
      const headBuf = Buffer.alloc(512), onread = (er, bytes) => {
        if (er)
          return cb2(er);
        if (bufPos += bytes, bufPos < 512 && bytes)
          return fs2.read(
            fd,
            headBuf,
            bufPos,
            headBuf.length - bufPos,
            position + bufPos,
            onread
          );
        if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
          return cb2(new Error("cannot append to compressed archives"));
        if (bufPos < 512)
          return cb2(null, position);
        const h = new Header(headBuf);
        if (!h.cksumValid)
          return cb2(null, position);
        const entryBlockSize = 512 * Math.ceil(h.size / 512);
        if (position + entryBlockSize + 512 > size || (position += entryBlockSize + 512, position >= size))
          return cb2(null, position);
        opt.mtimeCache && opt.mtimeCache.set(h.path, h.mtime), bufPos = 0, fs2.read(fd, headBuf, 0, 512, position, onread);
      };
      fs2.read(fd, headBuf, 0, 512, position, onread);
    }, promise2 = new Promise((resolve, reject) => {
      p.on("error", reject);
      let flag = "r+";
      const onopen = (er, fd) => {
        if (er && er.code === "ENOENT" && flag === "r+")
          return flag = "w+", fs2.open(opt.file, flag, onopen);
        if (er)
          return reject(er);
        fs2.fstat(fd, (er2, st) => {
          if (er2)
            return fs2.close(fd, () => reject(er2));
          getPos(fd, st.size, (er3, position) => {
            if (er3)
              return reject(er3);
            const stream2 = new fsm.WriteStream(opt.file, {
              fd,
              start: position
            });
            p.pipe(stream2), stream2.on("error", reject), stream2.on("close", resolve), addFilesAsync(p, files);
          });
        });
      };
      fs2.open(opt.file, flag, onopen);
    });
    return cb ? promise2.then(cb, cb) : promise2;
  }, addFilesSync = (p, files) => {
    files.forEach((file) => {
      file.charAt(0) === "@" ? t({
        file: path2.resolve(p.cwd, file.slice(1)),
        sync: !0,
        noResume: !0,
        onentry: (entry) => p.add(entry)
      }) : p.add(file);
    }), p.end();
  }, addFilesAsync = (p, files) => {
    for (; files.length; ) {
      const file = files.shift();
      if (file.charAt(0) === "@")
        return t({
          file: path2.resolve(p.cwd, file.slice(1)),
          noResume: !0,
          onentry: (entry) => p.add(entry)
        }).then((_) => addFilesAsync(p, files));
      p.add(file);
    }
    p.end();
  };
  return replace_1;
}
var update, hasRequiredUpdate;
function requireUpdate() {
  if (hasRequiredUpdate) return update;
  hasRequiredUpdate = 1;
  const hlo = requireHighLevelOpt(), r = requireReplace();
  update = (opt_, files, cb) => {
    const opt = hlo(opt_);
    if (!opt.file)
      throw new TypeError("file is required");
    if (opt.gzip || opt.brotli || opt.file.endsWith(".br") || opt.file.endsWith(".tbr"))
      throw new TypeError("cannot append to compressed archives");
    if (!files || !Array.isArray(files) || !files.length)
      throw new TypeError("no files or directories specified");
    return files = Array.from(files), mtimeFilter(opt), r(opt, files, cb);
  };
  const mtimeFilter = (opt) => {
    const filter2 = opt.filter;
    opt.mtimeCache || (opt.mtimeCache = /* @__PURE__ */ new Map()), opt.filter = filter2 ? (path2, stat2) => filter2(path2, stat2) && !(opt.mtimeCache.get(path2) > stat2.mtime) : (path2, stat2) => !(opt.mtimeCache.get(path2) > stat2.mtime);
  };
  return update;
}
var mkdir = { exports: {} }, optsArg_1, hasRequiredOptsArg;
function requireOptsArg() {
  if (hasRequiredOptsArg) return optsArg_1;
  hasRequiredOptsArg = 1;
  const { promisify } = require$$0__default$5.default, fs2 = require$$0__default.default;
  return optsArg_1 = (opts) => {
    if (!opts)
      opts = { mode: 511, fs: fs2 };
    else if (typeof opts == "object")
      opts = { mode: 511, fs: fs2, ...opts };
    else if (typeof opts == "number")
      opts = { mode: opts, fs: fs2 };
    else if (typeof opts == "string")
      opts = { mode: parseInt(opts, 8), fs: fs2 };
    else
      throw new TypeError("invalid options argument");
    return opts.mkdir = opts.mkdir || opts.fs.mkdir || fs2.mkdir, opts.mkdirAsync = promisify(opts.mkdir), opts.stat = opts.stat || opts.fs.stat || fs2.stat, opts.statAsync = promisify(opts.stat), opts.statSync = opts.statSync || opts.fs.statSync || fs2.statSync, opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs2.mkdirSync, opts;
  }, optsArg_1;
}
var pathArg_1, hasRequiredPathArg;
function requirePathArg() {
  if (hasRequiredPathArg) return pathArg_1;
  hasRequiredPathArg = 1;
  const platform2 = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform, { resolve, parse: parse3 } = require$$0__default$1.default;
  return pathArg_1 = (path2) => {
    if (/\0/.test(path2))
      throw Object.assign(
        new TypeError("path must be a string without null bytes"),
        {
          path: path2,
          code: "ERR_INVALID_ARG_VALUE"
        }
      );
    if (path2 = resolve(path2), platform2 === "win32") {
      const badWinChars = /[*|"<>?:]/, { root: root2 } = parse3(path2);
      if (badWinChars.test(path2.substr(root2.length)))
        throw Object.assign(new Error("Illegal characters in path."), {
          path: path2,
          code: "EINVAL"
        });
    }
    return path2;
  }, pathArg_1;
}
var findMade_1, hasRequiredFindMade;
function requireFindMade() {
  if (hasRequiredFindMade) return findMade_1;
  hasRequiredFindMade = 1;
  const { dirname } = require$$0__default$1.default, findMade = (opts, parent, path2 = void 0) => path2 === parent ? Promise.resolve() : opts.statAsync(parent).then(
    (st) => st.isDirectory() ? path2 : void 0,
    // will fail later
    (er) => er.code === "ENOENT" ? findMade(opts, dirname(parent), parent) : void 0
  ), findMadeSync = (opts, parent, path2 = void 0) => {
    if (path2 !== parent)
      try {
        return opts.statSync(parent).isDirectory() ? path2 : void 0;
      } catch (er) {
        return er.code === "ENOENT" ? findMadeSync(opts, dirname(parent), parent) : void 0;
      }
  };
  return findMade_1 = { findMade, findMadeSync }, findMade_1;
}
var mkdirpManual_1, hasRequiredMkdirpManual;
function requireMkdirpManual() {
  if (hasRequiredMkdirpManual) return mkdirpManual_1;
  hasRequiredMkdirpManual = 1;
  const { dirname } = require$$0__default$1.default, mkdirpManual = (path2, opts, made) => {
    opts.recursive = !1;
    const parent = dirname(path2);
    return parent === path2 ? opts.mkdirAsync(path2, opts).catch((er) => {
      if (er.code !== "EISDIR")
        throw er;
    }) : opts.mkdirAsync(path2, opts).then(() => made || path2, (er) => {
      if (er.code === "ENOENT")
        return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path2, opts, made2));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      return opts.statAsync(path2).then((st) => {
        if (st.isDirectory())
          return made;
        throw er;
      }, () => {
        throw er;
      });
    });
  }, mkdirpManualSync = (path2, opts, made) => {
    const parent = dirname(path2);
    if (opts.recursive = !1, parent === path2)
      try {
        return opts.mkdirSync(path2, opts);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        return;
      }
    try {
      return opts.mkdirSync(path2, opts), made || path2;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path2, opts, mkdirpManualSync(parent, opts, made));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      try {
        if (!opts.statSync(path2).isDirectory())
          throw er;
      } catch {
        throw er;
      }
    }
  };
  return mkdirpManual_1 = { mkdirpManual, mkdirpManualSync }, mkdirpManual_1;
}
var mkdirpNative_1, hasRequiredMkdirpNative;
function requireMkdirpNative() {
  if (hasRequiredMkdirpNative) return mkdirpNative_1;
  hasRequiredMkdirpNative = 1;
  const { dirname } = require$$0__default$1.default, { findMade, findMadeSync } = requireFindMade(), { mkdirpManual, mkdirpManualSync } = requireMkdirpManual();
  return mkdirpNative_1 = { mkdirpNative: (path2, opts) => (opts.recursive = !0, dirname(path2) === path2 ? opts.mkdirAsync(path2, opts) : findMade(opts, path2).then((made) => opts.mkdirAsync(path2, opts).then(() => made).catch((er) => {
    if (er.code === "ENOENT")
      return mkdirpManual(path2, opts);
    throw er;
  }))), mkdirpNativeSync: (path2, opts) => {
    if (opts.recursive = !0, dirname(path2) === path2)
      return opts.mkdirSync(path2, opts);
    const made = findMadeSync(opts, path2);
    try {
      return opts.mkdirSync(path2, opts), made;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path2, opts);
      throw er;
    }
  } }, mkdirpNative_1;
}
var useNative_1, hasRequiredUseNative;
function requireUseNative() {
  if (hasRequiredUseNative) return useNative_1;
  hasRequiredUseNative = 1;
  const fs2 = require$$0__default.default, versArr2 = (process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version).replace(/^v/, "").split("."), hasNative2 = +versArr2[0] > 10 || +versArr2[0] == 10 && +versArr2[1] >= 12;
  return useNative_1 = { useNative: hasNative2 ? (opts) => opts.mkdir === fs2.mkdir : () => !1, useNativeSync: hasNative2 ? (opts) => opts.mkdirSync === fs2.mkdirSync : () => !1 }, useNative_1;
}
var mkdirp_1, hasRequiredMkdirp;
function requireMkdirp() {
  if (hasRequiredMkdirp) return mkdirp_1;
  hasRequiredMkdirp = 1;
  const optsArg = requireOptsArg(), pathArg2 = requirePathArg(), { mkdirpNative, mkdirpNativeSync } = requireMkdirpNative(), { mkdirpManual, mkdirpManualSync } = requireMkdirpManual(), { useNative: useNative2, useNativeSync: useNativeSync2 } = requireUseNative(), mkdirp = (path2, opts) => (path2 = pathArg2(path2), opts = optsArg(opts), useNative2(opts) ? mkdirpNative(path2, opts) : mkdirpManual(path2, opts)), mkdirpSync = (path2, opts) => (path2 = pathArg2(path2), opts = optsArg(opts), useNativeSync2(opts) ? mkdirpNativeSync(path2, opts) : mkdirpManualSync(path2, opts));
  return mkdirp.sync = mkdirpSync, mkdirp.native = (path2, opts) => mkdirpNative(pathArg2(path2), optsArg(opts)), mkdirp.manual = (path2, opts) => mkdirpManual(pathArg2(path2), optsArg(opts)), mkdirp.nativeSync = (path2, opts) => mkdirpNativeSync(pathArg2(path2), optsArg(opts)), mkdirp.manualSync = (path2, opts) => mkdirpManualSync(pathArg2(path2), optsArg(opts)), mkdirp_1 = mkdirp, mkdirp_1;
}
var chownr_1, hasRequiredChownr;
function requireChownr() {
  if (hasRequiredChownr) return chownr_1;
  hasRequiredChownr = 1;
  const fs2 = require$$0__default.default, path2 = require$$0__default$1.default, LCHOWN = fs2.lchown ? "lchown" : "chown", LCHOWNSYNC = fs2.lchownSync ? "lchownSync" : "chownSync", needEISDIRHandled = fs2.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/), lchownSync = (path3, uid, gid) => {
    try {
      return fs2[LCHOWNSYNC](path3, uid, gid);
    } catch (er) {
      if (er.code !== "ENOENT")
        throw er;
    }
  }, chownSync = (path3, uid, gid) => {
    try {
      return fs2.chownSync(path3, uid, gid);
    } catch (er) {
      if (er.code !== "ENOENT")
        throw er;
    }
  }, handleEISDIR = needEISDIRHandled ? (path3, uid, gid, cb) => (er) => {
    !er || er.code !== "EISDIR" ? cb(er) : fs2.chown(path3, uid, gid, cb);
  } : (_, __, ___, cb) => cb, handleEISDirSync = needEISDIRHandled ? (path3, uid, gid) => {
    try {
      return lchownSync(path3, uid, gid);
    } catch (er) {
      if (er.code !== "EISDIR")
        throw er;
      chownSync(path3, uid, gid);
    }
  } : (path3, uid, gid) => lchownSync(path3, uid, gid), nodeVersion = process.version;
  let readdir2 = (path3, options2, cb) => fs2.readdir(path3, options2, cb), readdirSync2 = (path3, options2) => fs2.readdirSync(path3, options2);
  /^v4\./.test(nodeVersion) && (readdir2 = (path3, options2, cb) => fs2.readdir(path3, cb));
  const chown = (cpath, uid, gid, cb) => {
    fs2[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
      cb(er && er.code !== "ENOENT" ? er : null);
    }));
  }, chownrKid = (p, child, uid, gid, cb) => {
    if (typeof child == "string")
      return fs2.lstat(path2.resolve(p, child), (er, stats) => {
        if (er)
          return cb(er.code !== "ENOENT" ? er : null);
        stats.name = child, chownrKid(p, stats, uid, gid, cb);
      });
    if (child.isDirectory())
      chownr(path2.resolve(p, child.name), uid, gid, (er) => {
        if (er)
          return cb(er);
        const cpath = path2.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      });
    else {
      const cpath = path2.resolve(p, child.name);
      chown(cpath, uid, gid, cb);
    }
  }, chownr = (p, uid, gid, cb) => {
    readdir2(p, { withFileTypes: !0 }, (er, children) => {
      if (er) {
        if (er.code === "ENOENT")
          return cb();
        if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
          return cb(er);
      }
      if (er || !children.length)
        return chown(p, uid, gid, cb);
      let len = children.length, errState = null;
      const then = (er2) => {
        if (!errState) {
          if (er2)
            return cb(errState = er2);
          if (--len === 0)
            return chown(p, uid, gid, cb);
        }
      };
      children.forEach((child) => chownrKid(p, child, uid, gid, then));
    });
  }, chownrKidSync = (p, child, uid, gid) => {
    if (typeof child == "string")
      try {
        const stats = fs2.lstatSync(path2.resolve(p, child));
        stats.name = child, child = stats;
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        throw er;
      }
    child.isDirectory() && chownrSync(path2.resolve(p, child.name), uid, gid), handleEISDirSync(path2.resolve(p, child.name), uid, gid);
  }, chownrSync = (p, uid, gid) => {
    let children;
    try {
      children = readdirSync2(p, { withFileTypes: !0 });
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
        return handleEISDirSync(p, uid, gid);
      throw er;
    }
    return children && children.length && children.forEach((child) => chownrKidSync(p, child, uid, gid)), handleEISDirSync(p, uid, gid);
  };
  return chownr_1 = chownr, chownr.sync = chownrSync, chownr_1;
}
var hasRequiredMkdir;
function requireMkdir() {
  if (hasRequiredMkdir) return mkdir.exports;
  hasRequiredMkdir = 1;
  const mkdirp = requireMkdirp(), fs2 = require$$0__default.default, path2 = require$$0__default$1.default, chownr = requireChownr(), normPath = requireNormalizeWindowsPath();
  class SymlinkError extends Error {
    constructor(symlink, path3) {
      super("Cannot extract through symbolic link"), this.path = path3, this.symlink = symlink;
    }
    get name() {
      return "SylinkError";
    }
  }
  class CwdError extends Error {
    constructor(path3, code) {
      super(code + ": Cannot cd into '" + path3 + "'"), this.path = path3, this.code = code;
    }
    get name() {
      return "CwdError";
    }
  }
  const cGet = (cache, key2) => cache.get(normPath(key2)), cSet = (cache, key2, val) => cache.set(normPath(key2), val), checkCwd = (dir, cb) => {
    fs2.stat(dir, (er, st) => {
      (er || !st.isDirectory()) && (er = new CwdError(dir, er && er.code || "ENOTDIR")), cb(er);
    });
  };
  mkdir.exports = (dir, opt, cb) => {
    dir = normPath(dir);
    const umask = opt.umask, mode2 = opt.mode | 448, needChmod = (mode2 & umask) !== 0, uid = opt.uid, gid = opt.gid, doChown = typeof uid == "number" && typeof gid == "number" && (uid !== opt.processUid || gid !== opt.processGid), preserve = opt.preserve, unlink2 = opt.unlink, cache = opt.cache, cwd = normPath(opt.cwd), done = (er, created) => {
      er ? cb(er) : (cSet(cache, dir, !0), created && doChown ? chownr(created, uid, gid, (er2) => done(er2)) : needChmod ? fs2.chmod(dir, mode2, cb) : cb());
    };
    if (cache && cGet(cache, dir) === !0)
      return done();
    if (dir === cwd)
      return checkCwd(dir, done);
    if (preserve)
      return mkdirp(dir, { mode: mode2 }).then((made) => done(null, made), done);
    const parts = normPath(path2.relative(cwd, dir)).split("/");
    mkdir_(cwd, parts, mode2, cache, unlink2, cwd, null, done);
  };
  const mkdir_ = (base2, parts, mode2, cache, unlink2, cwd, created, cb) => {
    if (!parts.length)
      return cb(null, created);
    const p = parts.shift(), part = normPath(path2.resolve(base2 + "/" + p));
    if (cGet(cache, part))
      return mkdir_(part, parts, mode2, cache, unlink2, cwd, created, cb);
    fs2.mkdir(part, mode2, onmkdir(part, parts, mode2, cache, unlink2, cwd, created, cb));
  }, onmkdir = (part, parts, mode2, cache, unlink2, cwd, created, cb) => (er) => {
    er ? fs2.lstat(part, (statEr, st) => {
      if (statEr)
        statEr.path = statEr.path && normPath(statEr.path), cb(statEr);
      else if (st.isDirectory())
        mkdir_(part, parts, mode2, cache, unlink2, cwd, created, cb);
      else if (unlink2)
        fs2.unlink(part, (er2) => {
          if (er2)
            return cb(er2);
          fs2.mkdir(part, mode2, onmkdir(part, parts, mode2, cache, unlink2, cwd, created, cb));
        });
      else {
        if (st.isSymbolicLink())
          return cb(new SymlinkError(part, part + "/" + parts.join("/")));
        cb(er);
      }
    }) : (created = created || part, mkdir_(part, parts, mode2, cache, unlink2, cwd, created, cb));
  }, checkCwdSync = (dir) => {
    let ok = !1, code = "ENOTDIR";
    try {
      ok = fs2.statSync(dir).isDirectory();
    } catch (er) {
      code = er.code;
    } finally {
      if (!ok)
        throw new CwdError(dir, code);
    }
  };
  return mkdir.exports.sync = (dir, opt) => {
    dir = normPath(dir);
    const umask = opt.umask, mode2 = opt.mode | 448, needChmod = (mode2 & umask) !== 0, uid = opt.uid, gid = opt.gid, doChown = typeof uid == "number" && typeof gid == "number" && (uid !== opt.processUid || gid !== opt.processGid), preserve = opt.preserve, unlink2 = opt.unlink, cache = opt.cache, cwd = normPath(opt.cwd), done = (created2) => {
      cSet(cache, dir, !0), created2 && doChown && chownr.sync(created2, uid, gid), needChmod && fs2.chmodSync(dir, mode2);
    };
    if (cache && cGet(cache, dir) === !0)
      return done();
    if (dir === cwd)
      return checkCwdSync(cwd), done();
    if (preserve)
      return done(mkdirp.sync(dir, mode2));
    const parts = normPath(path2.relative(cwd, dir)).split("/");
    let created = null;
    for (let p = parts.shift(), part = cwd; p && (part += "/" + p); p = parts.shift())
      if (part = normPath(path2.resolve(part)), !cGet(cache, part))
        try {
          fs2.mkdirSync(part, mode2), created = created || part, cSet(cache, part, !0);
        } catch {
          const st = fs2.lstatSync(part);
          if (st.isDirectory()) {
            cSet(cache, part, !0);
            continue;
          } else if (unlink2) {
            fs2.unlinkSync(part), fs2.mkdirSync(part, mode2), created = created || part, cSet(cache, part, !0);
            continue;
          } else if (st.isSymbolicLink())
            return new SymlinkError(part, part + "/" + parts.join("/"));
        }
    return done(created);
  }, mkdir.exports;
}
var normalizeUnicode, hasRequiredNormalizeUnicode;
function requireNormalizeUnicode() {
  if (hasRequiredNormalizeUnicode) return normalizeUnicode;
  hasRequiredNormalizeUnicode = 1;
  const normalizeCache2 = /* @__PURE__ */ Object.create(null), { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
  return normalizeUnicode = (s) => (hasOwnProperty2.call(normalizeCache2, s) || (normalizeCache2[s] = s.normalize("NFD")), normalizeCache2[s]), normalizeUnicode;
}
var pathReservations, hasRequiredPathReservations;
function requirePathReservations() {
  if (hasRequiredPathReservations) return pathReservations;
  hasRequiredPathReservations = 1;
  const assert = require$$0__default$6.default, normalize2 = requireNormalizeUnicode(), stripSlashes = requireStripTrailingSlashes(), { join } = require$$0__default$1.default, isWindows = (process.env.TESTING_TAR_FAKE_PLATFORM || process.platform) === "win32";
  return pathReservations = () => {
    const queues = /* @__PURE__ */ new Map(), reservations = /* @__PURE__ */ new Map(), getDirs = (path2) => path2.split("/").slice(0, -1).reduce((set2, path3) => (set2.length && (path3 = join(set2[set2.length - 1], path3)), set2.push(path3 || "/"), set2), []), running = /* @__PURE__ */ new Set(), getQueues = (fn) => {
      const res = reservations.get(fn);
      if (!res)
        throw new Error("function does not have any path reservations");
      return {
        paths: res.paths.map((path2) => queues.get(path2)),
        dirs: [...res.dirs].map((path2) => queues.get(path2))
      };
    }, check = (fn) => {
      const { paths, dirs } = getQueues(fn);
      return paths.every((q) => q[0] === fn) && dirs.every((q) => q[0] instanceof Set && q[0].has(fn));
    }, run = (fn) => running.has(fn) || !check(fn) ? !1 : (running.add(fn), fn(() => clear(fn)), !0), clear = (fn) => {
      if (!running.has(fn))
        return !1;
      const { paths, dirs } = reservations.get(fn), next = /* @__PURE__ */ new Set();
      return paths.forEach((path2) => {
        const q = queues.get(path2);
        assert.equal(q[0], fn), q.length === 1 ? queues.delete(path2) : (q.shift(), typeof q[0] == "function" ? next.add(q[0]) : q[0].forEach((fn2) => next.add(fn2)));
      }), dirs.forEach((dir) => {
        const q = queues.get(dir);
        assert(q[0] instanceof Set), q[0].size === 1 && q.length === 1 ? queues.delete(dir) : q[0].size === 1 ? (q.shift(), next.add(q[0])) : q[0].delete(fn);
      }), running.delete(fn), next.forEach((fn2) => run(fn2)), !0;
    };
    return { check, reserve: (paths, fn) => {
      paths = isWindows ? ["win32 parallelization disabled"] : paths.map((p) => stripSlashes(join(normalize2(p))).toLowerCase());
      const dirs = new Set(
        paths.map((path2) => getDirs(path2)).reduce((a, b) => a.concat(b))
      );
      return reservations.set(fn, { dirs, paths }), paths.forEach((path2) => {
        const q = queues.get(path2);
        q ? q.push(fn) : queues.set(path2, [fn]);
      }), dirs.forEach((dir) => {
        const q = queues.get(dir);
        q ? q[q.length - 1] instanceof Set ? q[q.length - 1].add(fn) : q.push(/* @__PURE__ */ new Set([fn])) : queues.set(dir, [/* @__PURE__ */ new Set([fn])]);
      }), run(fn);
    } };
  }, pathReservations;
}
var getWriteFlag, hasRequiredGetWriteFlag;
function requireGetWriteFlag() {
  if (hasRequiredGetWriteFlag) return getWriteFlag;
  hasRequiredGetWriteFlag = 1;
  const isWindows = (process.env.__FAKE_PLATFORM__ || process.platform) === "win32", fs2 = loadEnv.commonjsGlobal.__FAKE_TESTING_FS__ || require$$0__default.default, { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs2.constants, fMapEnabled = isWindows && !!UV_FS_O_FILEMAP, fMapLimit = 512 * 1024, fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
  return getWriteFlag = fMapEnabled ? (size) => size < fMapLimit ? fMapFlag : "w" : () => "w", getWriteFlag;
}
var unpack, hasRequiredUnpack;
function requireUnpack() {
  if (hasRequiredUnpack) return unpack;
  hasRequiredUnpack = 1;
  const assert = require$$0__default$6.default, Parser = requireParse(), fs2 = require$$0__default.default, fsm = requireFsMinipass(), path2 = require$$0__default$1.default, mkdir2 = requireMkdir(), wc = requireWinchars(), pathReservations2 = requirePathReservations(), stripAbsolutePath2 = requireStripAbsolutePath(), normPath = requireNormalizeWindowsPath(), stripSlash = requireStripTrailingSlashes(), normalize2 = requireNormalizeUnicode(), ONENTRY = Symbol("onEntry"), CHECKFS = Symbol("checkFs"), CHECKFS2 = Symbol("checkFs2"), PRUNECACHE = Symbol("pruneCache"), ISREUSABLE = Symbol("isReusable"), MAKEFS = Symbol("makeFs"), FILE = Symbol("file"), DIRECTORY = Symbol("directory"), LINK = Symbol("link"), SYMLINK = Symbol("symlink"), HARDLINK = Symbol("hardlink"), UNSUPPORTED = Symbol("unsupported"), CHECKPATH = Symbol("checkPath"), MKDIR = Symbol("mkdir"), ONERROR = Symbol("onError"), PENDING = Symbol("pending"), PEND = Symbol("pend"), UNPEND = Symbol("unpend"), ENDED = Symbol("ended"), MAYBECLOSE = Symbol("maybeClose"), SKIP = Symbol("skip"), DOCHOWN = Symbol("doChown"), UID = Symbol("uid"), GID = Symbol("gid"), CHECKED_CWD = Symbol("checkedCwd"), crypto = require$$3__default.default, getFlag = requireGetWriteFlag(), isWindows = (process.env.TESTING_TAR_FAKE_PLATFORM || process.platform) === "win32", DEFAULT_MAX_DEPTH = 1024, unlinkFile = (path3, cb) => {
    if (!isWindows)
      return fs2.unlink(path3, cb);
    const name = path3 + ".DELETE." + crypto.randomBytes(16).toString("hex");
    fs2.rename(path3, name, (er) => {
      if (er)
        return cb(er);
      fs2.unlink(name, cb);
    });
  }, unlinkFileSync = (path3) => {
    if (!isWindows)
      return fs2.unlinkSync(path3);
    const name = path3 + ".DELETE." + crypto.randomBytes(16).toString("hex");
    fs2.renameSync(path3, name), fs2.unlinkSync(name);
  }, uint32 = (a, b, c2) => a === a >>> 0 ? a : b === b >>> 0 ? b : c2, cacheKeyNormalize = (path3) => stripSlash(normPath(normalize2(path3))).toLowerCase(), pruneCache = (cache, abs) => {
    abs = cacheKeyNormalize(abs);
    for (const path3 of cache.keys()) {
      const pnorm = cacheKeyNormalize(path3);
      (pnorm === abs || pnorm.indexOf(abs + "/") === 0) && cache.delete(path3);
    }
  }, dropCache = (cache) => {
    for (const key2 of cache.keys())
      cache.delete(key2);
  };
  class Unpack extends Parser {
    constructor(opt) {
      if (opt || (opt = {}), opt.ondone = (_) => {
        this[ENDED] = !0, this[MAYBECLOSE]();
      }, super(opt), this[CHECKED_CWD] = !1, this.reservations = pathReservations2(), this.transform = typeof opt.transform == "function" ? opt.transform : null, this.writable = !0, this.readable = !1, this[PENDING] = 0, this[ENDED] = !1, this.dirCache = opt.dirCache || /* @__PURE__ */ new Map(), typeof opt.uid == "number" || typeof opt.gid == "number") {
        if (typeof opt.uid != "number" || typeof opt.gid != "number")
          throw new TypeError("cannot set owner without number uid and gid");
        if (opt.preserveOwner)
          throw new TypeError(
            "cannot preserve owner in archive and also set owner explicitly"
          );
        this.uid = opt.uid, this.gid = opt.gid, this.setOwner = !0;
      } else
        this.uid = null, this.gid = null, this.setOwner = !1;
      opt.preserveOwner === void 0 && typeof opt.uid != "number" ? this.preserveOwner = process.getuid && process.getuid() === 0 : this.preserveOwner = !!opt.preserveOwner, this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null, this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null, this.maxDepth = typeof opt.maxDepth == "number" ? opt.maxDepth : DEFAULT_MAX_DEPTH, this.forceChown = opt.forceChown === !0, this.win32 = !!opt.win32 || isWindows, this.newer = !!opt.newer, this.keep = !!opt.keep, this.noMtime = !!opt.noMtime, this.preservePaths = !!opt.preservePaths, this.unlink = !!opt.unlink, this.cwd = normPath(path2.resolve(opt.cwd || process.cwd())), this.strip = +opt.strip || 0, this.processUmask = opt.noChmod ? 0 : process.umask(), this.umask = typeof opt.umask == "number" ? opt.umask : this.processUmask, this.dmode = opt.dmode || 511 & ~this.umask, this.fmode = opt.fmode || 438 & ~this.umask, this.on("entry", (entry) => this[ONENTRY](entry));
    }
    // a bad or damaged archive is a warning for Parser, but an error
    // when extracting.  Mark those errors as unrecoverable, because
    // the Unpack contract cannot be met.
    warn(code, msg, data = {}) {
      return (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT") && (data.recoverable = !1), super.warn(code, msg, data);
    }
    [MAYBECLOSE]() {
      this[ENDED] && this[PENDING] === 0 && (this.emit("prefinish"), this.emit("finish"), this.emit("end"));
    }
    [CHECKPATH](entry) {
      const p = normPath(entry.path), parts = p.split("/");
      if (this.strip) {
        if (parts.length < this.strip)
          return !1;
        if (entry.type === "Link") {
          const linkparts = normPath(entry.linkpath).split("/");
          if (linkparts.length >= this.strip)
            entry.linkpath = linkparts.slice(this.strip).join("/");
          else
            return !1;
        }
        parts.splice(0, this.strip), entry.path = parts.join("/");
      }
      if (isFinite(this.maxDepth) && parts.length > this.maxDepth)
        return this.warn("TAR_ENTRY_ERROR", "path excessively deep", {
          entry,
          path: p,
          depth: parts.length,
          maxDepth: this.maxDepth
        }), !1;
      if (!this.preservePaths) {
        if (parts.includes("..") || isWindows && /^[a-z]:\.\.$/i.test(parts[0]))
          return this.warn("TAR_ENTRY_ERROR", "path contains '..'", {
            entry,
            path: p
          }), !1;
        const [root2, stripped] = stripAbsolutePath2(p);
        root2 && (entry.path = stripped, this.warn("TAR_ENTRY_INFO", `stripping ${root2} from absolute path`, {
          entry,
          path: p
        }));
      }
      if (path2.isAbsolute(entry.path) ? entry.absolute = normPath(path2.resolve(entry.path)) : entry.absolute = normPath(path2.resolve(this.cwd, entry.path)), !this.preservePaths && entry.absolute.indexOf(this.cwd + "/") !== 0 && entry.absolute !== this.cwd)
        return this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", {
          entry,
          path: normPath(entry.path),
          resolvedPath: entry.absolute,
          cwd: this.cwd
        }), !1;
      if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir")
        return !1;
      if (this.win32) {
        const { root: aRoot } = path2.win32.parse(entry.absolute);
        entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length));
        const { root: pRoot } = path2.win32.parse(entry.path);
        entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));
      }
      return !0;
    }
    [ONENTRY](entry) {
      if (!this[CHECKPATH](entry))
        return entry.resume();
      switch (assert.equal(typeof entry.absolute, "string"), entry.type) {
        case "Directory":
        case "GNUDumpDir":
          entry.mode && (entry.mode = entry.mode | 448);
        // eslint-disable-next-line no-fallthrough
        case "File":
        case "OldFile":
        case "ContiguousFile":
        case "Link":
        case "SymbolicLink":
          return this[CHECKFS](entry);
        case "CharacterDevice":
        case "BlockDevice":
        case "FIFO":
        default:
          return this[UNSUPPORTED](entry);
      }
    }
    [ONERROR](er, entry) {
      er.name === "CwdError" ? this.emit("error", er) : (this.warn("TAR_ENTRY_ERROR", er, { entry }), this[UNPEND](), entry.resume());
    }
    [MKDIR](dir, mode2, cb) {
      mkdir2(normPath(dir), {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode: mode2,
        noChmod: this.noChmod
      }, cb);
    }
    [DOCHOWN](entry) {
      return this.forceChown || this.preserveOwner && (typeof entry.uid == "number" && entry.uid !== this.processUid || typeof entry.gid == "number" && entry.gid !== this.processGid) || typeof this.uid == "number" && this.uid !== this.processUid || typeof this.gid == "number" && this.gid !== this.processGid;
    }
    [UID](entry) {
      return uint32(this.uid, entry.uid, this.processUid);
    }
    [GID](entry) {
      return uint32(this.gid, entry.gid, this.processGid);
    }
    [FILE](entry, fullyDone) {
      const mode2 = entry.mode & 4095 || this.fmode, stream2 = new fsm.WriteStream(entry.absolute, {
        flags: getFlag(entry.size),
        mode: mode2,
        autoClose: !1
      });
      stream2.on("error", (er) => {
        stream2.fd && fs2.close(stream2.fd, () => {
        }), stream2.write = () => !0, this[ONERROR](er, entry), fullyDone();
      });
      let actions = 1;
      const done = (er) => {
        if (er) {
          stream2.fd && fs2.close(stream2.fd, () => {
          }), this[ONERROR](er, entry), fullyDone();
          return;
        }
        --actions === 0 && fs2.close(stream2.fd, (er2) => {
          er2 ? this[ONERROR](er2, entry) : this[UNPEND](), fullyDone();
        });
      };
      stream2.on("finish", (_) => {
        const abs = entry.absolute, fd = stream2.fd;
        if (entry.mtime && !this.noMtime) {
          actions++;
          const atime = entry.atime || /* @__PURE__ */ new Date(), mtime = entry.mtime;
          fs2.futimes(fd, atime, mtime, (er) => er ? fs2.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
        }
        if (this[DOCHOWN](entry)) {
          actions++;
          const uid = this[UID](entry), gid = this[GID](entry);
          fs2.fchown(fd, uid, gid, (er) => er ? fs2.chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
        }
        done();
      });
      const tx = this.transform && this.transform(entry) || entry;
      tx !== entry && (tx.on("error", (er) => {
        this[ONERROR](er, entry), fullyDone();
      }), entry.pipe(tx)), tx.pipe(stream2);
    }
    [DIRECTORY](entry, fullyDone) {
      const mode2 = entry.mode & 4095 || this.dmode;
      this[MKDIR](entry.absolute, mode2, (er) => {
        if (er) {
          this[ONERROR](er, entry), fullyDone();
          return;
        }
        let actions = 1;
        const done = (_) => {
          --actions === 0 && (fullyDone(), this[UNPEND](), entry.resume());
        };
        entry.mtime && !this.noMtime && (actions++, fs2.utimes(entry.absolute, entry.atime || /* @__PURE__ */ new Date(), entry.mtime, done)), this[DOCHOWN](entry) && (actions++, fs2.chown(entry.absolute, this[UID](entry), this[GID](entry), done)), done();
      });
    }
    [UNSUPPORTED](entry) {
      entry.unsupported = !0, this.warn(
        "TAR_ENTRY_UNSUPPORTED",
        `unsupported entry type: ${entry.type}`,
        { entry }
      ), entry.resume();
    }
    [SYMLINK](entry, done) {
      this[LINK](entry, entry.linkpath, "symlink", done);
    }
    [HARDLINK](entry, done) {
      const linkpath = normPath(path2.resolve(this.cwd, entry.linkpath));
      this[LINK](entry, linkpath, "link", done);
    }
    [PEND]() {
      this[PENDING]++;
    }
    [UNPEND]() {
      this[PENDING]--, this[MAYBECLOSE]();
    }
    [SKIP](entry) {
      this[UNPEND](), entry.resume();
    }
    // Check if we can reuse an existing filesystem entry safely and
    // overwrite it, rather than unlinking and recreating
    // Windows doesn't report a useful nlink, so we just never reuse entries
    [ISREUSABLE](entry, st) {
      return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows;
    }
    // check if a thing is there, and if so, try to clobber it
    [CHECKFS](entry) {
      this[PEND]();
      const paths = [entry.path];
      entry.linkpath && paths.push(entry.linkpath), this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
    }
    [PRUNECACHE](entry) {
      entry.type === "SymbolicLink" ? dropCache(this.dirCache) : entry.type !== "Directory" && pruneCache(this.dirCache, entry.absolute);
    }
    [CHECKFS2](entry, fullyDone) {
      this[PRUNECACHE](entry);
      const done = (er) => {
        this[PRUNECACHE](entry), fullyDone(er);
      }, checkCwd = () => {
        this[MKDIR](this.cwd, this.dmode, (er) => {
          if (er) {
            this[ONERROR](er, entry), done();
            return;
          }
          this[CHECKED_CWD] = !0, start();
        });
      }, start = () => {
        if (entry.absolute !== this.cwd) {
          const parent = normPath(path2.dirname(entry.absolute));
          if (parent !== this.cwd)
            return this[MKDIR](parent, this.dmode, (er) => {
              if (er) {
                this[ONERROR](er, entry), done();
                return;
              }
              afterMakeParent();
            });
        }
        afterMakeParent();
      }, afterMakeParent = () => {
        fs2.lstat(entry.absolute, (lstatEr, st) => {
          if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
            this[SKIP](entry), done();
            return;
          }
          if (lstatEr || this[ISREUSABLE](entry, st))
            return this[MAKEFS](null, entry, done);
          if (st.isDirectory()) {
            if (entry.type === "Directory") {
              const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode, afterChmod = (er) => this[MAKEFS](er, entry, done);
              return needChmod ? fs2.chmod(entry.absolute, entry.mode, afterChmod) : afterChmod();
            }
            if (entry.absolute !== this.cwd)
              return fs2.rmdir(entry.absolute, (er) => this[MAKEFS](er, entry, done));
          }
          if (entry.absolute === this.cwd)
            return this[MAKEFS](null, entry, done);
          unlinkFile(entry.absolute, (er) => this[MAKEFS](er, entry, done));
        });
      };
      this[CHECKED_CWD] ? start() : checkCwd();
    }
    [MAKEFS](er, entry, done) {
      if (er) {
        this[ONERROR](er, entry), done();
        return;
      }
      switch (entry.type) {
        case "File":
        case "OldFile":
        case "ContiguousFile":
          return this[FILE](entry, done);
        case "Link":
          return this[HARDLINK](entry, done);
        case "SymbolicLink":
          return this[SYMLINK](entry, done);
        case "Directory":
        case "GNUDumpDir":
          return this[DIRECTORY](entry, done);
      }
    }
    [LINK](entry, linkpath, link, done) {
      fs2[link](linkpath, entry.absolute, (er) => {
        er ? this[ONERROR](er, entry) : (this[UNPEND](), entry.resume()), done();
      });
    }
  }
  const callSync = (fn) => {
    try {
      return [null, fn()];
    } catch (er) {
      return [er, null];
    }
  };
  class UnpackSync extends Unpack {
    [MAKEFS](er, entry) {
      return super[MAKEFS](er, entry, () => {
      });
    }
    [CHECKFS](entry) {
      if (this[PRUNECACHE](entry), !this[CHECKED_CWD]) {
        const er2 = this[MKDIR](this.cwd, this.dmode);
        if (er2)
          return this[ONERROR](er2, entry);
        this[CHECKED_CWD] = !0;
      }
      if (entry.absolute !== this.cwd) {
        const parent = normPath(path2.dirname(entry.absolute));
        if (parent !== this.cwd) {
          const mkParent = this[MKDIR](parent, this.dmode);
          if (mkParent)
            return this[ONERROR](mkParent, entry);
        }
      }
      const [lstatEr, st] = callSync(() => fs2.lstatSync(entry.absolute));
      if (st && (this.keep || this.newer && st.mtime > entry.mtime))
        return this[SKIP](entry);
      if (lstatEr || this[ISREUSABLE](entry, st))
        return this[MAKEFS](null, entry);
      if (st.isDirectory()) {
        if (entry.type === "Directory") {
          const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode, [er3] = needChmod ? callSync(() => {
            fs2.chmodSync(entry.absolute, entry.mode);
          }) : [];
          return this[MAKEFS](er3, entry);
        }
        const [er2] = callSync(() => fs2.rmdirSync(entry.absolute));
        this[MAKEFS](er2, entry);
      }
      const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));
      this[MAKEFS](er, entry);
    }
    [FILE](entry, done) {
      const mode2 = entry.mode & 4095 || this.fmode, oner = (er) => {
        let closeError;
        try {
          fs2.closeSync(fd);
        } catch (e) {
          closeError = e;
        }
        (er || closeError) && this[ONERROR](er || closeError, entry), done();
      };
      let fd;
      try {
        fd = fs2.openSync(entry.absolute, getFlag(entry.size), mode2);
      } catch (er) {
        return oner(er);
      }
      const tx = this.transform && this.transform(entry) || entry;
      tx !== entry && (tx.on("error", (er) => this[ONERROR](er, entry)), entry.pipe(tx)), tx.on("data", (chunk) => {
        try {
          fs2.writeSync(fd, chunk, 0, chunk.length);
        } catch (er) {
          oner(er);
        }
      }), tx.on("end", (_) => {
        let er = null;
        if (entry.mtime && !this.noMtime) {
          const atime = entry.atime || /* @__PURE__ */ new Date(), mtime = entry.mtime;
          try {
            fs2.futimesSync(fd, atime, mtime);
          } catch (futimeser) {
            try {
              fs2.utimesSync(entry.absolute, atime, mtime);
            } catch {
              er = futimeser;
            }
          }
        }
        if (this[DOCHOWN](entry)) {
          const uid = this[UID](entry), gid = this[GID](entry);
          try {
            fs2.fchownSync(fd, uid, gid);
          } catch (fchowner) {
            try {
              fs2.chownSync(entry.absolute, uid, gid);
            } catch {
              er = er || fchowner;
            }
          }
        }
        oner(er);
      });
    }
    [DIRECTORY](entry, done) {
      const mode2 = entry.mode & 4095 || this.dmode, er = this[MKDIR](entry.absolute, mode2);
      if (er) {
        this[ONERROR](er, entry), done();
        return;
      }
      if (entry.mtime && !this.noMtime)
        try {
          fs2.utimesSync(entry.absolute, entry.atime || /* @__PURE__ */ new Date(), entry.mtime);
        } catch {
        }
      if (this[DOCHOWN](entry))
        try {
          fs2.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
        } catch {
        }
      done(), entry.resume();
    }
    [MKDIR](dir, mode2) {
      try {
        return mkdir2.sync(normPath(dir), {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode: mode2
        });
      } catch (er) {
        return er;
      }
    }
    [LINK](entry, linkpath, link, done) {
      try {
        fs2[link + "Sync"](linkpath, entry.absolute), done(), entry.resume();
      } catch (er) {
        return this[ONERROR](er, entry);
      }
    }
  }
  return Unpack.Sync = UnpackSync, unpack = Unpack, unpack;
}
var extract_1, hasRequiredExtract;
function requireExtract() {
  if (hasRequiredExtract) return extract_1;
  hasRequiredExtract = 1;
  const hlo = requireHighLevelOpt(), Unpack = requireUnpack(), fs2 = require$$0__default.default, fsm = requireFsMinipass(), path2 = require$$0__default$1.default, stripSlash = requireStripTrailingSlashes();
  extract_1 = (opt_, files, cb) => {
    typeof opt_ == "function" ? (cb = opt_, files = null, opt_ = {}) : Array.isArray(opt_) && (files = opt_, opt_ = {}), typeof files == "function" && (cb = files, files = null), files ? files = Array.from(files) : files = [];
    const opt = hlo(opt_);
    if (opt.sync && typeof cb == "function")
      throw new TypeError("callback not supported for sync tar functions");
    if (!opt.file && typeof cb == "function")
      throw new TypeError("callback only supported with file option");
    return files.length && filesFilter(opt, files), opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);
  };
  const filesFilter = (opt, files) => {
    const map2 = new Map(files.map((f) => [stripSlash(f), !0])), filter2 = opt.filter, mapHas = (file, r) => {
      const root2 = r || path2.parse(file).root || ".", ret = file === root2 ? !1 : map2.has(file) ? map2.get(file) : mapHas(path2.dirname(file), root2);
      return map2.set(file, ret), ret;
    };
    opt.filter = filter2 ? (file, entry) => filter2(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
  }, extractFileSync = (opt) => {
    const u = new Unpack.Sync(opt), file = opt.file, stat2 = fs2.statSync(file), readSize = opt.maxReadSize || 16 * 1024 * 1024;
    new fsm.ReadStreamSync(file, {
      readSize,
      size: stat2.size
    }).pipe(u);
  }, extractFile = (opt, cb) => {
    const u = new Unpack(opt), readSize = opt.maxReadSize || 16 * 1024 * 1024, file = opt.file, p = new Promise((resolve, reject) => {
      u.on("error", reject), u.on("close", resolve), fs2.stat(file, (er, stat2) => {
        if (er)
          reject(er);
        else {
          const stream2 = new fsm.ReadStream(file, {
            readSize,
            size: stat2.size
          });
          stream2.on("error", reject), stream2.pipe(u);
        }
      });
    });
    return cb ? p.then(cb, cb) : p;
  }, extractSync = (opt) => new Unpack.Sync(opt), extract = (opt) => new Unpack(opt);
  return extract_1;
}
var hasRequiredTar;
function requireTar() {
  return hasRequiredTar || (hasRequiredTar = 1, tar.c = tar.create = requireCreate(), tar.r = tar.replace = requireReplace(), tar.t = tar.list = requireList$1(), tar.u = tar.update = requireUpdate(), tar.x = tar.extract = requireExtract(), tar.Pack = requirePack(), tar.Unpack = requireUnpack(), tar.Parse = requireParse(), tar.ReadEntry = requireReadEntry(), tar.WriteEntry = requireWriteEntry(), tar.Header = requireHeader(), tar.Pax = requirePax(), tar.types = requireTypes$1()), tar;
}
var tarExports = requireTar();
const DISALLOWED_PATHS = [
  // Prevent security risks from unknown GitHub Actions
  "/.github/"
], ENV_VAR = {
  ...templateValidator.REQUIRED_ENV_VAR,
  READ_TOKEN: "SANITY_API_READ_TOKEN",
  WRITE_TOKEN: "SANITY_API_WRITE_TOKEN"
}, API_READ_TOKEN_ROLE = "viewer", API_WRITE_TOKEN_ROLE = "editor";
function getGitHubRawContentUrl(repoInfo) {
  const { username, name, branch, filePath } = repoInfo;
  return `https://raw.githubusercontent.com/${username}/${name}/${branch}/${filePath}`;
}
function isGithubRepoShorthand(value) {
  return URL.canParse(value) ? !1 : /^[\w-]+\/[\w-.]+(\/[@\w-.]+)*$/.test(value);
}
function isGithubRepoUrl(value) {
  if (URL.canParse(value) === !1)
    return !1;
  const url = new URL(value), pathSegments = url.pathname.slice(1).split("/");
  return url.protocol === "https:" && url.hostname === "github.com" && // The pathname must have at least 2 segments. If it has more than 2, the
  // third must be "tree" and it must have at least 4 segments.
  // https://github.com/:owner/:repo
  // https://github.com/:owner/:repo/tree/:ref
  pathSegments.length >= 2 && (pathSegments.length > 2 ? pathSegments[2] === "tree" && pathSegments.length >= 4 : !0);
}
async function downloadTarStream(url, bearerToken) {
  const headers = {};
  bearerToken && (headers.Authorization = `Bearer ${bearerToken}`);
  const res = await fetch(url, { headers });
  if (!res.body)
    throw new Error(`Failed to download: ${url}`);
  return Stream.Readable.fromWeb(res.body);
}
function checkIsRemoteTemplate(templateName) {
  return templateName?.includes("/") ?? !1;
}
async function getGitHubRepoInfo(value, bearerToken) {
  let username = "", name = "", branch = "", filePath = "";
  if (isGithubRepoShorthand(value)) {
    const parts = value.split("/");
    username = parts[0], name = parts[1], parts.length > 2 && (filePath = parts.slice(2).join("/"));
  }
  if (isGithubRepoUrl(value)) {
    const pathSegments = new URL(value).pathname.slice(1).split("/");
    username = pathSegments[0], name = pathSegments[1], pathSegments[2] === "tree" && (branch = pathSegments[3], pathSegments.length > 4 && (filePath = pathSegments.slice(4).join("/")));
  }
  if (!username || !name)
    throw new Error("Invalid GitHub repository format");
  const tokenMessage = `GitHub repository not found. For private repositories, use --template-token to provide an access token.

You can generate a new token at https://github.com/settings/personal-access-tokens/new
Set the token to "read-only" with repository access and a short expiry (e.g. 7 days) for security.`;
  try {
    const headers = {};
    bearerToken && (headers.Authorization = `Bearer ${bearerToken}`);
    const infoResponse = await fetch(`https://api.github.com/repos/${username}/${name}`, {
      headers
    });
    if (infoResponse.status !== 200)
      throw infoResponse.status === 404 ? new Error(tokenMessage) : new Error("GitHub repository not found");
    const info = await infoResponse.json();
    return {
      username,
      name,
      branch: branch || info.default_branch,
      filePath
    };
  } catch {
    throw new Error(tokenMessage);
  }
}
async function downloadAndExtractRepo(root2, { username, name, branch, filePath }, bearerToken) {
  let rootPath = null;
  await promises$1.pipeline(
    await downloadTarStream(
      `https://codeload.github.com/${username}/${name}/tar.gz/${branch}`,
      bearerToken
    ),
    tarExports.x({
      cwd: root2,
      strip: filePath ? filePath.split("/").length + 1 : 1,
      filter: (p) => {
        const posixPath = p.split(path$3.sep).join(path$3.posix.sep);
        if (rootPath === null) {
          const pathSegments = posixPath.split(path$3.posix.sep);
          rootPath = pathSegments.length ? pathSegments[0] : null;
        }
        for (const disallowedPath of DISALLOWED_PATHS)
          if (posixPath.includes(disallowedPath)) return !1;
        return posixPath.startsWith(`${rootPath}${filePath ? `/${filePath}/` : "/"}`);
      }
    })
  );
}
async function checkIfNeedsApiToken(root2, type2) {
  try {
    const templatePath = await Promise.any(
      templateValidator.ENV_TEMPLATE_FILES.map(async (file) => (await fs.access(path$3.join(root2, file)), file))
    );
    return (await fs.readFile(path$3.join(root2, templatePath), "utf8")).includes(type2 === "read" ? ENV_VAR.READ_TOKEN : ENV_VAR.WRITE_TOKEN);
  } catch {
    return !1;
  }
}
async function applyEnvVariables(root2, envData, targetName = ".env") {
  const templatePath = await Promise.any(
    templateValidator.ENV_TEMPLATE_FILES.map(async (file) => (await fs.access(path$3.join(root2, file)), file))
  ).catch(() => {
  });
  if (templatePath)
    try {
      const templateContent = await fs.readFile(path$3.join(root2, templatePath), "utf8"), { projectId, dataset, readToken = "", writeToken = "" } = envData, findAndReplaceVariable = (content, varRegex, value, useQuotes2) => {
        const varPattern = typeof varRegex == "string" ? varRegex : varRegex.source, pattern = new RegExp(`.*${varPattern}=.*$`, "gm"), matches = content.matchAll(pattern);
        return Array.from(matches).reduce((updatedContent, match2) => {
          if (!match2[0]) return updatedContent;
          const varName = match2[0].split("=")[0].trim();
          return updatedContent.replace(
            new RegExp(`${varName}=.*$`, "gm"),
            `${varName}=${useQuotes2 ? `"${value}"` : value}`
          );
        }, content);
      };
      let envContent = templateContent;
      const vars = [
        { pattern: ENV_VAR.PROJECT_ID, value: projectId },
        { pattern: ENV_VAR.DATASET, value: dataset },
        { pattern: ENV_VAR.READ_TOKEN, value: readToken },
        { pattern: ENV_VAR.WRITE_TOKEN, value: writeToken }
      ], useQuotes = templateContent.includes('="');
      for (const { pattern, value } of vars)
        envContent = findAndReplaceVariable(envContent, pattern, value, useQuotes);
      await fs.writeFile(path$3.join(root2, targetName), envContent);
    } catch {
      throw new Error(
        "Failed to set environment variables. This could be due to file permissions or the .env file format. See https://www.sanity.io/docs/environment-variables for details on environment variable setup."
      );
    }
}
async function tryApplyPackageName(root2, name) {
  try {
    const packageJson = await fs.readFile(path$3.join(root2, "package.json"), "utf8"), pkg = JSON.parse(packageJson);
    pkg.name = name, await fs.writeFile(path$3.join(root2, "package.json"), JSON.stringify(pkg, null, 2));
  } catch {
  }
}
async function generateSanityApiToken(label, type2, projectId, apiClient) {
  return (await apiClient({ requireProject: !1, requireUser: !0 }).config({ apiVersion: "v2021-06-07" }).request({
    uri: `/projects/${projectId}/tokens`,
    method: "POST",
    body: {
      label: `${label} (${Date.now()})`,
      roleName: type2 === "read" ? API_READ_TOKEN_ROLE : API_WRITE_TOKEN_ROLE
    }
  })).key;
}
async function setCorsOrigin(origin, projectId, apiClient) {
  try {
    await apiClient({ api: { projectId } }).request({
      method: "POST",
      url: "/cors",
      body: { origin, allowCredentials: !0 }
      // allowCredentials is true to allow for embedded studios if needed
    });
  } catch (error2) {
    loadEnv.debug("Failed to set CORS origin", error2);
  }
}
function canLaunchBrowser() {
  return ["win32", "darwin"].includes(os__default.default.platform()) ? !0 : !!(process.env.XDG_CURRENT_DESKTOP || process.env.GDMSESSION);
}
function createExpiringConfig({
  key: key2,
  ttl,
  store,
  fetchValue,
  onRevalidate = () => null,
  onFetch = () => null,
  onCacheHit = () => null
}) {
  let currentFetch = null;
  return {
    async get() {
      const { value, updatedAt } = store.get(key2) ?? {};
      if (value && updatedAt) {
        if (!(Date.now() - updatedAt > ttl))
          return onCacheHit(), value;
        onRevalidate();
      }
      if (currentFetch)
        return currentFetch;
      onFetch(), currentFetch = Promise.resolve(fetchValue());
      const nextValue = await currentFetch;
      return currentFetch = null, store.set(key2, {
        value: nextValue,
        updatedAt: Date.now()
      }), nextValue;
    },
    delete() {
      store.delete(key2);
    }
  };
}
function isTrueish(value) {
  if (value === void 0) return !1;
  if (value.toLowerCase() === "true") return !0;
  if (value.toLowerCase() === "false") return !1;
  const number2 = parseInt(value, 10);
  return isNaN(number2) ? !1 : number2 > 0;
}
const isCi = isTrueish(process.env.CI) || // Travis CI, CircleCI, Gitlab CI, Appveyor, CodeShip
isTrueish(process.env.CONTINUOUS_INTEGRATION) || // Travis CI
process.env.BUILD_NUMBER, debug$1 = loadEnv.debug.extend("telemetry"), FIVE_MINUTES = 1e3 * 60 * 5, LOG_FILE_NAME = "telemetry-events.ndjson", TELEMETRY_CONSENT_CONFIG_KEY = "telemetryConsent", VALID_API_STATUSES = ["granted", "denied", "unset"];
function isValidApiConsentStatus(status) {
  return VALID_API_STATUSES.includes(status);
}
function parseApiConsentStatus(value) {
  if (typeof value == "string" && isValidApiConsentStatus(value))
    return value;
  throw new Error(`Invalid consent status. Must be one of: ${VALID_API_STATUSES.join(", ")}`);
}
function createTelemetryClient(token2) {
  return getClientWrapper(null, "sanity.cli.js")({ requireUser: !1, requireProject: !1 }).config({
    apiVersion: "2023-12-18",
    token: token2,
    useCdn: !1,
    useProjectHostname: !1
  });
}
let _client = null;
function getCachedClient(token2) {
  return _client || (_client = createTelemetryClient(token2)), _client;
}
function resolveConsent({ env }) {
  if (debug$1("Resolving consent\u2026"), isCi)
    return debug$1("CI environment detected, treating telemetry consent as denied"), Promise.resolve({ status: "denied" });
  if (isTrueish(env.DO_NOT_TRACK))
    return debug$1("DO_NOT_TRACK is set, consent is denied"), Promise.resolve({
      status: "denied",
      reason: "localOverride"
    });
  const token2 = getCliToken();
  if (!token2)
    return debug$1("User is not logged in, consent is undetermined"), Promise.resolve({
      status: "undetermined",
      reason: "unauthenticated"
    });
  const client2 = getCachedClient(token2);
  function fetchConsent() {
    return createExpiringConfig({
      store: getUserConfig(),
      key: TELEMETRY_CONSENT_CONFIG_KEY,
      ttl: FIVE_MINUTES,
      fetchValue: () => client2.request({ uri: "/intake/telemetry-status", tag: "telemetry-consent.cli" }),
      onRevalidate() {
        debug$1("Revalidating cached telemetry consent status...");
      },
      onFetch() {
        debug$1("Fetching telemetry consent status...");
      },
      onCacheHit() {
        debug$1("Retrieved telemetry consent status from cache");
      }
    }).get();
  }
  return fetchConsent().then((response) => (debug$1("User consent status is %s", response.status), { status: parseApiConsentStatus(response.status) })).catch((err) => (debug$1('Failed to fetch user consent status, treating it as "undetermined": %s', err.stack), {
    status: "undetermined",
    reason: "fetchError"
  }));
}
function createTelemetryStore({
  env,
  projectId
}) {
  debug$1("Initializing telemetry");
  async function sendEvents(batch) {
    const token2 = getCliToken();
    if (!token2)
      return debug$1("No user token found. Something is not quite right"), Promise.reject(new Error("User is not logged in"));
    isTrueish(env.SANITY_TELEMETRY_INSPECT) && (console.info(`SANITY_TELEMETRY_INSPECT is set, appending events to "${LOG_FILE_NAME}"`), await fs.appendFile(LOG_FILE_NAME, `${batch.map((entry) => JSON.stringify(entry)).join(`
`)}
`));
    const client2 = getCachedClient(token2);
    debug$1("Submitting %s telemetry events", batch.length);
    try {
      return await client2.request({
        uri: "/intake/batch",
        method: "POST",
        json: !0,
        body: { projectId, batch }
      });
    } catch (err) {
      const statusCode = err.response && err.response.statusCode;
      throw debug$1(
        "Failed to send telemetry events%s: %s",
        statusCode ? ` (HTTP ${statusCode})` : "",
        err.stack
      ), err;
    }
  }
  const sessionId = telemetry.createSessionId();
  debug$1("session id: %s", sessionId);
  const store = telemetry.createBatchedStore(sessionId, {
    resolveConsent: () => resolveConsent({ env }),
    sendEvents
  });
  return process.once("SIGINT", () => store.flush().finally(() => process.exit(0))), process.once("beforeExit", () => store.flush()), process.once("unhandledRejection", () => store.flush()), process.once("uncaughtException", () => store.flush()), store;
}
const LoginTrace = telemetry.defineTrace({
  name: "CLI Login Step Completed",
  version: 1,
  description: "User completed a step in the CLI login flow"
}), callbackEndpoint = "/callback", debug = loadEnv.debug.extend("auth"), callbackPorts = [4321, 4e3, 3003, 1234, 8080, 13333], platformNames = {
  aix: "AIX",
  android: "Android",
  darwin: "MacOS",
  freebsd: "FreeBSD",
  linux: "Linux",
  openbsd: "OpenBSD",
  sunos: "SunOS",
  win32: "Windows"
};
async function login(args, context) {
  const { prompt: prompt2, output, apiClient, telemetry: telemetry2 } = context, { sso, experimental, open: openFlag, provider: specifiedProvider } = args.extOptions, previousToken = getCliToken(), hasExistingToken = !!previousToken, trace = telemetry2.trace(LoginTrace);
  trace.start();
  const client2 = apiClient({ requireUser: !1, requireProject: !1 }).clone().config({ token: void 0 }), provider = await getProvider({ client: client2, sso, experimental, output, prompt: prompt2, specifiedProvider });
  if (trace.log({ step: "selectProvider", provider: provider?.name }), provider === void 0)
    throw new Error("No authentication providers found");
  const apiHost = client2.config().apiHost || "https://api.sanity.io", { server, token: tokenPromise } = await startServerForTokenCallback({ apiHost, apiClient });
  trace.log({ step: "waitForToken" });
  const serverUrl = server.address();
  if (!serverUrl || typeof serverUrl == "string")
    throw new Error("Failed to start auth callback server");
  const loginUrl = new URL(provider.url), platformName = os__default.default.platform(), platform2 = platformName in platformNames ? platformNames[platformName] : platformName, hostname = os__default.default.hostname().replace(/\.(local|lan)$/g, "");
  loginUrl.searchParams.set("type", "token"), loginUrl.searchParams.set("label", `${hostname} / ${platform2}`), loginUrl.searchParams.set("origin", `http://localhost:${serverUrl.port}${callbackEndpoint}`);
  const shouldLaunchBrowser = canLaunchBrowser() && openFlag !== !1, actionText = shouldLaunchBrowser ? "Opening browser at" : "Please open a browser at";
  output.print(`
${actionText} ${loginUrl.href}
`);
  const spin = output.spinner("Waiting for browser login to complete... Press Ctrl + C to cancel").start();
  shouldLaunchBrowser && open(loginUrl.href);
  let authToken;
  try {
    authToken = (await tokenPromise).token, spin.stop();
  } catch (err) {
    throw spin.stop(), trace.error(err), err.message = `Login failed: ${err.message}`, err;
  } finally {
    server.close(), server.unref();
  }
  getUserConfig().set({
    authToken,
    authType: "normal"
  }), getUserConfig().delete(TELEMETRY_CONSENT_CONFIG_KEY), hasExistingToken && await apiClient({ requireUser: !0, requireProject: !1 }).clone().config({ token: previousToken }).request({ uri: "/auth/logout", method: "POST" }).catch((err) => {
    (err && err.response && err.response.statusCode) !== 401 && output.warn("[warn] Failed to log out existing session");
  }), output.success("Login successful"), trace.complete();
}
function startServerForTokenCallback(options2) {
  const { apiHost, apiClient } = options2, domain = apiHost.includes(".sanity.work") ? "www.sanity.work" : "www.sanity.io", attemptPorts = callbackPorts.slice();
  let callbackPort = attemptPorts.shift(), resolveToken, rejectToken;
  const tokenPromise = new Promise((resolve, reject) => {
    resolveToken = resolve, rejectToken = reject;
  });
  return new Promise((resolve, reject) => {
    const server = http__default.default.createServer(async function(req, res) {
      function failLoginRequest(code = "") {
        res.writeHead(303, "See Other", {
          Location: `https://${domain}/login/error${code ? `?error=${code}` : ""}`
        }), res.end(), server.close();
      }
      const url = new URL(req.url || "/", `http://localhost:${callbackPort}`);
      if (url.pathname !== callbackEndpoint) {
        res.writeHead(404, "Not Found", { "Content-Type": "text/plain" }), res.write("404 Not Found"), res.end();
        return;
      }
      const absoluteTokenUrl = url.searchParams.get("url");
      if (!absoluteTokenUrl) {
        failLoginRequest();
        return;
      }
      const tokenUrl = new URL(absoluteTokenUrl);
      if (!tokenUrl.searchParams.has("sid")) {
        failLoginRequest("NO_SESSION_ID");
        return;
      }
      let token2;
      try {
        token2 = await apiClient({ requireUser: !1, requireProject: !1 }).clone().request({ uri: `/auth/fetch${tokenUrl.search}` });
      } catch (err) {
        failLoginRequest("UNRESOLVED_SESSION"), rejectToken(err);
        return;
      }
      res.writeHead(303, "See Other", { Location: `https://${domain}/login/success` }), res.end(), server.close(), resolveToken(token2);
    });
    server.on("listening", function() {
      resolve({ token: tokenPromise, server });
    }), server.on("error", function(err) {
      if ("code" in err && err.code === "EADDRINUSE") {
        if (callbackPort = attemptPorts.shift(), !callbackPort) {
          reject(new Error("Failed to find port number to bind auth callback server to"));
          return;
        }
        debug("Port busy, trying %d", callbackPort), server.listen(callbackPort);
      } else
        reject(err);
    }), debug("Starting callback server on port %d", callbackPort), server.listen(callbackPort);
  });
}
async function getProvider({
  output,
  client: client2,
  sso,
  experimental,
  prompt: prompt2,
  specifiedProvider
}) {
  if (sso)
    return getSSOProvider({ client: client2, prompt: prompt2, slug: sso });
  const spin = output.spinner("Fetching providers...").start();
  let { providers } = await client2.request({ uri: "/auth/providers" });
  experimental && (providers = [...providers, { name: "sso", title: "SSO", url: "_not_used_" }]), spin.stop();
  const providerNames = providers.map((prov) => prov.name);
  if (specifiedProvider && providerNames.includes(specifiedProvider)) {
    const provider2 = providers.find((prov) => prov.name === specifiedProvider);
    if (!provider2)
      throw new Error(`Cannot find login provider with name "${specifiedProvider}"`);
    return provider2;
  }
  const provider = await promptProviders(prompt2, providers);
  if (provider.name === "sso") {
    const slug = await prompt2.single({
      type: "input",
      message: "Organization slug:"
    });
    return getSSOProvider({ client: client2, prompt: prompt2, slug });
  }
  return provider;
}
async function getSSOProvider({
  client: client2,
  prompt: prompt2,
  slug
}) {
  const enabledProviders = (await client2.withConfig({ apiVersion: "2021-10-01" }).request({
    uri: `/auth/organizations/by-slug/${slug}/providers`
  })).filter((candidate) => !candidate.disabled);
  if (enabledProviders.length === 0)
    return;
  if (enabledProviders.length === 1)
    return samlProviderToLoginProvider(enabledProviders[0]);
  const choice2 = await prompt2.single({
    type: "list",
    message: "Select SSO provider",
    choices: enabledProviders.map((provider) => provider.name)
  }), foundProvider = enabledProviders.find((provider) => provider.name === choice2);
  return foundProvider ? samlProviderToLoginProvider(foundProvider) : void 0;
}
async function promptProviders(prompt2, providers) {
  if (providers.length === 1)
    return providers[0];
  const provider = await prompt2.single({
    type: "list",
    message: "Please log in or create a new account",
    choices: providers.map((choice2) => choice2.title)
  });
  return providers.find((prov) => prov.title === provider) || providers[0];
}
function samlProviderToLoginProvider(saml) {
  return {
    name: saml.name,
    title: saml.name,
    url: saml.loginUrl
  };
}
function createProject(apiClient, options2) {
  return apiClient({
    requireUser: !0,
    requireProject: !1
  }).request({
    method: "POST",
    uri: "/projects",
    body: {
      ...options2,
      metadata: {
        ...options2?.metadata,
        integration: "cli"
      }
    }
  }).then((response) => ({
    projectId: response.projectId || response.id,
    displayName: options2.displayName || ""
  }));
}
const studioDependencies = {
  // Dependencies for a default Sanity installation
  dependencies: {
    // Official studio dependencies
    sanity: "latest",
    // Official studio plugin dependencies
    "@sanity/vision": "latest",
    // Non-Sanity dependencies
    react: "^19.1",
    "react-dom": "^19.1",
    "styled-components": "^6.1.18"
  },
  devDependencies: {
    // Linting/tooling
    "@sanity/eslint-config-studio": "latest",
    // When using typescript, we'll want the these types too, so might as well install them
    "@types/react": "^19.1",
    eslint: "^9.28",
    prettier: "^3.5",
    typescript: "^5.8"
    // Peer dependency of eslint-config-studio (implicitly)
  }
};
async function readdirRecursive(dir) {
  let content = [];
  const currentPath = path__default.default.resolve(dir), dirContent = (await fs__default.default.readdir(currentPath)).map((item) => path__default.default.join(currentPath, item));
  for (const subPath of dirContent) {
    const isDir2 = (await fs__default.default.stat(subPath)).isDirectory();
    content.push({ path: subPath, isDir: isDir2 }), isDir2 && (content = content.concat(await readdirRecursive(subPath)));
  }
  return content;
}
async function copy(srcPath, dstPath, options2) {
  const rename2 = options2?.rename, content = (await fs__default.default.stat(srcPath)).isDirectory() ? await readdirRecursive(srcPath) : [{ path: srcPath, isDir: !1 }], directories = content.filter((entry) => entry.isDir).sort((a, b) => b.path.length - a.path.length).sort((a, b) => a.path.localeCompare(b.path)).map((entry) => entry.path);
  for (const subDir of directories) {
    const relativePath = path__default.default.relative(srcPath, subDir), fullDstPath = path__default.default.join(dstPath, relativePath);
    await fs__default.default.mkdir(fullDstPath, { recursive: !0 });
  }
  const files = content.filter((entry) => !entry.isDir).sort((a, b) => b.path.length - a.path.length).sort((a, b) => a.path.localeCompare(b.path)).map((entry) => {
    const relativePath = path__default.default.relative(srcPath, entry.path), baseName = path__default.default.basename(relativePath), dirName = path__default.default.dirname(relativePath), dstName = rename2 ? rename2(baseName) : baseName, fullDstPath = path__default.default.join(dstPath, dirName, dstName);
    return { from: entry.path, to: fullDstPath };
  });
  for (const file of files)
    await fs__default.default.copyFile(file.from, file.to);
  return files.length;
}
function resolveLatestVersions(pkgs) {
  const lookups = {};
  for (const [packageName, range2] of Object.entries(pkgs))
    lookups[packageName] = range2 === "latest" ? latestVersion(packageName, { range: range2 }).then(caretify) : range2;
  return promiseProps(lookups);
}
function caretify(version2) {
  return version2 ? `^${version2}` : "latest";
}
var main$2 = {}, extendStatics$1 = function(d, b) {
  return extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) Object.prototype.hasOwnProperty.call(b2, p) && (d2[p] = b2[p]);
  }, extendStatics$1(d, b);
};
function __extends$1(d, b) {
  if (typeof b != "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$1(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  return __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
    }
    return t;
  }, __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
  return t;
}
function __decorate(decorators, target, key2, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") r = Reflect.decorate(decorators, target, key2, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key2, r) : d(target, key2)) || r);
  return c2 > 3 && r && Object.defineProperty(target, key2, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key2) {
    decorator(target, key2, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f != "function") throw new TypeError("Function expected");
    return f;
  }
  for (var kind = contextIn.kind, key2 = kind === "getter" ? "get" : kind === "setter" ? "set" : "value", target = !descriptorIn && ctor ? contextIn.static ? ctor : ctor.prototype : null, descriptor2 = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {}), _, done = !1, i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor2.get, set: descriptor2.set } : descriptor2[key2], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result != "object") throw new TypeError("Object expected");
      (_ = accept(result.get)) && (descriptor2.get = _), (_ = accept(result.set)) && (descriptor2.set = _), (_ = accept(result.init)) && initializers.unshift(_);
    } else (_ = accept(result)) && (kind === "field" ? initializers.unshift(_) : descriptor2[key2] = _);
  }
  target && Object.defineProperty(target, contextIn.name, descriptor2), done = !0;
}
function __runInitializers(thisArg, initializers, value) {
  for (var useValue = arguments.length > 2, i = 0; i < initializers.length; i++)
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x == "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  return typeof name == "symbol" && (name = name.description ? "[".concat(name.description, "]") : ""), Object.defineProperty(f, "name", { configurable: !0, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g.throw = verb(1), g.return = verb(2), typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    for (; g && (g = 0, op[0] && (_ = 0)), _; ) try {
      if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      switch (y = 0, t && (op = [op[0] & 2, t.value]), op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          return _.label++, { value: op[1], done: !1 };
        case 5:
          _.label++, y = op[1], op = [0];
          continue;
        case 7:
          op = _.ops.pop(), _.trys.pop();
          continue;
        default:
          if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1], t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2], _.ops.push(op);
            break;
          }
          t[2] && _.ops.pop(), _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e], y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: !0 };
  }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
  k2 === void 0 && (k2 = k);
  var desc = Object.getOwnPropertyDescriptor(m, k);
  (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
    return m[k];
  } }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  k2 === void 0 && (k2 = k), o[k2] = m[k];
};
function __exportStar(m, o) {
  for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(o, p) && __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol == "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length == "number") return {
    next: function() {
      return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol == "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    for (; (n === void 0 || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      r && !r.done && (m = i.return) && m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from2, pack2) {
  if (pack2 || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++)
    (ar || !(i in from2)) && (ar || (ar = Array.prototype.slice.call(from2, 0, i)), ar[i] = from2[i]);
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    g[n] && (i[n] = function(v) {
      return new Promise(function(a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    }, f && (i[n] = f(i[n])));
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    f(v), q.shift(), q.length && resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: !1 } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values == "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  return Object.defineProperty ? Object.defineProperty(cooked, "raw", { value: raw }) : cooked.raw = raw, cooked;
}
var __setModuleDefault = Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: !0, value: v });
} : function(o, v) {
  o.default = v;
}, ownKeys = function(o) {
  return ownKeys = Object.getOwnPropertyNames || function(o2) {
    var ar = [];
    for (var k in o2) Object.prototype.hasOwnProperty.call(o2, k) && (ar[ar.length] = k);
    return ar;
  }, ownKeys(o);
};
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) k[i] !== "default" && __createBinding(result, mod, k[i]);
  return __setModuleDefault(result, mod), result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver != "object" && typeof receiver != "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state == "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async2) {
  if (value != null) {
    if (typeof value != "object" && typeof value != "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async2) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose], async2 && (inner = dispose);
    }
    if (typeof dispose != "function") throw new TypeError("Object not disposable.");
    inner && (dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    }), env.stack.push({ value, dispose, async: async2 });
  } else async2 && env.stack.push({ async: !0 });
  return value;
}
var _SuppressedError = typeof SuppressedError == "function" ? SuppressedError : function(error2, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e, env.hasError = !0;
  }
  var r, s = 0;
  function next() {
    for (; r = env.stack.pop(); )
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
            return fail(e), next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path2, preserveJsx) {
  return typeof path2 == "string" && /^\.\.?\//.test(path2) ? path2.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext2, cm) {
    return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext2 || !cm) ? m : d + ext2 + "." + cm.toLowerCase() + "js";
  }) : path2;
}
var tslib_es6 = {
  __extends: __extends$1,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension
}, tslib_es6$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  __addDisposableResource,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldIn,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __disposeResources,
  __esDecorate,
  __exportStar,
  __extends: __extends$1,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __propKey,
  __read,
  __rest,
  __rewriteRelativeImportExtension,
  __runInitializers,
  __setFunctionName,
  __spread,
  __spreadArray,
  __spreadArrays,
  __values,
  default: tslib_es6
}), require$$0$3 = /* @__PURE__ */ loadEnv.getAugmentedNamespace(tslib_es6$1), main$1 = {}, fork = { exports: {} }, types$1 = { exports: {} }, shared = {}, hasRequiredShared;
function requireShared() {
  if (hasRequiredShared) return shared;
  hasRequiredShared = 1, Object.defineProperty(shared, "__esModule", { value: !0 }), shared.maybeSetModuleExports = void 0;
  var tslib_1 = require$$0$3, types_1 = tslib_1.__importDefault(requireTypes());
  function default_1(fork2) {
    var types2 = fork2.use(types_1.default), Type = types2.Type, builtin = types2.builtInTypes, isNumber2 = builtin.number;
    function geq(than) {
      return Type.from(function(value) {
        return isNumber2.check(value) && value >= than;
      }, isNumber2 + " >= " + than);
    }
    var defaults2 = {
      // Functions were used because (among other reasons) that's the most
      // elegant way to allow for the emptyArray one always to give a new
      // array instance.
      null: function() {
        return null;
      },
      emptyArray: function() {
        return [];
      },
      false: function() {
        return !1;
      },
      true: function() {
        return !0;
      },
      undefined: function() {
      },
      "use strict": function() {
        return "use strict";
      }
    }, naiveIsPrimitive = Type.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined), isPrimitive = Type.from(function(value) {
      if (value === null)
        return !0;
      var type2 = typeof value;
      return !(type2 === "object" || type2 === "function");
    }, naiveIsPrimitive.toString());
    return {
      geq,
      defaults: defaults2,
      isPrimitive
    };
  }
  shared.default = default_1;
  function maybeSetModuleExports(moduleGetter) {
    try {
      var nodeModule = moduleGetter(), originalExports = nodeModule.exports, defaultExport = originalExports.default;
    } catch {
      return;
    }
    defaultExport && defaultExport !== originalExports && typeof originalExports == "object" && (Object.assign(defaultExport, originalExports, { default: defaultExport }), originalExports.__esModule && Object.defineProperty(defaultExport, "__esModule", { value: !0 }), nodeModule.exports = defaultExport);
  }
  return shared.maybeSetModuleExports = maybeSetModuleExports, shared;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.Def = void 0;
    var tslib_1 = require$$0$3, shared_1 = requireShared(), Op = Object.prototype, objToStr = Op.toString, hasOwn = Op.hasOwnProperty, BaseType = (
      /** @class */
      function() {
        function BaseType2() {
        }
        return BaseType2.prototype.assert = function(value, deep) {
          if (!this.check(value, deep)) {
            var str2 = shallowStringify(value);
            throw new Error(str2 + " does not match type " + this);
          }
          return !0;
        }, BaseType2.prototype.arrayOf = function() {
          var elemType = this;
          return new ArrayType(elemType);
        }, BaseType2;
      }()
    ), ArrayType = (
      /** @class */
      function(_super) {
        tslib_1.__extends(ArrayType2, _super);
        function ArrayType2(elemType) {
          var _this = _super.call(this) || this;
          return _this.elemType = elemType, _this.kind = "ArrayType", _this;
        }
        return ArrayType2.prototype.toString = function() {
          return "[" + this.elemType + "]";
        }, ArrayType2.prototype.check = function(value, deep) {
          var _this = this;
          return Array.isArray(value) && value.every(function(elem) {
            return _this.elemType.check(elem, deep);
          });
        }, ArrayType2;
      }(BaseType)
    ), IdentityType = (
      /** @class */
      function(_super) {
        tslib_1.__extends(IdentityType2, _super);
        function IdentityType2(value) {
          var _this = _super.call(this) || this;
          return _this.value = value, _this.kind = "IdentityType", _this;
        }
        return IdentityType2.prototype.toString = function() {
          return String(this.value);
        }, IdentityType2.prototype.check = function(value, deep) {
          var result = value === this.value;
          return !result && typeof deep == "function" && deep(this, value), result;
        }, IdentityType2;
      }(BaseType)
    ), ObjectType = (
      /** @class */
      function(_super) {
        tslib_1.__extends(ObjectType2, _super);
        function ObjectType2(fields) {
          var _this = _super.call(this) || this;
          return _this.fields = fields, _this.kind = "ObjectType", _this;
        }
        return ObjectType2.prototype.toString = function() {
          return "{ " + this.fields.join(", ") + " }";
        }, ObjectType2.prototype.check = function(value, deep) {
          return objToStr.call(value) === objToStr.call({}) && this.fields.every(function(field) {
            return field.type.check(value[field.name], deep);
          });
        }, ObjectType2;
      }(BaseType)
    ), OrType = (
      /** @class */
      function(_super) {
        tslib_1.__extends(OrType2, _super);
        function OrType2(types2) {
          var _this = _super.call(this) || this;
          return _this.types = types2, _this.kind = "OrType", _this;
        }
        return OrType2.prototype.toString = function() {
          return this.types.join(" | ");
        }, OrType2.prototype.check = function(value, deep) {
          return this.types.some(function(type2) {
            return type2.check(value, !!deep);
          }) ? !0 : (typeof deep == "function" && deep(this, value), !1);
        }, OrType2;
      }(BaseType)
    ), PredicateType = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PredicateType2, _super);
        function PredicateType2(name, predicate) {
          var _this = _super.call(this) || this;
          return _this.name = name, _this.predicate = predicate, _this.kind = "PredicateType", _this;
        }
        return PredicateType2.prototype.toString = function() {
          return this.name;
        }, PredicateType2.prototype.check = function(value, deep) {
          var result = this.predicate(value, deep);
          return !result && typeof deep == "function" && deep(this, value), result;
        }, PredicateType2;
      }(BaseType)
    ), Def = (
      /** @class */
      function() {
        function Def2(type2, typeName) {
          this.type = type2, this.typeName = typeName, this.baseNames = [], this.ownFields = /* @__PURE__ */ Object.create(null), this.allSupertypes = /* @__PURE__ */ Object.create(null), this.supertypeList = [], this.allFields = /* @__PURE__ */ Object.create(null), this.fieldNames = [], this.finalized = !1, this.buildable = !1, this.buildParams = [];
        }
        return Def2.prototype.isSupertypeOf = function(that) {
          if (that instanceof Def2) {
            if (this.finalized !== !0 || that.finalized !== !0)
              throw new Error("");
            return hasOwn.call(that.allSupertypes, this.typeName);
          } else
            throw new Error(that + " is not a Def");
        }, Def2.prototype.checkAllFields = function(value, deep) {
          var allFields = this.allFields;
          if (this.finalized !== !0)
            throw new Error("" + this.typeName);
          function checkFieldByName(name) {
            var field = allFields[name], type2 = field.type, child = field.getValue(value);
            return type2.check(child, deep);
          }
          return value !== null && typeof value == "object" && Object.keys(allFields).every(checkFieldByName);
        }, Def2.prototype.bases = function() {
          for (var supertypeNames = [], _i = 0; _i < arguments.length; _i++)
            supertypeNames[_i] = arguments[_i];
          var bases = this.baseNames;
          if (this.finalized) {
            if (supertypeNames.length !== bases.length)
              throw new Error("");
            for (var i = 0; i < supertypeNames.length; i++)
              if (supertypeNames[i] !== bases[i])
                throw new Error("");
            return this;
          }
          return supertypeNames.forEach(function(baseName) {
            bases.indexOf(baseName) < 0 && bases.push(baseName);
          }), this;
        }, Def2;
      }()
    );
    exports2.Def = Def;
    var Field = (
      /** @class */
      function() {
        function Field2(name, type2, defaultFn, hidden) {
          this.name = name, this.type = type2, this.defaultFn = defaultFn, this.hidden = !!hidden;
        }
        return Field2.prototype.toString = function() {
          return JSON.stringify(this.name) + ": " + this.type;
        }, Field2.prototype.getValue = function(obj) {
          var value = obj[this.name];
          return typeof value < "u" || typeof this.defaultFn == "function" && (value = this.defaultFn.call(obj)), value;
        }, Field2;
      }()
    );
    function shallowStringify(value) {
      return Array.isArray(value) ? "[" + value.map(shallowStringify).join(", ") + "]" : value && typeof value == "object" ? "{ " + Object.keys(value).map(function(key2) {
        return key2 + ": " + value[key2];
      }).join(", ") + " }" : JSON.stringify(value);
    }
    function typesPlugin(_fork) {
      var Type = {
        or: function() {
          for (var types2 = [], _i = 0; _i < arguments.length; _i++)
            types2[_i] = arguments[_i];
          return new OrType(types2.map(function(type2) {
            return Type.from(type2);
          }));
        },
        from: function(value, name) {
          if (value instanceof ArrayType || value instanceof IdentityType || value instanceof ObjectType || value instanceof OrType || value instanceof PredicateType)
            return value;
          if (value instanceof Def)
            return value.type;
          if (isArray2.check(value)) {
            if (value.length !== 1)
              throw new Error("only one element type is permitted for typed arrays");
            return new ArrayType(Type.from(value[0]));
          }
          if (isObject2.check(value))
            return new ObjectType(Object.keys(value).map(function(name2) {
              return new Field(name2, Type.from(value[name2], name2));
            }));
          if (typeof value == "function") {
            var bicfIndex = builtInCtorFns.indexOf(value);
            if (bicfIndex >= 0)
              return builtInCtorTypes[bicfIndex];
            if (typeof name != "string")
              throw new Error("missing name");
            return new PredicateType(name, value);
          }
          return new IdentityType(value);
        },
        // Define a type whose name is registered in a namespace (the defCache) so
        // that future definitions will return the same type given the same name.
        // In particular, this system allows for circular and forward definitions.
        // The Def object d returned from Type.def may be used to configure the
        // type d.type by calling methods such as d.bases, d.build, and d.field.
        def: function(typeName) {
          return hasOwn.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);
        },
        hasDef: function(typeName) {
          return hasOwn.call(defCache, typeName);
        }
      }, builtInCtorFns = [], builtInCtorTypes = [];
      function defBuiltInType(name, example) {
        var objStr = objToStr.call(example), type2 = new PredicateType(name, function(value) {
          return objToStr.call(value) === objStr;
        });
        return example && typeof example.constructor == "function" && (builtInCtorFns.push(example.constructor), builtInCtorTypes.push(type2)), type2;
      }
      var isString = defBuiltInType("string", "truthy"), isFunction2 = defBuiltInType("function", function() {
      }), isArray2 = defBuiltInType("array", []), isObject2 = defBuiltInType("object", {}), isRegExp = defBuiltInType("RegExp", /./), isDate2 = defBuiltInType("Date", /* @__PURE__ */ new Date()), isNumber2 = defBuiltInType("number", 3), isBoolean = defBuiltInType("boolean", !0), isNull = defBuiltInType("null", null), isUndefined = defBuiltInType("undefined", void 0), isBigInt = typeof BigInt == "function" ? defBuiltInType("BigInt", BigInt(1234)) : new PredicateType("BigInt", function() {
        return !1;
      }), builtInTypes = {
        string: isString,
        function: isFunction2,
        array: isArray2,
        object: isObject2,
        RegExp: isRegExp,
        Date: isDate2,
        number: isNumber2,
        boolean: isBoolean,
        null: isNull,
        undefined: isUndefined,
        BigInt: isBigInt
      }, defCache = /* @__PURE__ */ Object.create(null);
      function defFromValue(value) {
        if (value && typeof value == "object") {
          var type2 = value.type;
          if (typeof type2 == "string" && hasOwn.call(defCache, type2)) {
            var d = defCache[type2];
            if (d.finalized)
              return d;
          }
        }
        return null;
      }
      var DefImpl = (
        /** @class */
        function(_super) {
          tslib_1.__extends(DefImpl2, _super);
          function DefImpl2(typeName) {
            var _this = _super.call(this, new PredicateType(typeName, function(value, deep) {
              return _this.check(value, deep);
            }), typeName) || this;
            return _this;
          }
          return DefImpl2.prototype.check = function(value, deep) {
            if (this.finalized !== !0)
              throw new Error("prematurely checking unfinalized type " + this.typeName);
            if (value === null || typeof value != "object")
              return !1;
            var vDef = defFromValue(value);
            return vDef ? deep && vDef === this ? this.checkAllFields(value, deep) : this.isSupertypeOf(vDef) ? deep ? vDef.checkAllFields(value, deep) && this.checkAllFields(value, !1) : !0 : !1 : this.typeName === "SourceLocation" || this.typeName === "Position" ? this.checkAllFields(value, deep) : !1;
          }, DefImpl2.prototype.build = function() {
            for (var _this = this, buildParams = [], _i = 0; _i < arguments.length; _i++)
              buildParams[_i] = arguments[_i];
            if (this.buildParams = buildParams, this.buildable)
              return this;
            this.field("type", String, function() {
              return _this.typeName;
            }), this.buildable = !0;
            var addParam = function(built, param, arg, isArgAvailable) {
              if (!hasOwn.call(built, param)) {
                var all = _this.allFields;
                if (!hasOwn.call(all, param))
                  throw new Error("" + param);
                var field = all[param], type2 = field.type, value;
                if (isArgAvailable)
                  value = arg;
                else if (field.defaultFn)
                  value = field.defaultFn.call(built);
                else {
                  var message = "no value or default function given for field " + JSON.stringify(param) + " of " + _this.typeName + "(" + _this.buildParams.map(function(name) {
                    return all[name];
                  }).join(", ") + ")";
                  throw new Error(message);
                }
                if (!type2.check(value))
                  throw new Error(shallowStringify(value) + " does not match field " + field + " of type " + _this.typeName);
                built[param] = value;
              }
            }, builder = function() {
              for (var args = [], _i2 = 0; _i2 < arguments.length; _i2++)
                args[_i2] = arguments[_i2];
              var argc = args.length;
              if (!_this.finalized)
                throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
              var built = Object.create(nodePrototype);
              if (_this.buildParams.forEach(function(param, i) {
                i < argc ? addParam(built, param, args[i], !0) : addParam(built, param, null, !1);
              }), Object.keys(_this.allFields).forEach(function(param) {
                addParam(built, param, null, !1);
              }), built.type !== _this.typeName)
                throw new Error("");
              return built;
            };
            return builder.from = function(obj) {
              if (!_this.finalized)
                throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
              var built = Object.create(nodePrototype);
              if (Object.keys(_this.allFields).forEach(function(param) {
                hasOwn.call(obj, param) ? addParam(built, param, obj[param], !0) : addParam(built, param, null, !1);
              }), built.type !== _this.typeName)
                throw new Error("");
              return built;
            }, Object.defineProperty(builders, getBuilderName(this.typeName), {
              enumerable: !0,
              value: builder
            }), this;
          }, DefImpl2.prototype.field = function(name, type2, defaultFn, hidden) {
            return this.finalized ? (console.error("Ignoring attempt to redefine field " + JSON.stringify(name) + " of finalized type " + JSON.stringify(this.typeName)), this) : (this.ownFields[name] = new Field(name, Type.from(type2), defaultFn, hidden), this);
          }, DefImpl2.prototype.finalize = function() {
            var _this = this;
            if (!this.finalized) {
              var allFields = this.allFields, allSupertypes = this.allSupertypes;
              this.baseNames.forEach(function(name) {
                var def = defCache[name];
                if (def instanceof Def)
                  def.finalize(), extend(allFields, def.allFields), extend(allSupertypes, def.allSupertypes);
                else {
                  var message = "unknown supertype name " + JSON.stringify(name) + " for subtype " + JSON.stringify(_this.typeName);
                  throw new Error(message);
                }
              }), extend(allFields, this.ownFields), allSupertypes[this.typeName] = this, this.fieldNames.length = 0;
              for (var fieldName in allFields)
                hasOwn.call(allFields, fieldName) && !allFields[fieldName].hidden && this.fieldNames.push(fieldName);
              Object.defineProperty(namedTypes2, this.typeName, {
                enumerable: !0,
                value: this.type
              }), this.finalized = !0, populateSupertypeList(this.typeName, this.supertypeList), this.buildable && this.supertypeList.lastIndexOf("Expression") >= 0 && wrapExpressionBuilderWithStatement(this.typeName);
            }
          }, DefImpl2;
        }(Def)
      );
      function getSupertypeNames(typeName) {
        if (!hasOwn.call(defCache, typeName))
          throw new Error("");
        var d = defCache[typeName];
        if (d.finalized !== !0)
          throw new Error("");
        return d.supertypeList.slice(1);
      }
      function computeSupertypeLookupTable(candidates) {
        for (var table = {}, typeNames = Object.keys(defCache), typeNameCount = typeNames.length, i = 0; i < typeNameCount; ++i) {
          var typeName = typeNames[i], d = defCache[typeName];
          if (d.finalized !== !0)
            throw new Error("" + typeName);
          for (var j = 0; j < d.supertypeList.length; ++j) {
            var superTypeName = d.supertypeList[j];
            if (hasOwn.call(candidates, superTypeName)) {
              table[typeName] = superTypeName;
              break;
            }
          }
        }
        return table;
      }
      var builders = /* @__PURE__ */ Object.create(null), nodePrototype = {};
      function defineMethod(name, func) {
        var old2 = nodePrototype[name];
        return isUndefined.check(func) ? delete nodePrototype[name] : (isFunction2.assert(func), Object.defineProperty(nodePrototype, name, {
          enumerable: !0,
          configurable: !0,
          value: func
        })), old2;
      }
      function getBuilderName(typeName) {
        return typeName.replace(/^[A-Z]+/, function(upperCasePrefix) {
          var len = upperCasePrefix.length;
          switch (len) {
            case 0:
              return "";
            // If there's only one initial capital letter, just lower-case it.
            case 1:
              return upperCasePrefix.toLowerCase();
            default:
              return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);
          }
        });
      }
      function getStatementBuilderName(typeName) {
        return typeName = getBuilderName(typeName), typeName.replace(/(Expression)?$/, "Statement");
      }
      var namedTypes2 = {};
      function getFieldNames(object) {
        var d = defFromValue(object);
        if (d)
          return d.fieldNames.slice(0);
        if ("type" in object)
          throw new Error("did not recognize object of type " + JSON.stringify(object.type));
        return Object.keys(object);
      }
      function getFieldValue(object, fieldName) {
        var d = defFromValue(object);
        if (d) {
          var field = d.allFields[fieldName];
          if (field)
            return field.getValue(object);
        }
        return object && object[fieldName];
      }
      function eachField(object, callback, context) {
        getFieldNames(object).forEach(function(name) {
          callback.call(this, name, getFieldValue(object, name));
        }, context);
      }
      function someField(object, callback, context) {
        return getFieldNames(object).some(function(name) {
          return callback.call(this, name, getFieldValue(object, name));
        }, context);
      }
      function wrapExpressionBuilderWithStatement(typeName) {
        var wrapperName = getStatementBuilderName(typeName);
        if (!builders[wrapperName]) {
          var wrapped = builders[getBuilderName(typeName)];
          if (wrapped) {
            var builder = function() {
              for (var args = [], _i = 0; _i < arguments.length; _i++)
                args[_i] = arguments[_i];
              return builders.expressionStatement(wrapped.apply(builders, args));
            };
            builder.from = function() {
              for (var args = [], _i = 0; _i < arguments.length; _i++)
                args[_i] = arguments[_i];
              return builders.expressionStatement(wrapped.from.apply(builders, args));
            }, builders[wrapperName] = builder;
          }
        }
      }
      function populateSupertypeList(typeName, list2) {
        list2.length = 0, list2.push(typeName);
        for (var lastSeen = /* @__PURE__ */ Object.create(null), pos2 = 0; pos2 < list2.length; ++pos2) {
          typeName = list2[pos2];
          var d = defCache[typeName];
          if (d.finalized !== !0)
            throw new Error("");
          hasOwn.call(lastSeen, typeName) && delete list2[lastSeen[typeName]], lastSeen[typeName] = pos2, list2.push.apply(list2, d.baseNames);
        }
        for (var to = 0, from2 = to, len = list2.length; from2 < len; ++from2)
          hasOwn.call(list2, from2) && (list2[to++] = list2[from2]);
        list2.length = to;
      }
      function extend(into, from2) {
        return Object.keys(from2).forEach(function(name) {
          into[name] = from2[name];
        }), into;
      }
      function finalize2() {
        Object.keys(defCache).forEach(function(name) {
          defCache[name].finalize();
        });
      }
      return {
        Type,
        builtInTypes,
        getSupertypeNames,
        computeSupertypeLookupTable,
        builders,
        defineMethod,
        getBuilderName,
        getStatementBuilderName,
        namedTypes: namedTypes2,
        getFieldNames,
        getFieldValue,
        eachField,
        someField,
        finalize: finalize2
      };
    }
    exports2.default = typesPlugin, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(types$1, types$1.exports)), types$1.exports;
}
var pathVisitor = { exports: {} }, nodePath = { exports: {} }, path$1 = { exports: {} }, hasRequiredPath;
function requirePath() {
  return hasRequiredPath || (hasRequiredPath = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, shared_1 = requireShared(), types_1 = tslib_1.__importDefault(requireTypes()), Op = Object.prototype, hasOwn = Op.hasOwnProperty;
    function pathPlugin(fork2) {
      var types2 = fork2.use(types_1.default), isArray2 = types2.builtInTypes.array, isNumber2 = types2.builtInTypes.number, Path = function Path2(value, parentPath, name) {
        if (!(this instanceof Path2))
          throw new Error("Path constructor cannot be invoked without 'new'");
        if (parentPath) {
          if (!(parentPath instanceof Path2))
            throw new Error("");
        } else
          parentPath = null, name = null;
        this.value = value, this.parentPath = parentPath, this.name = name, this.__childCache = null;
      }, Pp = Path.prototype;
      function getChildCache(path2) {
        return path2.__childCache || (path2.__childCache = /* @__PURE__ */ Object.create(null));
      }
      function getChildPath(path2, name) {
        var cache = getChildCache(path2), actualChildValue = path2.getValueProperty(name), childPath = cache[name];
        return (!hasOwn.call(cache, name) || // Ensure consistency between cache and reality.
        childPath.value !== actualChildValue) && (childPath = cache[name] = new path2.constructor(actualChildValue, path2, name)), childPath;
      }
      Pp.getValueProperty = function(name) {
        return this.value[name];
      }, Pp.get = function() {
        for (var names = [], _i = 0; _i < arguments.length; _i++)
          names[_i] = arguments[_i];
        for (var path2 = this, count2 = names.length, i = 0; i < count2; ++i)
          path2 = getChildPath(path2, names[i]);
        return path2;
      }, Pp.each = function(callback, context) {
        for (var childPaths = [], len = this.value.length, i = 0, i = 0; i < len; ++i)
          hasOwn.call(this.value, i) && (childPaths[i] = this.get(i));
        for (context = context || this, i = 0; i < len; ++i)
          hasOwn.call(childPaths, i) && callback.call(context, childPaths[i]);
      }, Pp.map = function(callback, context) {
        var result = [];
        return this.each(function(childPath) {
          result.push(callback.call(this, childPath));
        }, context), result;
      }, Pp.filter = function(callback, context) {
        var result = [];
        return this.each(function(childPath) {
          callback.call(this, childPath) && result.push(childPath);
        }, context), result;
      };
      function emptyMoves() {
      }
      function getMoves(path2, offset, start, end) {
        if (isArray2.assert(path2.value), offset === 0)
          return emptyMoves;
        var length = path2.value.length;
        if (length < 1)
          return emptyMoves;
        var argc = arguments.length;
        argc === 2 ? (start = 0, end = length) : argc === 3 ? (start = Math.max(start, 0), end = length) : (start = Math.max(start, 0), end = Math.min(end, length)), isNumber2.assert(start), isNumber2.assert(end);
        for (var moves = /* @__PURE__ */ Object.create(null), cache = getChildCache(path2), i = start; i < end; ++i)
          if (hasOwn.call(path2.value, i)) {
            var childPath = path2.get(i);
            if (childPath.name !== i)
              throw new Error("");
            var newIndex = i + offset;
            childPath.name = newIndex, moves[newIndex] = childPath, delete cache[i];
          }
        return delete cache.length, function() {
          for (var newIndex2 in moves) {
            var childPath2 = moves[newIndex2];
            if (childPath2.name !== +newIndex2)
              throw new Error("");
            cache[newIndex2] = childPath2, path2.value[newIndex2] = childPath2.value;
          }
        };
      }
      Pp.shift = function() {
        var move = getMoves(this, -1), result = this.value.shift();
        return move(), result;
      }, Pp.unshift = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        var move = getMoves(this, args.length), result = this.value.unshift.apply(this.value, args);
        return move(), result;
      }, Pp.push = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        return isArray2.assert(this.value), delete getChildCache(this).length, this.value.push.apply(this.value, args);
      }, Pp.pop = function() {
        isArray2.assert(this.value);
        var cache = getChildCache(this);
        return delete cache[this.value.length - 1], delete cache.length, this.value.pop();
      }, Pp.insertAt = function(index) {
        var argc = arguments.length, move = getMoves(this, argc - 1, index);
        if (move === emptyMoves && argc <= 1)
          return this;
        index = Math.max(index, 0);
        for (var i = 1; i < argc; ++i)
          this.value[index + i - 1] = arguments[i];
        return move(), this;
      }, Pp.insertBefore = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        for (var pp = this.parentPath, argc = args.length, insertAtArgs = [this.name], i = 0; i < argc; ++i)
          insertAtArgs.push(args[i]);
        return pp.insertAt.apply(pp, insertAtArgs);
      }, Pp.insertAfter = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        for (var pp = this.parentPath, argc = args.length, insertAtArgs = [this.name + 1], i = 0; i < argc; ++i)
          insertAtArgs.push(args[i]);
        return pp.insertAt.apply(pp, insertAtArgs);
      };
      function repairRelationshipWithParent(path2) {
        if (!(path2 instanceof Path))
          throw new Error("");
        var pp = path2.parentPath;
        if (!pp)
          return path2;
        var parentValue = pp.value, parentCache = getChildCache(pp);
        if (parentValue[path2.name] === path2.value)
          parentCache[path2.name] = path2;
        else if (isArray2.check(parentValue)) {
          var i = parentValue.indexOf(path2.value);
          i >= 0 && (parentCache[path2.name = i] = path2);
        } else
          parentValue[path2.name] = path2.value, parentCache[path2.name] = path2;
        if (parentValue[path2.name] !== path2.value)
          throw new Error("");
        if (path2.parentPath.get(path2.name) !== path2)
          throw new Error("");
        return path2;
      }
      return Pp.replace = function(replacement) {
        var results = [], parentValue = this.parentPath.value, parentCache = getChildCache(this.parentPath), count2 = arguments.length;
        if (repairRelationshipWithParent(this), isArray2.check(parentValue)) {
          for (var originalLength = parentValue.length, move = getMoves(this.parentPath, count2 - 1, this.name + 1), spliceArgs = [this.name, 1], i = 0; i < count2; ++i)
            spliceArgs.push(arguments[i]);
          var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);
          if (splicedOut[0] !== this.value)
            throw new Error("");
          if (parentValue.length !== originalLength - 1 + count2)
            throw new Error("");
          if (move(), count2 === 0)
            delete this.value, delete parentCache[this.name], this.__childCache = null;
          else {
            if (parentValue[this.name] !== replacement)
              throw new Error("");
            for (this.value !== replacement && (this.value = replacement, this.__childCache = null), i = 0; i < count2; ++i)
              results.push(this.parentPath.get(this.name + i));
            if (results[0] !== this)
              throw new Error("");
          }
        } else if (count2 === 1)
          this.value !== replacement && (this.__childCache = null), this.value = parentValue[this.name] = replacement, results.push(this);
        else if (count2 === 0)
          delete parentValue[this.name], delete this.value, this.__childCache = null;
        else
          throw new Error("Could not replace path");
        return results;
      }, Path;
    }
    exports2.default = pathPlugin, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(path$1, path$1.exports)), path$1.exports;
}
var scope = { exports: {} }, hasRequiredScope;
function requireScope() {
  return hasRequiredScope || (hasRequiredScope = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, shared_1 = requireShared(), types_1 = tslib_1.__importDefault(requireTypes()), hasOwn = Object.prototype.hasOwnProperty;
    function scopePlugin(fork2) {
      var types2 = fork2.use(types_1.default), Type = types2.Type, namedTypes2 = types2.namedTypes, Node = namedTypes2.Node, Expression = namedTypes2.Expression, isArray2 = types2.builtInTypes.array, b = types2.builders, Scope = function Scope2(path2, parentScope) {
        if (!(this instanceof Scope2))
          throw new Error("Scope constructor cannot be invoked without 'new'");
        TypeParameterScopeType.check(path2.value) || ScopeType.assert(path2.value);
        var depth;
        if (parentScope) {
          if (!(parentScope instanceof Scope2))
            throw new Error("");
          depth = parentScope.depth + 1;
        } else
          parentScope = null, depth = 0;
        Object.defineProperties(this, {
          path: { value: path2 },
          node: { value: path2.value },
          isGlobal: { value: !parentScope, enumerable: !0 },
          depth: { value: depth },
          parent: { value: parentScope },
          bindings: { value: {} },
          types: { value: {} }
        });
      }, ScopeType = Type.or(
        // Program nodes introduce global scopes.
        namedTypes2.Program,
        // Function is the supertype of FunctionExpression,
        // FunctionDeclaration, ArrowExpression, etc.
        namedTypes2.Function,
        // In case you didn't know, the caught parameter shadows any variable
        // of the same name in an outer scope.
        namedTypes2.CatchClause
      ), TypeParameterScopeType = Type.or(namedTypes2.Function, namedTypes2.ClassDeclaration, namedTypes2.ClassExpression, namedTypes2.InterfaceDeclaration, namedTypes2.TSInterfaceDeclaration, namedTypes2.TypeAlias, namedTypes2.TSTypeAliasDeclaration), FlowOrTSTypeParameterType = Type.or(namedTypes2.TypeParameter, namedTypes2.TSTypeParameter);
      Scope.isEstablishedBy = function(node) {
        return ScopeType.check(node) || TypeParameterScopeType.check(node);
      };
      var Sp = Scope.prototype;
      Sp.didScan = !1, Sp.declares = function(name) {
        return this.scan(), hasOwn.call(this.bindings, name);
      }, Sp.declaresType = function(name) {
        return this.scan(), hasOwn.call(this.types, name);
      }, Sp.declareTemporary = function(prefix) {
        if (prefix) {
          if (!/^[a-z$_]/i.test(prefix))
            throw new Error("");
        } else
          prefix = "t$";
        prefix += this.depth.toString(36) + "$", this.scan();
        for (var index = 0; this.declares(prefix + index); )
          ++index;
        var name = prefix + index;
        return this.bindings[name] = types2.builders.identifier(name);
      }, Sp.injectTemporary = function(identifier, init) {
        identifier || (identifier = this.declareTemporary());
        var bodyPath = this.path.get("body");
        return namedTypes2.BlockStatement.check(bodyPath.value) && (bodyPath = bodyPath.get("body")), bodyPath.unshift(b.variableDeclaration("var", [b.variableDeclarator(identifier, init || null)])), identifier;
      }, Sp.scan = function(force) {
        if (force || !this.didScan) {
          for (var name in this.bindings)
            delete this.bindings[name];
          for (var name in this.types)
            delete this.types[name];
          scanScope(this.path, this.bindings, this.types), this.didScan = !0;
        }
      }, Sp.getBindings = function() {
        return this.scan(), this.bindings;
      }, Sp.getTypes = function() {
        return this.scan(), this.types;
      };
      function scanScope(path2, bindings, scopeTypes) {
        var node = path2.value;
        if (TypeParameterScopeType.check(node)) {
          var params = path2.get("typeParameters", "params");
          isArray2.check(params.value) && params.each(function(childPath) {
            addTypeParameter(childPath, scopeTypes);
          });
        }
        ScopeType.check(node) && (namedTypes2.CatchClause.check(node) ? addPattern(path2.get("param"), bindings) : recursiveScanScope(path2, bindings, scopeTypes));
      }
      function recursiveScanScope(path2, bindings, scopeTypes) {
        var node = path2.value;
        path2.parent && namedTypes2.FunctionExpression.check(path2.parent.node) && path2.parent.node.id && addPattern(path2.parent.get("id"), bindings), node && (isArray2.check(node) ? path2.each(function(childPath) {
          recursiveScanChild(childPath, bindings, scopeTypes);
        }) : namedTypes2.Function.check(node) ? (path2.get("params").each(function(paramPath) {
          addPattern(paramPath, bindings);
        }), recursiveScanChild(path2.get("body"), bindings, scopeTypes), recursiveScanScope(path2.get("typeParameters"), bindings, scopeTypes)) : namedTypes2.TypeAlias && namedTypes2.TypeAlias.check(node) || namedTypes2.InterfaceDeclaration && namedTypes2.InterfaceDeclaration.check(node) || namedTypes2.TSTypeAliasDeclaration && namedTypes2.TSTypeAliasDeclaration.check(node) || namedTypes2.TSInterfaceDeclaration && namedTypes2.TSInterfaceDeclaration.check(node) ? addTypePattern(path2.get("id"), scopeTypes) : namedTypes2.VariableDeclarator.check(node) ? (addPattern(path2.get("id"), bindings), recursiveScanChild(path2.get("init"), bindings, scopeTypes)) : node.type === "ImportSpecifier" || node.type === "ImportNamespaceSpecifier" || node.type === "ImportDefaultSpecifier" ? addPattern(
          // Esprima used to use the .name field to refer to the local
          // binding identifier for ImportSpecifier nodes, but .id for
          // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.
          // ESTree/Acorn/ESpree use .local for all three node types.
          path2.get(node.local ? "local" : node.name ? "name" : "id"),
          bindings
        ) : Node.check(node) && !Expression.check(node) && types2.eachField(node, function(name, child) {
          var childPath = path2.get(name);
          if (!pathHasValue(childPath, child))
            throw new Error("");
          recursiveScanChild(childPath, bindings, scopeTypes);
        }));
      }
      function pathHasValue(path2, value) {
        return !!(path2.value === value || Array.isArray(path2.value) && path2.value.length === 0 && Array.isArray(value) && value.length === 0);
      }
      function recursiveScanChild(path2, bindings, scopeTypes) {
        var node = path2.value;
        if (!(!node || Expression.check(node))) if (namedTypes2.FunctionDeclaration.check(node) && node.id !== null)
          addPattern(path2.get("id"), bindings);
        else if (namedTypes2.ClassDeclaration && namedTypes2.ClassDeclaration.check(node) && node.id !== null)
          addPattern(path2.get("id"), bindings), recursiveScanScope(path2.get("typeParameters"), bindings, scopeTypes);
        else if (namedTypes2.InterfaceDeclaration && namedTypes2.InterfaceDeclaration.check(node) || namedTypes2.TSInterfaceDeclaration && namedTypes2.TSInterfaceDeclaration.check(node))
          addTypePattern(path2.get("id"), scopeTypes);
        else if (ScopeType.check(node)) {
          if (namedTypes2.CatchClause.check(node) && // TODO Broaden this to accept any pattern.
          namedTypes2.Identifier.check(node.param)) {
            var catchParamName = node.param.name, hadBinding = hasOwn.call(bindings, catchParamName);
            recursiveScanScope(path2.get("body"), bindings, scopeTypes), hadBinding || delete bindings[catchParamName];
          }
        } else
          recursiveScanScope(path2, bindings, scopeTypes);
      }
      function addPattern(patternPath, bindings) {
        var pattern = patternPath.value;
        namedTypes2.Pattern.assert(pattern), namedTypes2.Identifier.check(pattern) ? hasOwn.call(bindings, pattern.name) ? bindings[pattern.name].push(patternPath) : bindings[pattern.name] = [patternPath] : namedTypes2.AssignmentPattern && namedTypes2.AssignmentPattern.check(pattern) ? addPattern(patternPath.get("left"), bindings) : namedTypes2.ObjectPattern && namedTypes2.ObjectPattern.check(pattern) ? patternPath.get("properties").each(function(propertyPath) {
          var property = propertyPath.value;
          namedTypes2.Pattern.check(property) ? addPattern(propertyPath, bindings) : namedTypes2.Property.check(property) || namedTypes2.ObjectProperty && namedTypes2.ObjectProperty.check(property) ? addPattern(propertyPath.get("value"), bindings) : namedTypes2.SpreadProperty && namedTypes2.SpreadProperty.check(property) && addPattern(propertyPath.get("argument"), bindings);
        }) : namedTypes2.ArrayPattern && namedTypes2.ArrayPattern.check(pattern) ? patternPath.get("elements").each(function(elementPath) {
          var element = elementPath.value;
          namedTypes2.Pattern.check(element) ? addPattern(elementPath, bindings) : namedTypes2.SpreadElement && namedTypes2.SpreadElement.check(element) && addPattern(elementPath.get("argument"), bindings);
        }) : namedTypes2.PropertyPattern && namedTypes2.PropertyPattern.check(pattern) ? addPattern(patternPath.get("pattern"), bindings) : (namedTypes2.SpreadElementPattern && namedTypes2.SpreadElementPattern.check(pattern) || namedTypes2.RestElement && namedTypes2.RestElement.check(pattern) || namedTypes2.SpreadPropertyPattern && namedTypes2.SpreadPropertyPattern.check(pattern)) && addPattern(patternPath.get("argument"), bindings);
      }
      function addTypePattern(patternPath, types3) {
        var pattern = patternPath.value;
        namedTypes2.Pattern.assert(pattern), namedTypes2.Identifier.check(pattern) && (hasOwn.call(types3, pattern.name) ? types3[pattern.name].push(patternPath) : types3[pattern.name] = [patternPath]);
      }
      function addTypeParameter(parameterPath, types3) {
        var parameter = parameterPath.value;
        FlowOrTSTypeParameterType.assert(parameter), hasOwn.call(types3, parameter.name) ? types3[parameter.name].push(parameterPath) : types3[parameter.name] = [parameterPath];
      }
      return Sp.lookup = function(name) {
        for (var scope2 = this; scope2 && !scope2.declares(name); scope2 = scope2.parent)
          ;
        return scope2;
      }, Sp.lookupType = function(name) {
        for (var scope2 = this; scope2 && !scope2.declaresType(name); scope2 = scope2.parent)
          ;
        return scope2;
      }, Sp.getGlobalScope = function() {
        for (var scope2 = this; !scope2.isGlobal; )
          scope2 = scope2.parent;
        return scope2;
      }, Scope;
    }
    exports2.default = scopePlugin, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(scope, scope.exports)), scope.exports;
}
var hasRequiredNodePath;
function requireNodePath() {
  return hasRequiredNodePath || (hasRequiredNodePath = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, types_1 = tslib_1.__importDefault(requireTypes()), path_1 = tslib_1.__importDefault(requirePath()), scope_1 = tslib_1.__importDefault(requireScope()), shared_1 = requireShared();
    function nodePathPlugin(fork2) {
      var types2 = fork2.use(types_1.default), n = types2.namedTypes, b = types2.builders, isNumber2 = types2.builtInTypes.number, isArray2 = types2.builtInTypes.array, Path = fork2.use(path_1.default), Scope = fork2.use(scope_1.default), NodePath = function NodePath2(value, parentPath, name) {
        if (!(this instanceof NodePath2))
          throw new Error("NodePath constructor cannot be invoked without 'new'");
        Path.call(this, value, parentPath, name);
      }, NPp = NodePath.prototype = Object.create(Path.prototype, {
        constructor: {
          value: NodePath,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      });
      Object.defineProperties(NPp, {
        node: {
          get: function() {
            return Object.defineProperty(this, "node", {
              configurable: !0,
              value: this._computeNode()
            }), this.node;
          }
        },
        parent: {
          get: function() {
            return Object.defineProperty(this, "parent", {
              configurable: !0,
              value: this._computeParent()
            }), this.parent;
          }
        },
        scope: {
          get: function() {
            return Object.defineProperty(this, "scope", {
              configurable: !0,
              value: this._computeScope()
            }), this.scope;
          }
        }
      }), NPp.replace = function() {
        return delete this.node, delete this.parent, delete this.scope, Path.prototype.replace.apply(this, arguments);
      }, NPp.prune = function() {
        var remainingNodePath = this.parent;
        return this.replace(), cleanUpNodesAfterPrune(remainingNodePath);
      }, NPp._computeNode = function() {
        var value = this.value;
        if (n.Node.check(value))
          return value;
        var pp = this.parentPath;
        return pp && pp.node || null;
      }, NPp._computeParent = function() {
        var value = this.value, pp = this.parentPath;
        if (!n.Node.check(value)) {
          for (; pp && !n.Node.check(pp.value); )
            pp = pp.parentPath;
          pp && (pp = pp.parentPath);
        }
        for (; pp && !n.Node.check(pp.value); )
          pp = pp.parentPath;
        return pp || null;
      }, NPp._computeScope = function() {
        var value = this.value, pp = this.parentPath, scope2 = pp && pp.scope;
        return n.Node.check(value) && Scope.isEstablishedBy(value) && (scope2 = new Scope(this, scope2)), scope2 || null;
      }, NPp.getValueProperty = function(name) {
        return types2.getFieldValue(this.value, name);
      }, NPp.needsParens = function(assumeExpressionContext) {
        var pp = this.parentPath;
        if (!pp)
          return !1;
        var node = this.value;
        if (!n.Expression.check(node) || node.type === "Identifier")
          return !1;
        for (; !n.Node.check(pp.value); )
          if (pp = pp.parentPath, !pp)
            return !1;
        var parent = pp.value;
        switch (node.type) {
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
            return parent.type === "MemberExpression" && this.name === "object" && parent.object === node;
          case "BinaryExpression":
          case "LogicalExpression":
            switch (parent.type) {
              case "CallExpression":
                return this.name === "callee" && parent.callee === node;
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
                return !0;
              case "MemberExpression":
                return this.name === "object" && parent.object === node;
              case "BinaryExpression":
              case "LogicalExpression": {
                var n_1 = node, po = parent.operator, pp_1 = PRECEDENCE[po], no = n_1.operator, np = PRECEDENCE[no];
                if (pp_1 > np)
                  return !0;
                if (pp_1 === np && this.name === "right") {
                  if (parent.right !== n_1)
                    throw new Error("Nodes must be equal");
                  return !0;
                }
              }
              default:
                return !1;
            }
          case "SequenceExpression":
            switch (parent.type) {
              case "ForStatement":
                return !1;
              case "ExpressionStatement":
                return this.name !== "expression";
              default:
                return !0;
            }
          case "YieldExpression":
            switch (parent.type) {
              case "BinaryExpression":
              case "LogicalExpression":
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "CallExpression":
              case "MemberExpression":
              case "NewExpression":
              case "ConditionalExpression":
              case "YieldExpression":
                return !0;
              default:
                return !1;
            }
          case "Literal":
            return parent.type === "MemberExpression" && isNumber2.check(node.value) && this.name === "object" && parent.object === node;
          case "AssignmentExpression":
          case "ConditionalExpression":
            switch (parent.type) {
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "BinaryExpression":
              case "LogicalExpression":
                return !0;
              case "CallExpression":
                return this.name === "callee" && parent.callee === node;
              case "ConditionalExpression":
                return this.name === "test" && parent.test === node;
              case "MemberExpression":
                return this.name === "object" && parent.object === node;
              default:
                return !1;
            }
          default:
            if (parent.type === "NewExpression" && this.name === "callee" && parent.callee === node)
              return containsCallExpression(node);
        }
        return !!(assumeExpressionContext !== !0 && !this.canBeFirstInStatement() && this.firstInStatement());
      };
      function isBinary(node) {
        return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);
      }
      var PRECEDENCE = {};
      [
        ["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"]
      ].forEach(function(tier, i) {
        tier.forEach(function(op) {
          PRECEDENCE[op] = i;
        });
      });
      function containsCallExpression(node) {
        return n.CallExpression.check(node) ? !0 : isArray2.check(node) ? node.some(containsCallExpression) : n.Node.check(node) ? types2.someField(node, function(_name, child) {
          return containsCallExpression(child);
        }) : !1;
      }
      NPp.canBeFirstInStatement = function() {
        var node = this.node;
        return !n.FunctionExpression.check(node) && !n.ObjectExpression.check(node);
      }, NPp.firstInStatement = function() {
        return firstInStatement(this);
      };
      function firstInStatement(path2) {
        for (var node, parent; path2.parent; path2 = path2.parent) {
          if (node = path2.node, parent = path2.parent.node, n.BlockStatement.check(parent) && path2.parent.name === "body" && path2.name === 0) {
            if (parent.body[0] !== node)
              throw new Error("Nodes must be equal");
            return !0;
          }
          if (n.ExpressionStatement.check(parent) && path2.name === "expression") {
            if (parent.expression !== node)
              throw new Error("Nodes must be equal");
            return !0;
          }
          if (n.SequenceExpression.check(parent) && path2.parent.name === "expressions" && path2.name === 0) {
            if (parent.expressions[0] !== node)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (n.CallExpression.check(parent) && path2.name === "callee") {
            if (parent.callee !== node)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (n.MemberExpression.check(parent) && path2.name === "object") {
            if (parent.object !== node)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (n.ConditionalExpression.check(parent) && path2.name === "test") {
            if (parent.test !== node)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (isBinary(parent) && path2.name === "left") {
            if (parent.left !== node)
              throw new Error("Nodes must be equal");
            continue;
          }
          if (n.UnaryExpression.check(parent) && !parent.prefix && path2.name === "argument") {
            if (parent.argument !== node)
              throw new Error("Nodes must be equal");
            continue;
          }
          return !1;
        }
        return !0;
      }
      function cleanUpNodesAfterPrune(remainingNodePath) {
        if (n.VariableDeclaration.check(remainingNodePath.node)) {
          var declarations = remainingNodePath.get("declarations").value;
          if (!declarations || declarations.length === 0)
            return remainingNodePath.prune();
        } else if (n.ExpressionStatement.check(remainingNodePath.node)) {
          if (!remainingNodePath.get("expression").value)
            return remainingNodePath.prune();
        } else n.IfStatement.check(remainingNodePath.node) && cleanUpIfStatementAfterPrune(remainingNodePath);
        return remainingNodePath;
      }
      function cleanUpIfStatementAfterPrune(ifStatement) {
        var testExpression = ifStatement.get("test").value, alternate = ifStatement.get("alternate").value, consequent = ifStatement.get("consequent").value;
        if (!consequent && !alternate) {
          var testExpressionStatement = b.expressionStatement(testExpression);
          ifStatement.replace(testExpressionStatement);
        } else if (!consequent && alternate) {
          var negatedTestExpression = b.unaryExpression("!", testExpression, !0);
          n.UnaryExpression.check(testExpression) && testExpression.operator === "!" && (negatedTestExpression = testExpression.argument), ifStatement.get("test").replace(negatedTestExpression), ifStatement.get("consequent").replace(alternate), ifStatement.get("alternate").replace();
        }
      }
      return NodePath;
    }
    exports2.default = nodePathPlugin, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(nodePath, nodePath.exports)), nodePath.exports;
}
var hasRequiredPathVisitor;
function requirePathVisitor() {
  return hasRequiredPathVisitor || (hasRequiredPathVisitor = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, types_1 = tslib_1.__importDefault(requireTypes()), node_path_1 = tslib_1.__importDefault(requireNodePath()), shared_1 = requireShared(), hasOwn = Object.prototype.hasOwnProperty;
    function pathVisitorPlugin(fork2) {
      var types2 = fork2.use(types_1.default), NodePath = fork2.use(node_path_1.default), isArray2 = types2.builtInTypes.array, isObject2 = types2.builtInTypes.object, isFunction2 = types2.builtInTypes.function, undefined$1, PathVisitor = function PathVisitor2() {
        if (!(this instanceof PathVisitor2))
          throw new Error("PathVisitor constructor cannot be invoked without 'new'");
        this._reusableContextStack = [], this._methodNameTable = computeMethodNameTable(this), this._shouldVisitComments = hasOwn.call(this._methodNameTable, "Block") || hasOwn.call(this._methodNameTable, "Line"), this.Context = makeContextConstructor(this), this._visiting = !1, this._changeReported = !1;
      };
      function computeMethodNameTable(visitor) {
        var typeNames = /* @__PURE__ */ Object.create(null);
        for (var methodName in visitor)
          /^visit[A-Z]/.test(methodName) && (typeNames[methodName.slice(5)] = !0);
        for (var supertypeTable = types2.computeSupertypeLookupTable(typeNames), methodNameTable = /* @__PURE__ */ Object.create(null), typeNameKeys = Object.keys(supertypeTable), typeNameCount = typeNameKeys.length, i = 0; i < typeNameCount; ++i) {
          var typeName = typeNameKeys[i];
          methodName = "visit" + supertypeTable[typeName], isFunction2.check(visitor[methodName]) && (methodNameTable[typeName] = methodName);
        }
        return methodNameTable;
      }
      PathVisitor.fromMethodsObject = function(methods) {
        if (methods instanceof PathVisitor)
          return methods;
        if (!isObject2.check(methods))
          return new PathVisitor();
        var Visitor = function Visitor2() {
          if (!(this instanceof Visitor2))
            throw new Error("Visitor constructor cannot be invoked without 'new'");
          PathVisitor.call(this);
        }, Vp = Visitor.prototype = Object.create(PVp);
        return Vp.constructor = Visitor, extend(Vp, methods), extend(Visitor, PathVisitor), isFunction2.assert(Visitor.fromMethodsObject), isFunction2.assert(Visitor.visit), new Visitor();
      };
      function extend(target, source2) {
        for (var property in source2)
          hasOwn.call(source2, property) && (target[property] = source2[property]);
        return target;
      }
      PathVisitor.visit = function(node, methods) {
        return PathVisitor.fromMethodsObject(methods).visit(node);
      };
      var PVp = PathVisitor.prototype;
      PVp.visit = function() {
        if (this._visiting)
          throw new Error("Recursively calling visitor.visit(path) resets visitor state. Try this.visit(path) or this.traverse(path) instead.");
        this._visiting = !0, this._changeReported = !1, this._abortRequested = !1;
        for (var argc = arguments.length, args = new Array(argc), i = 0; i < argc; ++i)
          args[i] = arguments[i];
        args[0] instanceof NodePath || (args[0] = new NodePath({ root: args[0] }).get("root")), this.reset.apply(this, args);
        var didNotThrow;
        try {
          var root2 = this.visitWithoutReset(args[0]);
          didNotThrow = !0;
        } finally {
          if (this._visiting = !1, !didNotThrow && this._abortRequested)
            return args[0].value;
        }
        return root2;
      }, PVp.AbortRequest = function() {
      }, PVp.abort = function() {
        var visitor = this;
        visitor._abortRequested = !0;
        var request = new visitor.AbortRequest();
        throw request.cancel = function() {
          visitor._abortRequested = !1;
        }, request;
      }, PVp.reset = function(_path) {
      }, PVp.visitWithoutReset = function(path2) {
        if (this instanceof this.Context)
          return this.visitor.visitWithoutReset(path2);
        if (!(path2 instanceof NodePath))
          throw new Error("");
        var value = path2.value, methodName = value && typeof value == "object" && typeof value.type == "string" && this._methodNameTable[value.type];
        if (methodName) {
          var context = this.acquireContext(path2);
          try {
            return context.invokeVisitorMethod(methodName);
          } finally {
            this.releaseContext(context);
          }
        } else
          return visitChildren(path2, this);
      };
      function visitChildren(path2, visitor) {
        if (!(path2 instanceof NodePath))
          throw new Error("");
        if (!(visitor instanceof PathVisitor))
          throw new Error("");
        var value = path2.value;
        if (isArray2.check(value))
          path2.each(visitor.visitWithoutReset, visitor);
        else if (isObject2.check(value)) {
          var childNames = types2.getFieldNames(value);
          visitor._shouldVisitComments && value.comments && childNames.indexOf("comments") < 0 && childNames.push("comments");
          for (var childCount = childNames.length, childPaths = [], i = 0; i < childCount; ++i) {
            var childName = childNames[i];
            hasOwn.call(value, childName) || (value[childName] = types2.getFieldValue(value, childName)), childPaths.push(path2.get(childName));
          }
          for (var i = 0; i < childCount; ++i)
            visitor.visitWithoutReset(childPaths[i]);
        }
        return path2.value;
      }
      PVp.acquireContext = function(path2) {
        return this._reusableContextStack.length === 0 ? new this.Context(path2) : this._reusableContextStack.pop().reset(path2);
      }, PVp.releaseContext = function(context) {
        if (!(context instanceof this.Context))
          throw new Error("");
        this._reusableContextStack.push(context), context.currentPath = null;
      }, PVp.reportChanged = function() {
        this._changeReported = !0;
      }, PVp.wasChangeReported = function() {
        return this._changeReported;
      };
      function makeContextConstructor(visitor) {
        function Context2(path2) {
          if (!(this instanceof Context2))
            throw new Error("");
          if (!(this instanceof PathVisitor))
            throw new Error("");
          if (!(path2 instanceof NodePath))
            throw new Error("");
          Object.defineProperty(this, "visitor", {
            value: visitor,
            writable: !1,
            enumerable: !0,
            configurable: !1
          }), this.currentPath = path2, this.needToCallTraverse = !0, Object.seal(this);
        }
        if (!(visitor instanceof PathVisitor))
          throw new Error("");
        var Cp = Context2.prototype = Object.create(visitor);
        return Cp.constructor = Context2, extend(Cp, sharedContextProtoMethods), Context2;
      }
      var sharedContextProtoMethods = /* @__PURE__ */ Object.create(null);
      return sharedContextProtoMethods.reset = function(path2) {
        if (!(this instanceof this.Context))
          throw new Error("");
        if (!(path2 instanceof NodePath))
          throw new Error("");
        return this.currentPath = path2, this.needToCallTraverse = !0, this;
      }, sharedContextProtoMethods.invokeVisitorMethod = function(methodName) {
        if (!(this instanceof this.Context))
          throw new Error("");
        if (!(this.currentPath instanceof NodePath))
          throw new Error("");
        var result = this.visitor[methodName].call(this, this.currentPath);
        if (result === !1 ? this.needToCallTraverse = !1 : result !== undefined$1 && (this.currentPath = this.currentPath.replace(result)[0], this.needToCallTraverse && this.traverse(this.currentPath)), this.needToCallTraverse !== !1)
          throw new Error("Must either call this.traverse or return false in " + methodName);
        var path2 = this.currentPath;
        return path2 && path2.value;
      }, sharedContextProtoMethods.traverse = function(path2, newVisitor) {
        if (!(this instanceof this.Context))
          throw new Error("");
        if (!(path2 instanceof NodePath))
          throw new Error("");
        if (!(this.currentPath instanceof NodePath))
          throw new Error("");
        return this.needToCallTraverse = !1, visitChildren(path2, PathVisitor.fromMethodsObject(newVisitor || this.visitor));
      }, sharedContextProtoMethods.visit = function(path2, newVisitor) {
        if (!(this instanceof this.Context))
          throw new Error("");
        if (!(path2 instanceof NodePath))
          throw new Error("");
        if (!(this.currentPath instanceof NodePath))
          throw new Error("");
        return this.needToCallTraverse = !1, PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path2);
      }, sharedContextProtoMethods.reportChanged = function() {
        this.visitor.reportChanged();
      }, sharedContextProtoMethods.abort = function() {
        this.needToCallTraverse = !1, this.visitor.abort();
      }, PathVisitor;
    }
    exports2.default = pathVisitorPlugin, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(pathVisitor, pathVisitor.exports)), pathVisitor.exports;
}
var equiv = { exports: {} }, hasRequiredEquiv;
function requireEquiv() {
  return hasRequiredEquiv || (hasRequiredEquiv = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, shared_1 = requireShared(), types_1 = tslib_1.__importDefault(requireTypes());
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default), getFieldNames = types2.getFieldNames, getFieldValue = types2.getFieldValue, isArray2 = types2.builtInTypes.array, isObject2 = types2.builtInTypes.object, isDate2 = types2.builtInTypes.Date, isRegExp = types2.builtInTypes.RegExp, hasOwn = Object.prototype.hasOwnProperty;
      function astNodesAreEquivalent(a, b, problemPath) {
        return isArray2.check(problemPath) ? problemPath.length = 0 : problemPath = null, areEquivalent(a, b, problemPath);
      }
      astNodesAreEquivalent.assert = function(a, b) {
        var problemPath = [];
        if (!astNodesAreEquivalent(a, b, problemPath))
          if (problemPath.length === 0) {
            if (a !== b)
              throw new Error("Nodes must be equal");
          } else
            throw new Error("Nodes differ in the following path: " + problemPath.map(subscriptForProperty).join(""));
      };
      function subscriptForProperty(property) {
        return /[_$a-z][_$a-z0-9]*/i.test(property) ? "." + property : "[" + JSON.stringify(property) + "]";
      }
      function areEquivalent(a, b, problemPath) {
        return a === b ? !0 : isArray2.check(a) ? arraysAreEquivalent(a, b, problemPath) : isObject2.check(a) ? objectsAreEquivalent(a, b, problemPath) : isDate2.check(a) ? isDate2.check(b) && +a == +b : isRegExp.check(a) ? isRegExp.check(b) && a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.ignoreCase === b.ignoreCase : a == b;
      }
      function arraysAreEquivalent(a, b, problemPath) {
        isArray2.assert(a);
        var aLength = a.length;
        if (!isArray2.check(b) || b.length !== aLength)
          return problemPath && problemPath.push("length"), !1;
        for (var i = 0; i < aLength; ++i) {
          if (problemPath && problemPath.push(i), i in a != i in b || !areEquivalent(a[i], b[i], problemPath))
            return !1;
          if (problemPath) {
            var problemPathTail = problemPath.pop();
            if (problemPathTail !== i)
              throw new Error("" + problemPathTail);
          }
        }
        return !0;
      }
      function objectsAreEquivalent(a, b, problemPath) {
        if (isObject2.assert(a), !isObject2.check(b))
          return !1;
        if (a.type !== b.type)
          return problemPath && problemPath.push("type"), !1;
        var aNames = getFieldNames(a), aNameCount = aNames.length, bNames = getFieldNames(b), bNameCount = bNames.length;
        if (aNameCount === bNameCount) {
          for (var i = 0; i < aNameCount; ++i) {
            var name = aNames[i], aChild = getFieldValue(a, name), bChild = getFieldValue(b, name);
            if (problemPath && problemPath.push(name), !areEquivalent(aChild, bChild, problemPath))
              return !1;
            if (problemPath) {
              var problemPathTail = problemPath.pop();
              if (problemPathTail !== name)
                throw new Error("" + problemPathTail);
            }
          }
          return !0;
        }
        if (!problemPath)
          return !1;
        var seenNames = /* @__PURE__ */ Object.create(null);
        for (i = 0; i < aNameCount; ++i)
          seenNames[aNames[i]] = !0;
        for (i = 0; i < bNameCount; ++i) {
          if (name = bNames[i], !hasOwn.call(seenNames, name))
            return problemPath.push(name), !1;
          delete seenNames[name];
        }
        for (name in seenNames) {
          problemPath.push(name);
          break;
        }
        return !1;
      }
      return astNodesAreEquivalent;
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(equiv, equiv.exports)), equiv.exports;
}
var hasRequiredFork;
function requireFork() {
  return hasRequiredFork || (hasRequiredFork = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, types_1 = tslib_1.__importDefault(requireTypes()), path_visitor_1 = tslib_1.__importDefault(requirePathVisitor()), equiv_1 = tslib_1.__importDefault(requireEquiv()), path_1 = tslib_1.__importDefault(requirePath()), node_path_1 = tslib_1.__importDefault(requireNodePath()), shared_1 = requireShared();
    function default_1(plugins) {
      var fork2 = createFork(), types2 = fork2.use(types_1.default);
      plugins.forEach(fork2.use), types2.finalize();
      var PathVisitor = fork2.use(path_visitor_1.default);
      return {
        Type: types2.Type,
        builtInTypes: types2.builtInTypes,
        namedTypes: types2.namedTypes,
        builders: types2.builders,
        defineMethod: types2.defineMethod,
        getFieldNames: types2.getFieldNames,
        getFieldValue: types2.getFieldValue,
        eachField: types2.eachField,
        someField: types2.someField,
        getSupertypeNames: types2.getSupertypeNames,
        getBuilderName: types2.getBuilderName,
        astNodesAreEquivalent: fork2.use(equiv_1.default),
        finalize: types2.finalize,
        Path: fork2.use(path_1.default),
        NodePath: fork2.use(node_path_1.default),
        PathVisitor,
        use: fork2.use,
        visit: PathVisitor.visit
      };
    }
    exports2.default = default_1;
    function createFork() {
      var used = [], usedResult = [];
      function use(plugin) {
        var idx = used.indexOf(plugin);
        return idx === -1 && (idx = used.length, used.push(plugin), usedResult[idx] = plugin(fork2)), usedResult[idx];
      }
      var fork2 = { use };
      return fork2;
    }
    (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(fork, fork.exports)), fork.exports;
}
var esProposals = { exports: {} }, es2022 = { exports: {} }, es2021$1 = { exports: {} }, es2021 = { exports: {} }, es2020$1 = { exports: {} }, es2016$1 = { exports: {} }, core$1 = { exports: {} }, hasRequiredCore$1;
function requireCore$1() {
  return hasRequiredCore$1 || (hasRequiredCore$1 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var shared_1 = requireShared();
    function default_1() {
      return {
        BinaryOperators: [
          "==",
          "!=",
          "===",
          "!==",
          "<",
          "<=",
          ">",
          ">=",
          "<<",
          ">>",
          ">>>",
          "+",
          "-",
          "*",
          "/",
          "%",
          "&",
          "|",
          "^",
          "in",
          "instanceof"
        ],
        AssignmentOperators: [
          "=",
          "+=",
          "-=",
          "*=",
          "/=",
          "%=",
          "<<=",
          ">>=",
          ">>>=",
          "|=",
          "^=",
          "&="
        ],
        LogicalOperators: [
          "||",
          "&&"
        ]
      };
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(core$1, core$1.exports)), core$1.exports;
}
var hasRequiredEs2016$1;
function requireEs2016$1() {
  return hasRequiredEs2016$1 || (hasRequiredEs2016$1 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, shared_1 = requireShared(), core_1 = tslib_1.__importDefault(requireCore$1());
    function default_1(fork2) {
      var result = fork2.use(core_1.default);
      return result.BinaryOperators.indexOf("**") < 0 && result.BinaryOperators.push("**"), result.AssignmentOperators.indexOf("**=") < 0 && result.AssignmentOperators.push("**="), result;
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2016$1, es2016$1.exports)), es2016$1.exports;
}
var hasRequiredEs2020$1;
function requireEs2020$1() {
  return hasRequiredEs2020$1 || (hasRequiredEs2020$1 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, shared_1 = requireShared(), es2016_1 = tslib_1.__importDefault(requireEs2016$1());
    function default_1(fork2) {
      var result = fork2.use(es2016_1.default);
      return result.LogicalOperators.indexOf("??") < 0 && result.LogicalOperators.push("??"), result;
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2020$1, es2020$1.exports)), es2020$1.exports;
}
var hasRequiredEs2021$1;
function requireEs2021$1() {
  return hasRequiredEs2021$1 || (hasRequiredEs2021$1 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, shared_1 = requireShared(), es2020_1 = tslib_1.__importDefault(requireEs2020$1());
    function default_1(fork2) {
      var result = fork2.use(es2020_1.default);
      return result.LogicalOperators.forEach(function(op) {
        var assignOp = op + "=";
        result.AssignmentOperators.indexOf(assignOp) < 0 && result.AssignmentOperators.push(assignOp);
      }), result;
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(es2021, es2021.exports)), es2021.exports;
}
var es2020 = { exports: {} }, es2019 = { exports: {} }, es2018 = { exports: {} }, es2017 = { exports: {} }, es2016 = { exports: {} }, es6 = { exports: {} }, core = { exports: {} }, hasRequiredCore;
function requireCore() {
  return hasRequiredCore || (hasRequiredCore = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, core_1 = tslib_1.__importDefault(requireCore$1()), types_1 = tslib_1.__importDefault(requireTypes()), shared_1 = tslib_1.__importStar(requireShared());
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default), Type = types2.Type, def = Type.def, or = Type.or, shared2 = fork2.use(shared_1.default), defaults2 = shared2.defaults, geq = shared2.geq, _a = fork2.use(core_1.default), BinaryOperators = _a.BinaryOperators, AssignmentOperators = _a.AssignmentOperators, LogicalOperators = _a.LogicalOperators;
      def("Printable").field("loc", or(def("SourceLocation"), null), defaults2.null, !0), def("Node").bases("Printable").field("type", String).field("comments", or([def("Comment")], null), defaults2.null, !0), def("SourceLocation").field("start", def("Position")).field("end", def("Position")).field("source", or(String, null), defaults2.null), def("Position").field("line", geq(1)).field("column", geq(0)), def("File").bases("Node").build("program", "name").field("program", def("Program")).field("name", or(String, null), defaults2.null), def("Program").bases("Node").build("body").field("body", [def("Statement")]), def("Function").bases("Node").field("id", or(def("Identifier"), null), defaults2.null).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("generator", Boolean, defaults2.false).field("async", Boolean, defaults2.false), def("Statement").bases("Node"), def("EmptyStatement").bases("Statement").build(), def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]), def("ExpressionStatement").bases("Statement").build("expression").field("expression", def("Expression")), def("IfStatement").bases("Statement").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Statement")).field("alternate", or(def("Statement"), null), defaults2.null), def("LabeledStatement").bases("Statement").build("label", "body").field("label", def("Identifier")).field("body", def("Statement")), def("BreakStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults2.null), def("ContinueStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults2.null), def("WithStatement").bases("Statement").build("object", "body").field("object", def("Expression")).field("body", def("Statement")), def("SwitchStatement").bases("Statement").build("discriminant", "cases", "lexical").field("discriminant", def("Expression")).field("cases", [def("SwitchCase")]).field("lexical", Boolean, defaults2.false), def("ReturnStatement").bases("Statement").build("argument").field("argument", or(def("Expression"), null)), def("ThrowStatement").bases("Statement").build("argument").field("argument", def("Expression")), def("TryStatement").bases("Statement").build("block", "handler", "finalizer").field("block", def("BlockStatement")).field("handler", or(def("CatchClause"), null), function() {
        return this.handlers && this.handlers[0] || null;
      }).field("handlers", [def("CatchClause")], function() {
        return this.handler ? [this.handler] : [];
      }, !0).field("guardedHandlers", [def("CatchClause")], defaults2.emptyArray).field("finalizer", or(def("BlockStatement"), null), defaults2.null), def("CatchClause").bases("Node").build("param", "guard", "body").field("param", def("Pattern")).field("guard", or(def("Expression"), null), defaults2.null).field("body", def("BlockStatement")), def("WhileStatement").bases("Statement").build("test", "body").field("test", def("Expression")).field("body", def("Statement")), def("DoWhileStatement").bases("Statement").build("body", "test").field("body", def("Statement")).field("test", def("Expression")), def("ForStatement").bases("Statement").build("init", "test", "update", "body").field("init", or(def("VariableDeclaration"), def("Expression"), null)).field("test", or(def("Expression"), null)).field("update", or(def("Expression"), null)).field("body", def("Statement")), def("ForInStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement")), def("DebuggerStatement").bases("Statement").build(), def("Declaration").bases("Statement"), def("FunctionDeclaration").bases("Function", "Declaration").build("id", "params", "body").field("id", def("Identifier")), def("FunctionExpression").bases("Function", "Expression").build("id", "params", "body"), def("VariableDeclaration").bases("Declaration").build("kind", "declarations").field("kind", or("var", "let", "const")).field("declarations", [def("VariableDeclarator")]), def("VariableDeclarator").bases("Node").build("id", "init").field("id", def("Pattern")).field("init", or(def("Expression"), null), defaults2.null), def("Expression").bases("Node"), def("ThisExpression").bases("Expression").build(), def("ArrayExpression").bases("Expression").build("elements").field("elements", [or(def("Expression"), null)]), def("ObjectExpression").bases("Expression").build("properties").field("properties", [def("Property")]), def("Property").bases("Node").build("kind", "key", "value").field("kind", or("init", "get", "set")).field("key", or(def("Literal"), def("Identifier"))).field("value", def("Expression")), def("SequenceExpression").bases("Expression").build("expressions").field("expressions", [def("Expression")]);
      var UnaryOperator = or("-", "+", "!", "~", "typeof", "void", "delete");
      def("UnaryExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UnaryOperator).field("argument", def("Expression")).field("prefix", Boolean, defaults2.true);
      var BinaryOperator = or.apply(void 0, BinaryOperators);
      def("BinaryExpression").bases("Expression").build("operator", "left", "right").field("operator", BinaryOperator).field("left", def("Expression")).field("right", def("Expression"));
      var AssignmentOperator = or.apply(void 0, AssignmentOperators);
      def("AssignmentExpression").bases("Expression").build("operator", "left", "right").field("operator", AssignmentOperator).field("left", or(def("Pattern"), def("MemberExpression"))).field("right", def("Expression"));
      var UpdateOperator = or("++", "--");
      def("UpdateExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UpdateOperator).field("argument", def("Expression")).field("prefix", Boolean);
      var LogicalOperator = or.apply(void 0, LogicalOperators);
      def("LogicalExpression").bases("Expression").build("operator", "left", "right").field("operator", LogicalOperator).field("left", def("Expression")).field("right", def("Expression")), def("ConditionalExpression").bases("Expression").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Expression")).field("alternate", def("Expression")), def("NewExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]), def("CallExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]), def("MemberExpression").bases("Expression").build("object", "property", "computed").field("object", def("Expression")).field("property", or(def("Identifier"), def("Expression"))).field("computed", Boolean, function() {
        var type2 = this.property.type;
        return type2 === "Literal" || type2 === "MemberExpression" || type2 === "BinaryExpression";
      }), def("Pattern").bases("Node"), def("SwitchCase").bases("Node").build("test", "consequent").field("test", or(def("Expression"), null)).field("consequent", [def("Statement")]), def("Identifier").bases("Expression", "Pattern").build("name").field("name", String).field("optional", Boolean, defaults2.false), def("Literal").bases("Expression").build("value").field("value", or(String, Boolean, null, Number, RegExp, BigInt)), def("Comment").bases("Printable").field("value", String).field("leading", Boolean, defaults2.true).field("trailing", Boolean, defaults2.false);
    }
    exports2.default = default_1, (0, shared_1.maybeSetModuleExports)(function() {
      return module2;
    });
  }(core, core.exports)), core.exports;
}
var hasRequiredEs6;
function requireEs6() {
  return hasRequiredEs6 || (hasRequiredEs6 = 1, function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var tslib_1 = require$$0$3, core_1 = tslib_1.__importDefault(requireCore()), types_1 = tslib_1.__importDefault(requireTypes()), shared_1 = tslib_1.__importStar(requireShared());
    function default_1(fork2) {
      fork2.use(core_1.default);
      var types2 = fork2.use(types_1.default), def = types2.Type.def, or = types2.Type.or, defaults2 = fork2.use(shared_1.default).defaults;
      def("Function").field("generator", Boolean, defaults2.false).field("expression", Boolean, defaults2.false).field("defaults", [or(def("Expression"), null)], defaults2.emptyArray).field("rest", or(def("Identifier"), null), defaults2.null), def("RestElement").bases("Pattern").build("argument").field("argument", def("Pattern")).field(
        "typeAnnotation",
        // for Babylon. Flow parser puts it on the identifier
        or(def("TypeAnnotation"), def("TSTypeAnnotation"), null),
        defaults2.null
      ), def("SpreadElementPattern").bases("Pattern").build("argument").field("argument", def("Pattern")), def("FunctionDeclaration").build("id", "params", "body", "generator", "expression").field("id", or(def("Identifier"), null)), def("Functio